using IGX.Geometry.Common;
using IGX.Geometry.DataStructure;
using IGX.ViewControl.Buffer;
using IGX.ViewControl.Buffer.Common;
using IGX.ViewControl.Render.Materials;
using System.Runtime.InteropServices;

namespace IGX.ViewControl.Render
{
    public class RendererData
    {
        private readonly object _lockObject = new();
        private readonly List<Vertex> _vertices;
        private readonly List<uint> _triIndices;
        private readonly List<uint> _edgeIndices;
        private readonly List<MeshInstanceGL> _instInstances;
        private readonly List<MatColInstance> _matColInstances;
        private readonly List<DrawElementsIndirectCommand> _commands;
        private readonly List<DrawElementsIndirectCommand> _edgeCommands;

        public int ModelId { get; }
        public IReadOnlyList<Vertex> Vertices => _vertices.AsReadOnly();
        public IReadOnlyList<uint> TriIndices => _triIndices.AsReadOnly();
        public IReadOnlyList<uint> EdgeIndices => _edgeIndices.AsReadOnly();
        public IReadOnlyList<MeshInstanceGL> InstInstances => _instInstances.AsReadOnly();
        public IReadOnlyList<MatColInstance> matColInstances => _matColInstances.AsReadOnly();
        public IReadOnlyList<DrawElementsIndirectCommand> Commands => _commands.AsReadOnly();
        public IReadOnlyList<DrawElementsIndirectCommand> EdgeCommands => _edgeCommands.AsReadOnly();
        public AABB3 ModelAabb { get; set; } = AABB3.Empty;
        public void AddVertices(IEnumerable<Vertex> vertices) => _vertices.AddRange(vertices);
        public void AddTriIndices(IEnumerable<uint> face_Indices) => _triIndices.AddRange(face_Indices);
        public void AddEdgeIndices(IEnumerable<uint> edgeIndices) => _edgeIndices.AddRange(edgeIndices);
        public void AddCommand(DrawElementsIndirectCommand command) => _commands.Add(command);
        public void AddEdgeCommand(DrawElementsIndirectCommand command) => _edgeCommands.Add(command);
        public void AddInstance(GeometryInstance instanceData, string grandType) => _instInstances.Add(new(instanceData, grandType));
        public void AddCommands(DrawElementsIndirectCommand command) => _commands.Add(command);
        public void UploadVertices(VertexBuffer<Vertex> vertexBuffer)
        {
            lock (_lockObject)
            {
                if (_vertices.Count == 0)
                {
                    Console.WriteLine("Warning: No vertices to upload.");
                    return;
                }
                var span = CollectionsMarshal.AsSpan(_vertices);
                vertexBuffer.UpdateData(span);
            }
        }
        public void UploadTriIndices(MutableBuffer<uint> indexBuffer)
        {
            lock (_lockObject)
            {
                if (_triIndices.Count == 0)
                {
                    Console.WriteLine("Warning: No triangle indices to upload.");
                    return;
                }
                var span = CollectionsMarshal.AsSpan(_triIndices);
                indexBuffer.UpdateData(span);
            }
        }
        public void UploadCommands(IndirectBuffer<DrawElementsIndirectCommand> commandBuffer)
        {
            lock (_lockObject)
            {
                if (_commands.Count == 0)
                {
                    Console.WriteLine("Warning: No triangle commands to upload.");
                    return;
                }
                var span = CollectionsMarshal.AsSpan(_commands);
                commandBuffer.UpdateCommands(0, span);
            }
        }
        public void UploadEdgeCommands(IndirectBuffer<DrawElementsIndirectCommand> commandBuffer)
        {
            lock (_lockObject)
            {
                if (_edgeCommands.Count == 0)
                {
                    Console.WriteLine("Warning: No edge commands to upload.");
                    return;
                }
                var span = CollectionsMarshal.AsSpan(_edgeCommands);
                commandBuffer.UpdateCommands(0, span);
            }
        }
        private void ValidateIndices(IEnumerable<uint> indices, string paramName)
        {
            foreach (var index in indices)
            {
                if (index >= (uint)_vertices.Count)
                {
                    throw new ArgumentException($"Index {index} is out of bounds for vertices count {_vertices.Count}.", paramName);
                }
            }
        }
        private void ValidateCommand(DrawElementsIndirectCommand command, string paramName)
        {
            if (command.firstIndex + command.count > (uint)_triIndices.Count)
            {
                throw new ArgumentException($"Command accesses out-of-bounds indices: firstIndex={command.firstIndex}, count={command.count}, indices count={_triIndices.Count}.", paramName);
            }
        }
        public RendererData(int modelId, int initialVertexCapacity = 1000, int initialIndexCapacity = 3000)
        {
            ModelId = modelId;
            _vertices = new List<Vertex>(initialVertexCapacity);
            _triIndices = new List<uint>(initialIndexCapacity);
            _edgeIndices = new List<uint>(initialIndexCapacity);
            _instInstances = new List<MeshInstanceGL>(100);
            _matColInstances = new List<MatColInstance>(100);
            _commands = new List<DrawElementsIndirectCommand>(100);
            _edgeCommands = new List<DrawElementsIndirectCommand>(100);
        }
    }
}
