using System;
using System.Collections.Generic;
using System.Linq;
using IGX.Geometry.ConvexHull;
using IGX.Geometry.Intersect;
using OpenTK.Mathematics;

namespace IGX.Geometry.Common
{
    /// <summary>
    /// 선분을 선의 중점과 방향 및 extent 값으로 표현
    /// </summary>
    public struct Segment3f
    {
        public Vector3 center;
        public Vector3 direction;
        public float extent;

        AABB3 box;

        public AABB3 Bound
        {
            get { return GetBounds(); }
        }

        public float Extent
        {
            get { return extent; }
        }

        public float Length
        {
            get { return 2 * extent; }
        }

        public Vector3 P0
        {
            get { return center - (extent * direction); }
        }

        public Vector3 P1
        {
            get { return center + (extent * direction); }
        }

        public Segment3f(bool bZero = true)
        {
            center = Vector3.Zero;
            direction = Vector3.Zero;
            extent = 0;
            box = AABB3.Empty;
        }

        public Segment3f(Vector3 p0, Vector3 p1)
        {
            center = 0.5f * (p0 + p1);
            direction = p1 - p0;
            extent = 0.5f * direction.Length;
            direction = Vector3.Normalize(direction);
            box = new AABB3(p0, p1);
            //box = GetBounds();
        }

        public Segment3f(Vector3 center, Vector3 direction, float extent)
        {
            this.center = center;
            this.direction = direction;
            this.extent = extent;
            box = new AABB3(-extent * direction, extent * direction);
            //box = GetBounds();
        }

        public OOBB3 GetOOBB(float radius = 0.1f)
        {
            return new OOBB3(this, radius);
        }
        public bool Intersect(OOBB3 oobb, ref List<Vector3> intersections)
        {
            intersections.Clear(); // 이전 교차점 정보 초기화
            Vector3 direction = P1 - P0;
            Matrix3 Orientation = new(oobb.axisX, oobb.axisY, oobb.axisZ);
            Matrix3 inverseOrientation = Orientation.Inverted();

            // Segment의 끝점이 Oobb 내부에 있는지 확인하고 추가
            if (IsPointInOOBB(inverseOrientation, oobb.center, P0, oobb.extent))
            {
                intersections.Add(P0);
            }
            if (IsPointInOOBB(inverseOrientation, oobb.center, P1, oobb.extent))
            {
                intersections.Add(P1);
            }

            for (int i = 0; i < 3; i++)
            {
                for (int sign = -1; sign <= 1; sign += 2)
                {
                    Vector3 normal = i == 0 ? oobb.axisX : i == 1 ? oobb.axisY : oobb.axisZ;
                    normal *= sign;
                    Vector3 planePoint = oobb.center + (oobb.extent[i] * normal);

                    float denominator = Vector3.Dot(normal, direction);
                    if (MathF.Abs(denominator) > 1e-6f)
                    {
                        float t = Vector3.Dot(normal, planePoint - P0) / denominator;
                        if (t >= 0 && t <= 1)
                        {
                            Vector3 intersection = P0 + (t * direction);
                            // 교차점이 Oobb 면 위에 있는지 확인 (중복 방지)
                            if (IsPointOnOOBBFace(Orientation, oobb.center, intersection, oobb.extent, i, sign) && !intersections.Any(p => (p - intersection).LengthSquared < 1e-6f))
                            {
                                intersections.Add(intersection);
                            }
                        }
                    }
                }
            }

            intersections = intersections.Distinct().ToList();
            return intersections.Count > 0;
        }

        private static bool IsPointInOOBB(Matrix3 inverseOrient, Vector3 center, Vector3 point, Vector3 extent)
        {
            Vector3 localPoint = (point - center) * inverseOrient;
            return MathF.Abs(localPoint.X) <= extent.X + 1e-6f &&
                   MathF.Abs(localPoint.Y) <= extent.Y + 1e-6f &&
                   MathF.Abs(localPoint.Z) <= extent.Z + 1e-6f;
        }

        private static bool IsPointOnOOBBFace(Matrix3 Orient, Vector3 center, Vector3 point, Vector3 extent, int axisIndex, int sign)
        {
            Matrix3 o = Orient.Inverted();
            Vector3 localPoint = (point - center) * o;
            float faceValue = extent[axisIndex] * sign;

            if (MathF.Abs(localPoint[axisIndex] - faceValue) > 1e-6f)
            {
                return false;
            }

            for (int i = 0; i < 3; i++)
            {
                if (i != axisIndex && MathF.Abs(localPoint[i]) > extent[i] + 1e-6f)
                {
                    return false;
                }
            }
            return true;
        }

        public float Distance(Vector3 P)
        {
            Vector3 v = P1 - P0;
            Vector3 w = P - P0;

            float c1 = Vector3.Dot(w, v);
            if (c1 <= 0)
            {
                return P.DistanceTo(P0);
            }

            float c2 = Vector3.Dot(v, v);
            if (c2 <= c1)
            {
                return P.DistanceTo(P1);
            }

            float b = c1 / c2;
            Vector3 Pb = P0 + (b * v);
            return P.DistanceTo(Pb);
        }

        /// <summary>
        /// this segment와 other segment간 최단 거리 계산
        /// </summary>
        /// <param name="other"></param>
        /// <param name="eps"></param>
        /// <returns></returns>
        public float Distance(Segment3f other, float eps = MathUtil.Epsilon)
        {
            Vector3 u = P1 - P0;
            Vector3 v = other.P1 - other.P0;
            Vector3 w = P0 - other.P0;
            float a = Vector3.Dot(u, u); //  >= 0
            float b = Vector3.Dot(u, v);
            float c = Vector3.Dot(v, v); //  >= 0
            float d = Vector3.Dot(u, w);
            float e = Vector3.Dot(v, w);
            float D = (a * c) - (b * b);//  >= 0
            float sc, sN, sD = D; // sc = sN / sD, default sD = D >= 0
            float tc, tN, tD = D; // tc = tN / tD, default tD = D >= 0

            if (D < eps)
            {
                sN = 0.0f; // this 선분의 P0
                sD = 1.0f; // zero devide 회피 목적
                tN = e;
                tD = c;
            }
            else
            {
                sN = (b * e) - (c * d);
                tN = (a * e) - (b * d);
                if (sN < 0.0)
                {   // sc < 0 => s=0 hedge
                    sN = 0.0f;
                    tN = e;
                    tD = c;
                }
                else if (sN > sD)
                {  // sc > 1  => s=1 hedge
                    sN = sD;
                    tN = e + b;
                    tD = c;
                }
            }

            if (tN < 0.0f)
            {   // tc < 0 => t=0 hedge
                tN = 0.0f;
                if (-d < 0.0f)
                {
                    sN = 0.0f;
                }
                else if (-d > a)
                {
                    sN = sD;
                }
                else
                {
                    sN = -d;
                    sD = a;
                }
            }
            else if (tN > tD)
            {      // tc > 1  => t=1 hedge
                tN = tD;
                if (-d + b < 0.0)
                {
                    sN = 0;
                }
                else if (-d + b > a)
                {
                    sN = sD;
                }
                else
                {
                    sN = -d + b;
                    sD = a;
                }
            }
            // sc, tc 계산
            sc = Math.Abs(sN) < eps ? 0.0f : sN / sD;
            tc = Math.Abs(tN) < eps ? 0.0f : tN / tD;

            Vector3 dP = w + (sc * u) - (tc * v);  // =  S1(sc) - S2(tc)

            return dP.Length;   // return the closest DistanceManager
        }

        public float DistanceNormal(Vector3 P)
        {
            return (direction * Vector3.Dot(direction, P)).DistanceTo(P);
        }

        public float DistanceSquared(Vector3 P)
        {
            Vector3 v = P1 - P0;
            Vector3 w = P - P0;

            float c1 = Vector3.Dot(w, v);
            if (c1 <= 0)
            {
                return P.DistanceSquared(P0);
            }

            float c2 = Vector3.Dot(v, v);
            if (c2 <= c1)
            {
                return P.DistanceSquared(P1);
            }

            float b = c1 / c2;
            Vector3 Pb = P0 + (b * v);
            return P.DistanceSquared(Pb);
        }

        public Segment2f Get2dSegment(int igc)
        {
            Vector2 p0 = new();
            Vector2 p1 = new();

            switch (igc)
            {
                case 0:
                    p0 = P0.Yz();
                    p1 = P1.Yz();
                    break;
                case 1:
                    p0 = P0.Zx();
                    p1 = P1.Zx();
                    break;
                case 2:
                    p0 = P0.Xy();
                    p1 = P1.Xy();
                    break;
            }
            return new Segment2f(p0, p1);
        }

        //private AABB3 GetBounds()
        //{
        //    if (direction == Vector3.Zero)
        //        return AABB3.Empty;

        //    AABB3 bx = new AABB3(P0);
        //    return bx;
        //}

        public float GetParameter(Vector3 P)
        {
            return Vector3.Dot(direction, P - P0);
        }

        public Vector3 GetPointAt(float t)
        {
            return center + (((2f * t) - 1f) * extent * direction);
        }

        public Segment3f Reverse()
        {
            return new Segment3f(P1, P0);
        }

        public void UpdateFromEndpoints(Vector3 p0, Vector3 p1)
        {
            direction = p1 - p0;
            center = (p0 + p1) * 0.5f;
            extent = extent = 0.5f * direction.Length;
            direction = Vector3.Normalize(direction);
        }

        public override string ToString()
        {
            return string.Format("{0}, {1}", P0, P1);
        }

        public string ToString(string fmt)
        {
            return string.Format("{0}, {1}", P0.ToString(fmt), P1.ToString(fmt));
        }

        /// <summary>
        /// 방향이 같고 겹치는 부분이 있는지 확인
        /// </summary>
        /// <param name="seg1"></param>
        /// <param name="seg2"></param>
        /// <returns></returns>
        public bool AreInNearSeg(Segment3f other, float tol = 1e-6f)
        {
            //방향이 같고 인접한 포인트가 하나라도 있으면 트루
            float ang = this.direction.AngleDeg(other.direction);

            if (ang < tol)
            {
                float d10 = this.Distance(other.P0);
                float d11 = this.Distance(other.P1);
                float d20 = other.Distance(this.P0);
                float d21 = other.Distance(this.P1);

                List<float> dd = new() { d10, d11, d20, d21 };
                if (dd.Min() < tol)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// 겹치는 부분이 있는지 확인(연결된 경우 제외)
        /// </summary>
        /// <param name="other"></param>
        /// <param name="tol"></param>
        /// <param name="isOpposite"></param>
        /// <returns></returns>
        public bool AreInNearSegA(Segment3f other, float tol = 1e-6f, bool isOpposite = false, float distanceTol = 10)
        {
            // 방향이 같은 경우 (ang < tol) 또는 반대 방향 허용 시 (isOpposite && |ang - 180| < tol)
            float ang = this.direction.AngleDeg(other.direction);
            bool isSameOrOppositeDir = (ang < tol) || (isOpposite && Math.Abs(ang - 180f) < tol);
            if (!isSameOrOppositeDir)
            {
                return false;
            }

            // 나란하지만 인접한 경우는 제외
            if (IsParallelAndAdjacent(this, other, distanceTol))
            {
                return false;
            }

            // 겹치는 경우
            // ksk 250421 tol 추가
            //if (IsOverlapping(this.P0, this.P1, other.P0, other.P1, 10))
            return IsOverlappingA(this, other, tol: tol, distanceTol);
        }

        // 나란히 있는 경우를 판단하는 함수
        private bool IsParallelAndAdjacent(Segment3f seg1, Segment3f seg2, float tol)
        {
            // 두 세그먼트가 연결된 지점 확인
            bool areConnected = EqualsWithTolerance(seg1.P1, seg2.P0, tol) || EqualsWithTolerance(seg1.P0, seg2.P1, tol);
            //bool areConnected2 = EqualsWithTolerance(seg1.P1, seg2.P1, tol) || EqualsWithTolerance(seg1.P0, seg2.P0, tol);

            // 연결된 경우, 하지만 겹치지 않는 경우 나란히 있다고 간주
            //return areConnected && !IsOverlapping(seg1.P0, seg1.P1, seg2.P0, seg2.P1, tol);
            return areConnected && !IsOverlappingA(seg1, seg2, tol);
        }

        // 두 점이 허용 오차 내에서 같은지 확인하는 확장 메서드
        public static bool EqualsWithTolerance(Vector3 v1, Vector3 v2, float tol)
        {
            return Math.Abs(v1.X - v2.X) < tol && Math.Abs(v1.Y - v2.Y) < tol && Math.Abs(v1.Z - v2.Z) < tol;
        }

        /// <summary>
        /// 두 3D 세그먼트가 동일한 직선 위에 있고 일정 길이 이상 겹치는지 판단
        /// </summary>
        public bool IsOverlappingA(Segment3f seg1, Segment3f seg2, float tol = 1e-6f, float minOverlap = 10f)
        {
            // 1. 방향 유사 여부 확인
            float ang = seg1.direction.AngleDeg(seg2.direction);
            if (!(ang < tol || Math.Abs(ang - 180f) < tol))
            {
                return false;
            }

            // 2. 동일 평면 여부
            if (!seg1.AreInNearPlane(seg1, seg2, tol))
            {
                return false;
            }

            // 3. 투영 후 겹침 구간 계산
            float t0 = seg1.GetParameter(seg2.P0) / seg1.Length;
            float t1 = seg1.GetParameter(seg2.P1) / seg1.Length;

            float minT = Math.Min(t0, t1);
            float maxT = Math.Max(t0, t1);

            float overlap = Math.Max(0, Math.Min(1, maxT) - Math.Max(0, minT)) * seg1.Length;

            return overlap >= minOverlap;
        }

        public bool AreInNearPlane(Segment3f seg1, Segment3f seg2, float tol = 1e-6f)
        {
            Vector3 u = seg1.P1 - seg1.P0;
            Vector3 normal = Vector3.Cross(u, seg2.P1 - seg2.P0); // 두 벡터로 평면 법선 추정
            if (normal.LengthSquared < tol)
            {
                return true; // 평행한 경우 → 같은 평면 가능성 ↑
            }

            normal = Vector3.Normalize(normal);

            // seg2의 한 점이 seg1의 평면 위에 있는지 확인
            float dist = Math.Abs(Vector3.Dot(normal, seg2.P0 - seg1.P0));

            return dist < tol;
        }

        private AABB3 GetBounds()
        {
            if (direction == Vector3.Zero)
            {
                return AABB3.Empty;
            }

            AABB3 bx = AABB3.Empty;
            bx.Contain(P0);
            bx.Contain(P1);

            return bx;
        }


    }
}
