using System;
using OpenTK.Mathematics;
using MathNet.Numerics.LinearAlgebra;
using System.Runtime.CompilerServices;

namespace IGX.Geometry.Common
{
    public static class Vector2Extensions
    {
        // 인덱서 정의
        public static float GetComponent(this Vector2 v, int index)
        {
            if (index == 0)
            {
                return v.X;
            }
            else
            {
                return index == 1 ? v.Y : throw new IndexOutOfRangeException("Invalid index. Use 0 for X and 1 for Y.");
            }
        }

        public static Vector2 Perp(this Vector2 v)
        {
            return new Vector2(-v.Y, v.X);
        }

        public static int CompareTo(this Vector2 a, Vector2 b)
        {
            // 먼저 x 성분을 기준으로 비교
            int compareX = a.X.CompareTo(b.X);

            // x 성분이 같으면 y 성분을 기준으로 비교
            return compareX == 0 ? a.Y.CompareTo(b.Y) : compareX;
        }

        /// <summary>
        /// this 벡터와 벡터 B의 각도를 계산(degree)
        /// </summary>
        /// <param name="B">this 벡터에 대해 주어진 벡터</param>
        /// <returns>각도 degree</returns>
        public static float AngleDeg(this Vector2 var, Vector2 B)
        {
            return var.AngleRad(B) * MathUtil.Rad2Deg;
        }

        /// <summary>
        /// this ~ point까지 거리
        /// </summary>
        /// <param name="point"></param>
        /// <returns></returns>
        public static float DistanceTo(this Vector2 var, Vector2 point)
        {
            Vector2 df = var - point;
            return (float)Math.Sqrt(Vector2.Dot(df, df));
        }

        /// <summary>
        /// 각 벡터 요소의 절대 값인 벡터를 반환
        /// </summary>
        /// <returns></returns>
        public static Vector2 Abs(this Vector2 value)
        {
            return new Vector2(
                value.X < 0 ? -value.X : value.X,
                value.Y < 0 ? -value.Y : value.Y
            );
        }

        /// <summary>
        /// this 벡터와 벡터 B의 각도를 계산(radian)
        /// </summary>
        /// <param name="B">벡터 2</param>
        /// <returns></returns>
        public static float AngleRad(this Vector2 var, Vector2 B)
        {
            float f = MathUtil.Clamp(Vector2.Dot(var, B), -1, 1);
            return (float)Math.Acos(f);
        }

        /// <summary>
        /// 벡터 외적 계산
        /// </summary>
        /// <param name="B">두 번째 벡터</param>
        /// <returns>cross product</returns>
        public static float CrossDot(this Vector2 var, Vector2 B)
        {
            return (var.X * B.Y) - (var.Y * B.X);
        }

        /// <summary>
        /// 두 점간 거리의 제곱
        /// </summary>
        /// <param name="point1"></param>
        /// <param name="point2"></param>
        /// <returns></returns>
        public static float DistanceSquared(this Vector2 point1, Vector2 point2)
        {
            return ((point2.X - point1.X) * (point2.X - point1.X))
                 + ((point2.Y - point1.Y) * (point2.Y - point1.Y));
        }

        public static float ManhattanDistance(this Vector2 v)
        {
            return Math.Abs(v.X) + Math.Abs(v.Y);
        }

        public static bool IsNormalized(this Vector2 var)
        {
            return Math.Abs((var.X * var.X) + (var.Y * var.Y) - 1) < MathUtil.ZeroTolerance;
        }

        /// <summary>
        /// this와 this --> B를 잇는 벡터의 점 B에서 수직한 벡터와의 내적
        /// sin 성분
        /// </summary>
        /// <param name="b"></param>
        /// <returns></returns>
        public static float PerpDot(this Vector2 a, Vector2 b)
        {
            return (a.X * b.Y) - (a.Y * b.X);
        }

        public static Vector2 Perpendicular(this Vector2 vector)
        {
            return new Vector2(-vector.Y, vector.X);
        }

        public static Vector3 To3D(this Vector2 s, Plane3f plane, int coordtorecover)
        {
            Vector3 v = Vector3.Zero;

            float inv = 1 / plane.normal[coordtorecover];

            switch (coordtorecover)
            {
                case 0:
                    v.Y = s.X;
                    v.Z = s.Y;
                    v.X = inv * (plane.constant - (plane.normal.Y * v.Y) - (plane.normal.Z * v.Z));
                    break;
                case 1:
                    v.Z = s.X;
                    v.X = s.Y;
                    v.Y = inv * (plane.constant - (plane.normal.Z * v.Z) - (plane.normal.X * v.X));
                    break;
                case 2:
                    v.X = s.X;
                    v.Y = s.Y;
                    v.Z = inv * (plane.constant - (plane.normal.X * v.X) - (plane.normal.Y * v.Y));
                    break;
            }

            return v;
        }

        public static string ToString(this Vector2 var, string fmt)
        {
            return string.Format("{0} {1}", var.X.ToString(fmt), var.Y.ToString(fmt));
        }

        public static void TurnRight(this ref Vector2 var)
        {
            float temp = var.X;
            var.X = var.Y;
            var.Y = -temp;
        }

        public static void TurnRight(this ref Vector2 var, float dAng)
        {
            var.TurnLeft(MathUtil.TwoPi - dAng);
        }

        public static void TurnLeft(this ref Vector2 var, float dAng)
        {
            float temp = var.X;

            var.X = (float)((Math.Cos(dAng) * var.X) - (Math.Sin(dAng) * var.Y));
            var.Y = (float)((Math.Sin(dAng) * temp) + (Math.Cos(dAng) * var.Y));
        }

        public static bool LessThan(this ref Vector2 a, Vector2 b)
        {
            if (a.X < b.X)
            {
                return true;
            }
            else
            {
                return a.X == b.X && a.Y < b.Y;
            }
        }

        public static bool GreaterThan(this ref Vector2 a, Vector2 b)
        {
            if (a.X > b.X)
            {
                return true;
            }
            else
            {
                return a.X == b.X && a.Y > b.Y;
            }
        }

        public static bool IsNormalized(this Vector2 a, float epsilonl = MathUtil.ZeroTolerance)
        {
            return epsilonl >= Math.Abs(a.Length - 1);
        }
        public static Vector3 ProjectBackTo3D(this Vector2 point, Plane3f plane)
        {
            float x = point.X;
            float y = point.Y;

            float z = 0;// 평면 방정식에서 Z 값. Z = -(A*X + B*Y + D) / C

            if (Math.Abs(plane.normal.Z) > 1e-6f)  // 법선 벡터의 Z 값이 0이 아니면
            {// 평면 방정식에서 Z 값 계산
                z = -((plane.normal.X * x) + (plane.normal.Y * y) + plane.constant) / plane.normal.Z;
            }
            else
            { // Z 값이 0인 평면이면 계산할 필요 없음, 평면이 XY 평면일 때
                z = 0;  // 평면의 Z 값이 항상 0일 수 있으므로
            }
            return new Vector3(x, y, z);
        }

        public static float[] ToArray(this Vector2 v)
        {
            return new float[2] { v.X, v.Y };
        }
    }
}
