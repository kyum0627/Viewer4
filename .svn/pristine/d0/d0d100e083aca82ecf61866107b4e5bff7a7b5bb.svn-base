using IGX.ViewControl.Buffer;
using OpenTK.GLControl;

namespace IGX.ViewControl.Render
{
    // 렌더링을 총괄하는 컨트롤러 클래스
    public class RendererStrategy : IDisposable
    {
        private readonly IgxViewAPI _apis;
        private readonly GLControl _glControl;
        private IRenderer? _strategy; // Nullable로 선언하여 안전성 확보

        private bool _isDisposed;
        private readonly object _disposeLock = new object();

        public RendererStrategy(IgxViewAPI apis, GLControl glControl)
        {
            // Null 인자를 방지하기 위해 Null 체크
            _apis = apis ?? throw new ArgumentNullException(nameof(apis));
            _glControl = glControl ?? throw new ArgumentNullException(nameof(glControl));

            // 렌더링 모드 변경 이벤트 구독
            _apis.Shading.ModeChanged += OnShadeModeChanged;

            // 초기 렌더링 전략을 설정하고 초기화
            SetStrategyBasedOnShadeMode();
        }

        private void OnShadeModeChanged(object? sender, EventArgs e)
        {
            // 이벤트 발생 시 렌더링 전략을 변경하고 초기화
            SetStrategyBasedOnShadeMode();
        }

        private void SetStrategyBasedOnShadeMode()
        {
            IRenderer? newStrategy = null;

            // 기존 전략이 있다면 먼저 리소스를 해제
            _strategy?.Dispose();

            // 새로운 ShadeMode에 따라 적절한 렌더링 전략 객체 생성
            switch (_apis.Shading.Mode)
            {
                case ShadeMode.Phong:
                case ShadeMode.Flat:
                    newStrategy = new ForwardPass(_apis);//, _glControl);
                    break;
                case ShadeMode.Xray:
                    newStrategy = new ForwardPass(_apis);//, _glControl); // Xray 모드 전용 렌더러
                    break;
                case ShadeMode.OUTLINE:
                    newStrategy = new DeferredPass(_apis);//, _glControl);//, buffers); // OUTLINE 모드 전용 렌더러
                    break;
                default:
                    newStrategy = new ForwardPass(_apis);//, _glControl);
                    break;
            }

            _strategy = newStrategy;

            // 새 전략이 성공적으로 생성되었다면 초기화
            if (_strategy != null && _glControl.IsHandleCreated)
            {
                _strategy.Initialize(_glControl.Width, _glControl.Height);
            }

            // 렌더링 전략이 변경되었음을 화면에 알림
            _glControl.Invalidate();
        }

        // 초기 렌더링과 리사이징에 필요한 공용 메서드
        public void Initialize(int width, int height)
        {
            _strategy?.Initialize(width, height);
        }

        public void Draw(IMyCamera camera)
        {
            _strategy?.Draw(camera, true);
        }
        public void Resize(int width, int height)
        {
            _strategy?.Resize(width, height);
        }

        public void Dispose()
        {
            // 다중 스레드 환경에서 안전하게 리소스 해제
            lock (_disposeLock)
            {
                if (_isDisposed)
                {
                    return;
                }

                // 이벤트 구독 해제
                _apis.Shading.ModeChanged -= OnShadeModeChanged;

                // 렌더링 전략 객체의 리소스를 먼저 정리
                _strategy?.Dispose();

                // OpenGL 컨텍스트가 유효한지 확인하고 전역 리소스를 해제
                if (_glControl.IsHandleCreated && !_glControl.IsDisposed)
                {
                    _glControl.MakeCurrent();
                    // 보류 중인 OpenGL 리소스 해제 메서드 호출
                    Shader.ProcessPendingDeletions();
                    FrameBuffer.ProcessPendingDeletions();
                }

                _isDisposed = true;
            }
        }
    }
}