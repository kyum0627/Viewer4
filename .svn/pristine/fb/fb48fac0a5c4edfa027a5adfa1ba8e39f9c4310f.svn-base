using System;
using System.Collections.Generic;
using OpenTK.Mathematics;
using IGX.Geometry.Common;

namespace IGX.Geometry.Intersect
{
    /// <summary>
    /// 평면상의 직선간 교첨
    /// https://www.geometrictools.com/Source/Intersection2D.html#LinearLinear
    /// https://ko.wikipedia.org/wiki/직선
    /// </summary>
    public class IntersectLine2Line2
    {
        Line2f line1;
        Line2f line2;

        // ---- 교차 계산 결과 ----
        public IntersectionResult2 result;

        /// <summary>
        /// 겹치면 Dimension1 A의 origin을 리턴
        /// </summary>
        /// <param name="A"></param>
        /// <param name="B"></param>
        public IntersectLine2Line2(Line2f A, Line2f B)
        {
            line1 = A;
            line2 = B;
            result = new IntersectionResult2();
            result = GetIntersectionOrOverlap(line1, line2);
        }

        public IntersectionResult2 GetIntersectionOrOverlap(Line2f a, Line2f other, float tolerrance = 1e-05f)
        {
            Vector2 p1 = a.origin;
            Vector2 p2 = other.origin;
            Vector2 r1 = a.direction;
            Vector2 r2 = other.direction;

            float rCrossS = CrossProduct(r1, r2);
            Vector2 qp = p2 - p1;
            float qpCrossR = CrossProduct(qp, r1);

            // 두 직선이 평행한 경우
            if (Math.Abs(rCrossS) < float.Epsilon)
            {
                // 두 직선이 겹치는지 확인
                if (IsLinesOverlap(a, other))
                {
                    // 겹치는 부분이 있으므로 무한 직선을 반환
                    result.type = IntersectionType.LINE;
                    result.quantity = int.MaxValue;
                    result.status = IntersectionResult.INTERSECT;
                    result.parameter1 = new Interval(-float.MaxValue, float.MaxValue);
                    result.parameter2 = new Interval(-float.MaxValue, float.MaxValue);
                    result.points = new List<Vector2>
                    {
                        a.origin
                    };

                    return result;
                }
                else
                {
                    // 평행한 경우 교차점이 존재하지 않음
                    result.type = IntersectionType.EMPTY;
                    result.quantity = 0;
                    result.status = IntersectionResult.NOTINTERSECT;
                    result.parameter1 = new Interval(0, 0);
                    result.parameter2 = new Interval(0, 0);
                    result.points = new List<Vector2>();
                    result.points.Clear();
                    return result;
                }
            }

            // 교차점 계산
            float t = CrossProduct(qp, r2) / rCrossS;
            Vector2 intersection = p1 + (t * r1);

            result.type = IntersectionType.POINT;
            result.quantity = 1;
            result.status = IntersectionResult.INTERSECT;
            result.parameter1 = new Interval(t, t);
            result.points = new List<Vector2>
            {
                a.origin
            };
            return result;
        }

        // 벡터의 외적 계산
        private static float CrossProduct(Vector2 v1, Vector2 v2)
        {
            return (v1.X * v2.Y) - (v1.Y * v2.X);
        }

        // 두 직선이 겹치는지 여부 확인
        private static bool IsLinesOverlap(Line2f line1, Line2f line2)
        {
            Vector2 p1 = line1.origin;
            Vector2 p2 = line2.origin;
            Vector2 r1 = line1.direction;
            Vector2 r2 = line2.direction;

            Vector2 q = p2 - p1;

            // 두 직선의 방향 벡터가 비슷하게 평행하면서 시작점이 다른 경우
            if (Math.Abs(CrossProduct(r1, r2)) < float.Epsilon &&
                Math.Abs(CrossProduct(q, r1)) < float.Epsilon)
            {
                // 두 직선이 일부 겹치는 부분이 존재
                return true;
            }

            return false;
        }
    }
}
