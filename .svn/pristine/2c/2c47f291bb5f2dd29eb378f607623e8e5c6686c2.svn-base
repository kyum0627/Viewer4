using IGX.Geometry.Common;
using IGX.Geometry.ConvexHull;
using OpenTK.Mathematics;
using static g3.RoundRectGenerator;

namespace IGX.ViewControl.Render.Materials
{
    /// <summary>
    /// 클리핑 박스 데이터와 관련 논리를 관리하는 클래스.
    /// </summary>
    public class ClippingBox
    {
        public Vector4[] ClipPlanes { get; private set; } = new Vector4[6];
        private readonly Dictionary<int, int[]> _planeIndexLookUp = [];

        public ClippingBox()
        {
            InitializeClipPlanes();
            InitializeLookUpTable();
        }
        /// <summary>
        /// 6개의 클리핑 평면을 초기화.
        /// </summary>
        private void InitializeClipPlanes()
        {
            ClipPlanes = new Vector4[6]
            {
                ( 1,  0,  0, 1),
                (-1,  0,  0, 1),
                ( 0,  1,  0, 1),
                ( 0, -1,  0, 1),
                ( 0,  0,  1, 1),
                ( 0,  0, -1, 1)
            };
        }
        private void InitializeLookUpTable()
        {
            // 평면 핸들 (인덱스 0-5)
            for (int i = 0; i < 6; i++) _planeIndexLookUp[i] = new[] { i };

            // 엣지 핸들 (인덱스 6-17)
            _planeIndexLookUp[6] = new[] { 3, 5 }; // Left-Bottom-Front (엣지)
            _planeIndexLookUp[7] = new[] { 0, 5 }; // Right-Bottom-Front
            _planeIndexLookUp[8] = new[] { 2, 5 }; // Top-Front
            _planeIndexLookUp[9] = new[] { 1, 5 }; // Left-Top-Front
            _planeIndexLookUp[10] = new[] { 3, 4 }; // Left-Bottom-Back
            _planeIndexLookUp[11] = new[] { 0, 4 }; // Right-Bottom-Back
            _planeIndexLookUp[12] = new[] { 2, 4 }; // Top-Back
            _planeIndexLookUp[13] = new[] { 1, 4 }; // Left-Top-Back
            _planeIndexLookUp[14] = new[] { 1, 3 }; // Left-Bottom
            _planeIndexLookUp[15] = new[] { 0, 3 }; // Right-Bottom
            _planeIndexLookUp[16] = new[] { 1, 2 }; // Left-Top
            _planeIndexLookUp[17] = new[] { 0, 2 }; // Right-Top

            // 코너 핸들 (인덱스 18-25)
            _planeIndexLookUp[18] = new[] { 1, 3, 5 }; // Left-Bottom-Front
            _planeIndexLookUp[19] = new[] { 0, 3, 5 }; // Right-Bottom-Front
            _planeIndexLookUp[20] = new[] { 1, 2, 5 }; // Left-Top-Front
            _planeIndexLookUp[21] = new[] { 0, 2, 5 }; // Right-Top-Front
            _planeIndexLookUp[22] = new[] { 1, 3, 4 }; // Left-Bottom-Back
            _planeIndexLookUp[23] = new[] { 0, 3, 4 }; // Right-Bottom-Back
            _planeIndexLookUp[24] = new[] { 1, 2, 4 }; // Left-Top-Back
            _planeIndexLookUp[25] = new[] { 0, 2, 4 }; // Right-Top-Back
        }
        /// <summary>
        /// 클리핑 상자를 주어진 중심과 반지름에 맞춰 재설정.
        /// </summary>
        public void ResetBox(Vector3 center, float radius)
        {
            Vector3 min = center - new Vector3(radius, radius, radius);
            Vector3 max = center + new Vector3(radius, radius, radius);
            ResetBox(new AABB3(min, max));
        }

        public void ResetBox(AABB3 abox)
        {
            Vector3 min = abox.min;
            Vector3 max = abox.max;

            // 각 평면은 min/max 지점을 통과하는 법선 벡터로 정의.
            ClipPlanes[0] = CreatePlane( Vector3.UnitX, max); // Right (x_max)
            ClipPlanes[1] = CreatePlane(-Vector3.UnitX, min); // Left (x_min)
            ClipPlanes[2] = CreatePlane( Vector3.UnitY, max); // Top (y_max)
            ClipPlanes[3] = CreatePlane(-Vector3.UnitY, min); // Bottom (y_min)
            ClipPlanes[4] = CreatePlane( Vector3.UnitZ, max); // Back (z_max)
            ClipPlanes[5] = CreatePlane(-Vector3.UnitZ, min); // Front (z_min)
        }
        public void ResetBox(OOBB3 abox)
        {
            Vector3 center = abox.center;
            Vector3 extent = abox.extent;
            ClipPlanes[0] = CreatePlane( abox.axisX, center + abox.axisX * extent.X); // Right
            ClipPlanes[1] = CreatePlane(-abox.axisX, center - abox.axisX * extent.X); // Left
            ClipPlanes[2] = CreatePlane( abox.axisY, center + abox.axisY * extent.Y); // Top
            ClipPlanes[3] = CreatePlane(-abox.axisY, center - abox.axisY * extent.Y); // Bottom
            ClipPlanes[4] = CreatePlane( abox.axisZ, center + abox.axisZ * extent.Z); // Back
            ClipPlanes[5] = CreatePlane(-abox.axisZ, center - abox.axisZ * extent.Z); // Front
        }
        /// <summary>
        /// 법선과 한 점을 사용하여 평면 방정식(ax+by+cz+d=0)을 나타내는 Vector4를 생성.
        /// </summary>
        private Vector4 CreatePlane(Vector3 normal, Vector3 point)
        {
            normal.Normalize();
            float d = -Vector3.Dot(normal, point);
            return new Vector4(normal, d);
        }
        /// <summary>
        /// 핸들 인덱스에 따라 클리핑 평면을 업데이트.
        /// </summary>
        public void UpdatePlanes(int handleIndex, Vector3 delta)
        {
            if (!_planeIndexLookUp.TryGetValue(handleIndex, out int[]? planeIndices))
            {
                return;
            }

            foreach (int planeIndex in planeIndices)
            {
                Vector3 normal = ClipPlanes[planeIndex].Xyz;
                ClipPlanes[planeIndex].W += Vector3.Dot(delta, normal);
            }
        }

        /// <summary>
        /// 6개의 클리핑 평면 교차점을 계산하여 상자의 8개 코너를 반환.
        /// </summary>
        public Vector3[] GetClipBoxCorners()
        {
            Plane3f[] planes = new Plane3f[6];
            for (int i = 0; i < 6; i++)
            {
                planes[i] = new Plane3f(ClipPlanes[i].Xyz, ClipPlanes[i].W);
            }

            Vector3[] corners = new Vector3[8];
            corners[0] = IntersectPlanes(planes[1], planes[3], planes[5]); // Left-Bottom-Front
            corners[1] = IntersectPlanes(planes[0], planes[3], planes[5]); // Right-Bottom-Front
            corners[2] = IntersectPlanes(planes[1], planes[2], planes[5]); // Left-Top-Front
            corners[3] = IntersectPlanes(planes[0], planes[2], planes[5]); // Right-Top-Front
            corners[4] = IntersectPlanes(planes[1], planes[3], planes[4]); // Left-Bottom-Back
            corners[5] = IntersectPlanes(planes[0], planes[3], planes[4]); // Right-Bottom-Back
            corners[6] = IntersectPlanes(planes[1], planes[2], planes[4]); // Left-Top-Back
            corners[7] = IntersectPlanes(planes[0], planes[2], planes[4]); // Right-Top-Back

            return corners;
        }
        public Vector3 IntersectPlanes(Plane3f p1, Plane3f p2, Plane3f p3)
        {
            Vector3 n1 = p1.normal;
            Vector3 n2 = p2.normal;
            Vector3 n3 = p3.normal;

            float d1 = p1.constant;
            float d2 = p2.constant;
            float d3 = p3.constant;

            float denom = Vector3.Dot(n1, Vector3.Cross(n2, n3));
            if (MathF.Abs(denom) < 1e-6)
            {
                return new Vector3(float.NaN);
            }

            Vector3 v = Vector3.Cross(n2, n3) * -d1 + Vector3.Cross(n3, n1) * -d2 + Vector3.Cross(n1, n2) * -d3;
            return v / denom;
        }
        public Vector3 GetHandlePosition(int handleIndex)
        {
            // 룩업 테이블을 사용하여 평면 인덱스들을 가져옵니다.
            if (!_planeIndexLookUp.TryGetValue(handleIndex, out int[]? planes))
            {
                return Vector3.Zero;
            }

            if (planes.Length == 1) // 평면 핸들
            {
                Vector4 plane = ClipPlanes[planes[0]];
                return plane.Xyz * -plane.W;
            }
            else if (planes.Length == 2) // 엣지 핸들
            {
                return IntersectPlanes(
                    new Plane3f(ClipPlanes[planes[0]].Xyz, ClipPlanes[planes[0]].W),
                    new Plane3f(ClipPlanes[planes[1]].Xyz, ClipPlanes[planes[1]].W),

                    new Plane3f(Vector3.Cross(ClipPlanes[planes[0]].Xyz, ClipPlanes[planes[1]].Xyz).Normalized(), 0)
                );
            }
            else if (planes.Length == 3) // 코너 핸들
            {
                return IntersectPlanes(
                    new Plane3f(ClipPlanes[planes[0]].Xyz, ClipPlanes[planes[0]].W),
                    new Plane3f(ClipPlanes[planes[1]].Xyz, ClipPlanes[planes[1]].W),
                    new Plane3f(ClipPlanes[planes[2]].Xyz, ClipPlanes[planes[2]].W)
                );
            }
            return Vector3.Zero;
        }
        /// <summary>
        /// 엣지 인덱스에 해당하는 두 개의 클리핑 평면 인덱스를 반환.
        /// </summary>
        public int[] GetPlanesForEdge(int edgeIndex)
        {
            switch (edgeIndex)
            {
                case 0: return new[] { 3, 5 }; // Bottom-Front
                case 1: return new[] { 0, 5 }; // Right-Front
                case 2: return new[] { 2, 5 }; // Top-Front
                case 3: return new[] { 1, 5 }; // Left-Front
                case 4: return new[] { 3, 4 }; // Bottom-Back
                case 5: return new[] { 0, 4 }; // Right-Back
                case 6: return new[] { 2, 4 }; // Top-Back
                case 7: return new[] { 1, 4 }; // Left-Back
                case 8: return new[] { 1, 3 }; // Left-Bottom
                case 9: return new[] { 0, 3 }; // Right-Bottom
                case 10: return new[] { 1, 2 }; // Left-Top
                case 11: return new[] { 0, 2 }; // Right-Top
                default: return Array.Empty<int>();
            }
        }

        /// <summary>
        /// 코너 인덱스에 해당하는 세 개의 클리핑 평면 인덱스를 반환.
        /// </summary>
        public int[] GetPlanesForCorner(int cornerIndex)
        {
            switch (cornerIndex)
            {
                case 0: return new[] { 1, 3, 5 };
                case 1: return new[] { 0, 3, 5 };
                case 2: return new[] { 1, 2, 5 };
                case 3: return new[] { 0, 2, 5 };
                case 4: return new[] { 1, 3, 4 };
                case 5: return new[] { 0, 3, 4 };
                case 6: return new[] { 1, 2, 4 };
                case 7: return new[] { 0, 2, 4 };
                default: return Array.Empty<int>();
            }
        }
    }
}