using IGX.Geometry.Common;
using IGX.Geometry.DataStructure;
using IGX.ViewControl.Buffer.Common;
using OpenTK.Graphics.OpenGL4;
using OpenTK.Mathematics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace IGX.ViewControl.Buffer
{
    public class VertexBuffer<T> : MutableBuffer<T> where T : struct
    {
        private static readonly Dictionary<Type, VertexAttributeData[]> _cachedVertexAttributes = new();
        private static readonly object _attributeLock = new();

        public VertexBuffer(T[]? data, BufferUsageHint usage, BufferTarget target)
            : base(data ?? Array.Empty<T>(), target, usage, keepCpuData: true)
        {
            if (data != null && data.Length > 0)
            {
                if (!IsContextLikelyActive())
                {
                    throw new InvalidOperationException("Cannot set initial data without an active OpenGL context.");
                }
                try
                {
                    SetData(data);
                    CheckGLError();
                }
                catch (InvalidOperationException ex)
                {
                    throw new InvalidOperationException("Failed to set initial vertex _instancedBuffer data.", ex);
                }
            }
        }

        public void SetAttributes()
        {
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot set attributes without an active OpenGL context.");
            }

            lock (_attributeLock)
            {
                if (!_cachedVertexAttributes.ContainsKey(typeof(T)))
                {
                    CacheVertexAttributes();
                }

                var attributes = _cachedVertexAttributes[typeof(T)];
                if (attributes.Length == 0)
                {
                    throw new InvalidOperationException(
                        $"No vertex attributes defined for type '{typeof(T).Name}'. Ensure fields are decorated with VertexAttribute attributes."
                    );
                }

                try
                {
                    Bind();
                    int stride = Marshal.SizeOf<T>();

                    foreach (VertexAttributeData attrData in attributes)
                    {
                        GL.EnableVertexAttribArray(attrData.Location);
                        if (attrData.IsMatrix4)
                        {
                            for (int i = 0; i < 4; i++)
                            {
                                GL.VertexAttribPointer(
                                    attrData.Location + i,
                                    4,
                                    VertexAttribPointerType.Float,
                                    attrData.Normalized,
                                    stride,
                                    attrData.Offset + Vector4.SizeInBytes * i
                                );
                                GL.VertexAttribDivisor(attrData.Location + i, attrData.Divisor);
                            }
                        }
                        else
                        {
                            if (attrData.GLType == All.Float || attrData.GLType == All.HalfFloat || attrData.GLType == All.Fixed ||
                                attrData.Normalized && (attrData.GLType == All.UnsignedShort || attrData.GLType == All.UnsignedByte ||
                                                        attrData.GLType == All.Short || attrData.GLType == All.Byte))
                            {
                                GL.VertexAttribPointer(
                                    attrData.Location,
                                    attrData.Size,
                                    (VertexAttribPointerType)attrData.GLType,
                                    attrData.Normalized,
                                    stride,
                                    attrData.Offset
                                );
                            }
                            else if (attrData.GLType == All.Int || attrData.GLType == All.UnsignedInt)
                            {
                                GL.VertexAttribIPointer(
                                    attrData.Location,
                                    attrData.Size,
                                    (VertexAttribIntegerType)attrData.GLType,
                                    stride,
                                    attrData.Offset
                                );
                            }
                            else if (attrData.GLType == All.Double)
                            {
                                GL.VertexAttribLPointer(
                                    attrData.Location,
                                    attrData.Size,
                                    (VertexAttribDoubleType)attrData.GLType,
                                    stride,
                                    attrData.Offset
                                );
                            }
                            else
                            {
                                throw new InvalidOperationException(
                                    $"Unsupported VertexAttribute type {attrData.GLType} for field '{attrData.FieldName}'"
                                );
                            }

                            if (attrData.Divisor > 0)
                            {
                                GL.VertexAttribDivisor(attrData.Location, attrData.Divisor);
                            }
                        }
                    }
                    CheckGLError();
                    Unbind();
                }
                catch (InvalidOperationException ex)
                {
                    throw new InvalidOperationException("Failed to set vertex attributes.", ex);
                }
            }
        }

        public void UpdateVertices(int startIndex, ReadOnlySpan<T> newVertices)
        {
            if (startIndex < 0 || newVertices.Length < 0 || startIndex + newVertices.Length > Count)
            {
                throw new ArgumentOutOfRangeException(nameof(startIndex), "Vertex range is out of bounds.");
            }

            if (newVertices.Length == 0) return;

            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot update vertices without an active OpenGL context.");
            }

            var cpuData = CpuData;
            if (cpuData.IsEmpty)
            {
                throw new InvalidOperationException("CPU _instancedBuffer is not maintained.");
            }

            newVertices.CopyTo(cpuData.Slice(startIndex, newVertices.Length));

            try
            {
                UpdateData(newVertices, (nint)(startIndex * Unsafe.SizeOf<T>()));
                CheckGLError();
            }
            catch (InvalidOperationException ex)
            {
                throw new InvalidOperationException("Failed to update vertices in GPU _instancedBuffer.", ex);
            }
        }

        private void CacheVertexAttributes()
        {
            lock (_attributeLock)
            {
                if (_cachedVertexAttributes.ContainsKey(typeof(T)))
                {
                    return;
                }

                List<VertexAttributeData> fieldAttributes = new();
                FieldInfo[] fields = typeof(T).GetFields(BindingFlags.Public | BindingFlags.Instance);

                foreach (FieldInfo field in fields)
                {
                    VertexAttribute? attribute = field.GetCustomAttribute<VertexAttribute>();
                    if (attribute != null)
                    {
                        if (field.FieldType == typeof(Matrix4))
                        {
                            fieldAttributes.Add(new VertexAttributeData
                            {
                                FieldName = field.Name,
                                Location = attribute.Location,
                                Size = 4,
                                GLType = All.Float,
                                Normalized = false,
                                Offset = (int)Marshal.OffsetOf<T>(field.Name),
                                Divisor = attribute.Divisor,
                                IsMatrix4 = true
                            });
                        }
                        else
                        {
                            fieldAttributes.Add(new VertexAttributeData
                            {
                                FieldName = field.Name,
                                Location = attribute.Location,
                                Size = attribute.Size,
                                GLType = attribute.Type,
                                Normalized = attribute.Normalized,
                                Offset = (int)Marshal.OffsetOf<T>(field.Name),
                                Divisor = attribute.Divisor
                            });
                        }
                    }
                    else
                    {
                        Console.WriteLine(
                            $"Warning: Field '{field.Name}' in type '{typeof(T).Name}' has no VertexAttribute attribute and will not be set as a vertex attribute."
                        );
                    }
                }

                _cachedVertexAttributes[typeof(T)] = fieldAttributes.OrderBy(a => a.Location).ToArray();

                if (_cachedVertexAttributes[typeof(T)].Length == 0)
                {
                    Console.WriteLine(
                        $"Warning: Type '{typeof(T).Name}' has no fields with VertexAttribute attributes. No vertex attributes will be set."
                    );
                }
            }
        }

        private static bool IsContextLikelyActive()
        {
            try
            {
                GL.GetError();
                return true;
            }
            catch
            {
                return false;
            }
        }

        private static void CheckGLError()
        {
            var error = GL.GetError();
            if (error != ErrorCode.NoError)
            {
                throw new InvalidOperationException($"OpenGL error: {error}");
            }
        }
    }
}