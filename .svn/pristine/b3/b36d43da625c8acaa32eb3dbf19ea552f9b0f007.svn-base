using OpenTK.Mathematics;

namespace IGX.Geometry.Common
{
    /// <summary>
    /// 2차원 공간을 vector, line 혹은 default_nsegs 기준으로 분할
    /// 즉, 원점에서 norID 방향으로 constant만큼 떨어진 무한 직선을 기준으로 공간을 분할
    /// halfspace.norID.Dot(Pi) - halfspace.conatant > 0 이면 norID 방향
    /// halfspace.norID.Dot(Pi) - halfspace.conatant < 0 이면 normal 반대 방향
    /// geometry를 기준선 혹은 면 등으로 clipping할 때 사용
    /// </summary>
    public class HalfSpace2
    {
        public float constant;
        public Vector2 normal;

        public HalfSpace2()
        {
            constant = 0f;
            normal = Vector2.One;
        }

        public HalfSpace2(Vector2 norm, float cons)
        {
            normal = norm;
            constant = cons;
        }

        public HalfSpace2(Line2f line)
        {
            normal = line.direction.Perp();
            constant = Vector2.Dot(normal, line.origin);
        }

        public HalfSpace2(Segment2f segment)
        {
            normal = segment.direction.Perp();
            constant = Vector2.Dot(normal, segment.center);
        }

        public HalfSpace2(Vector2 origin, Vector2 norm)
        {
            normal = Vector2.Normalize(norm);
            constant = Vector2.Dot(normal, origin);
        }

        public static bool operator ==(HalfSpace2 a, HalfSpace2 b)
        {
            return a.constant == b.constant && a.normal == b.normal;
        }

        public static bool operator !=(HalfSpace2 a, HalfSpace2 b)
        {
            return a.constant != b.constant || a.normal != b.normal;
        }
        public static bool operator <(HalfSpace2 a, HalfSpace2 b)
        {
            if (a.normal.LessThan(b.normal))
            {
                return true;
            }
            return !a.normal.GreaterThan(b.normal) && a.constant < b.constant;
        }

        public static bool operator >(HalfSpace2 a, HalfSpace2 b)
        {
            if (a.normal.GreaterThan(b.normal))
            {
                return true;
            }
            return !a.normal.LessThan(b.normal) && a.constant > b.constant;
        }

        public bool Equals(HalfSpace2 other)
        {
            return normal.Equals(other.normal) && constant.Equals(other.constant);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hash = (int)2166136261;
                hash = (hash * 16777619) ^ normal.GetHashCode();
                hash = (hash * 16777619) ^ constant.GetHashCode();
                return hash;
            }
        }
        public override bool Equals(object? obj)
        {
            if (obj == null)
            {
                return false;
            }

            if (obj is HalfSpace2 a)
            {
                return Equals(a); // Equals(HalfSpace2) 메서드로 위임
            }
            else
            {
                return false;
            }
        }
    }

    public class HalfSpace3
    {
        public float constant;
        public Vector3 normal;

        public HalfSpace3()
        {
            constant = 0f;
            normal = Vector3.One;
        }

        public HalfSpace3(Vector3 norm, float cons)
        {
            normal = norm;
            constant = cons;
        }

        public static bool operator ==(HalfSpace3 a, HalfSpace3 b)
        {
            return a.constant == b.constant && a.normal == b.normal;
        }

        public static bool operator !=(HalfSpace3 a, HalfSpace3 b)
        {
            return a.constant != b.constant || a.normal != b.normal;
        }

        public static bool operator <(HalfSpace3 a, HalfSpace3 b)
        {
            if (a.normal.LessThan(b.normal))
            {
                return true;
            }
            return !a.normal.GreaterThan(b.normal) && a.constant < b.constant;
        }

        public static bool operator >(HalfSpace3 a, HalfSpace3 b)
        {
            if (a.normal.GreaterThan(b.normal))
            {
                return true;
            }
            return !a.normal.LessThan(b.normal) && a.constant > b.constant;
        }

        public bool Equals(HalfSpace3 other)
        {
            return normal == other.normal && constant == other.constant;
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hash = (int)2166136261;
                hash = (hash * 16777619) ^ normal.GetHashCode();
                hash = (hash * 16777619) ^ constant.GetHashCode();
                return hash;
            }
        }

        public override bool Equals(object? obj)
        {
            if (obj is null)
            {
                return false;
            }

            return obj is HalfSpace3 a && normal == a.normal && constant == a.constant;
        }
    }
}
