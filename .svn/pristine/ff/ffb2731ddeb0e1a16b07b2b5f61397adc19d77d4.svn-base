using IGX.Geometry.DataStructure;
using IGX.Geometry.GeometryBuilder;
using IGX.ViewControl.Buffer;
using IGX.ViewControl.Buffer.Common;
using OpenTK.Graphics.OpenGL4;
using OpenTK.Mathematics;
using System.Collections.Generic;
using System.Diagnostics;

namespace IGX.ViewControl.Render.Materials
{
    public static class ArrowData
    {
        public static int margin = 20;
        public static int viewportWidth = 100 + margin;
        public static int viewportHeight = 100 + margin;

        public static (List<Vertex> Vertices, List<uint> Indices, List<DrawElementsIndirectCommand> DrawCommands) GeneratePareneMesh()
        {
            const float length = 1f;
            const float cylinderRatio = 0.7f;
            const float arrowRadiusRatio = 1f / 24f;
            const float coneRadiusRatio = 1f / 8f;
            const int segments = 16;

            var vertices = new List<Vertex>();
            var indices = new List<uint>();
            var drawCommands = new List<DrawElementsIndirectCommand>();

            const float arrowCylinderLength = length * cylinderRatio;
            const float arrowConeLength = length * (1f - cylinderRatio);
            const float arrowRadius = length * arrowRadiusRatio;
            const float coneRadius = length * coneRadiusRatio;

            Vector3 from = Vector3.Zero;
            Vector3 to = new(0, 0, arrowCylinderLength);
            Vector3 end = to + new Vector3(0, 0, arrowConeLength);

            Cylinder cylinderModel = new(from, to, arrowRadius);
            cylinderModel.Tessellate(segments, true, false);

            Snout coneModel = new(to, end, coneRadius, 0);
            coneModel.Tessellate(segments, true, false);

            AddMeshData(cylinderModel, vertices, indices, drawCommands);
            AddMeshData(coneModel, vertices, indices, drawCommands);

            //var mesh = new Mesh();
            var Points = new List<Vector3>();
            var Normals = new List<Vector3>();
            var Indices = new List<uint>();
            Points.AddRange(cylinderModel.Points);
            Points.AddRange(coneModel.Points);
            Normals.AddRange(cylinderModel.Points);
            Normals.AddRange(coneModel.Points);
            Indices.AddRange(cylinderModel.Indices);
            var offset = (uint)cylinderModel.Points.Count;
            Indices.AddRange(coneModel.Indices.Select(i => i + offset).ToList());

            return (vertices, indices, drawCommands);
        }

        //public static (List<Vertex> Vertices, List<uint> Indices, List<DrawElementsIndirectCommand> DrawCommands) Generate2()
        //{
        //    const float length = 1f;
        //    const float cylinderRatio = 0.7f;
        //    const float arrowRadiusRatio = 1f / 24f;
        //    const float coneRadiusRatio = 1f / 8f;
        //    const int segments = 16;

        //    var Vertices = new List<Vertex>();
        //    var indices = new List<uint>();
        //    var drawCommands = new List<DrawElementsIndirectCommand>();

        //    const float arrowCylinderLength = length * cylinderRatio;
        //    const float arrowConeLength = length * (1f - cylinderRatio);
        //    const float arrowRadius = length * arrowRadiusRatio;
        //    const float coneRadius = length * coneRadiusRatio;

        //    Vector3 from = Vector3.Zero;
        //    Vector3 to = new Vector3(0, 0, arrowCylinderLength);
        //    Vector3 end = to + new Vector3(0, 0, arrowConeLength);

        //    Cylinder cylinderModel = new(from, to, arrowRadius);
        //    cylinderModel.Tessellate(segments, true, false);

        //    Snout coneModel = new(to, end, coneRadius, 0);
        //    coneModel.Tessellate(segments, true, false);

        //    AddMeshData(cylinderModel, Vertices, indices, drawCommands);
        //    AddMeshData(coneModel, Vertices, indices, drawCommands);

        //    return (Vertices, indices, drawCommands);
        //}
        private static void AddMeshData(PrimitiveBase mesh, List<Vertex> vertices, List<uint> indices, List<DrawElementsIndirectCommand> commands)
        {
            int baseVertex = vertices.Count;
            int firstIndex = indices.Count;

            for (int i = 0; i < mesh.Points.Count; i++)
            {
                vertices.Add(new Vertex(mesh.Points[i], mesh.Normals[i]));
            }

            foreach (var index in mesh.Indices)
            {
                indices.Add((uint)(index + baseVertex));
            }

            commands.Add(new DrawElementsIndirectCommand
            {
                count = (uint)mesh.Indices.Count,
                instanceCount = 1,
                firstIndex = (uint)firstIndex,
                baseVertex = (uint)baseVertex,
                baseInstance = 0
            });
        }
        private static void xAddMeshData(PrimitiveBase mesh, List<Vertex> vertices, List<uint> indices, List<DrawElementsIndirectCommand> commands)
        {
            int baseVertex = vertices.Count;
            int firstIndex = indices.Count;

            for (int i = 0; i < mesh.Points.Count; i++)
            {
                vertices.Add(new Vertex(mesh.Points[i], mesh.Normals[i]));
            }

            foreach (var index in mesh.Indices)
            {
                indices.Add((uint)(index + baseVertex));
            }

            commands.Add(new DrawElementsIndirectCommand
            {
                count = (uint)mesh.Indices.Count,
                instanceCount = 1,
                firstIndex = (uint)firstIndex,
                baseVertex = (uint)baseVertex,
                baseInstance = 0
            });
        }
    }

    public sealed class DrawArrows : IDisposable
    {
        private static readonly Lazy<DrawArrows> _instance = new(() => new DrawArrows());

        private readonly DrawElementsIndirect<Vertex, uint, MatColInstance> _renderer;
        private readonly List<MatColInstance> _instances;
        private bool _isDisposed = false;

        public static DrawArrows Instance => _instance.Value;

        private DrawArrows()
        {
            var (vertices, indices, commands) = ArrowData.GeneratePareneMesh();
            _instances = [];
            _renderer = new DrawElementsIndirect<Vertex, uint, MatColInstance>(
                vertices.ToArray(),
                indices.ToArray(),
                _instances.ToArray(),
                commands.ToArray(),
                instanceHint: BufferUsageHint.DynamicDraw // 인스턴스 데이터는 자주 변경되므로 DynamicDraw 힌트 사용
            );
        }

        public void AddArrow(MatColInstance instance)
        {
            _instances.Add(instance);
        }

        public void UpdateArrows()
        {
            if (_isDisposed || _instances.Count == 0) return;
            _renderer._indirectCommandBuffer.UpdateInstances(_instances.ToArray());
        }

        public void Render(PrimitiveType primitiveType = PrimitiveType.Triangles)
        {
            if (_isDisposed || _instances.Count == 0) return;
            _renderer.DrawMulti(primitiveType);
        }

        public void Clear()
        {
            _instances.Clear();
        }

        public void Dispose()
        {
            if (_isDisposed) return;
            _renderer.Dispose();
            _isDisposed = true;
            GC.SuppressFinalize(this);
        }
    }
}