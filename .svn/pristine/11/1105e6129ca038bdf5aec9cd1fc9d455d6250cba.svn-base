using OpenTK.Mathematics;

namespace IGX.Geometry.Common
{
    public class Plane2f
    {
        public Vector2 normal;
        public float constant;

        public Vector2 V0;
        public Plane2f()
        {
            normal = Vector2.Normalize(normal);
            constant = 0f;
        }

        public Plane2f(Vector2 pos, Vector2 normal)
        {
            V0 = pos;
            this.normal = normal;
        }

        // Specify N and c directly.
        public Plane2f(Vector2 inNormal, float inConstant)
        {
            normal = inNormal;
            constant = inConstant;
        }

        // Comparisons to support sorted containers.
        public static bool operator ==(Plane2f A, Plane2f B)
        {
            return B.normal == A.normal && B.constant == A.constant;
        }

        public static bool operator !=(Plane2f A, Plane2f B)
        {
            return B.normal != A.normal || B.constant != A.constant;
        }
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hash = (int)2166136261;
                // Suitable nullity checks etc, of course :)
                hash = (hash * 16777619) ^ constant.GetHashCode();
                hash = (hash * 16777619) ^ normal.GetHashCode();
                return hash;
            }
        }

        public override bool Equals(object? obj)
        {
            if (obj is null)
            {
                return false;
            }

            if (obj is Plane2f)
            {
                Plane2f otherPlane = (Plane2f)obj;
                return constant == otherPlane.constant && normal == otherPlane.normal;
            }
            else
            {
                return false;
            }
        }
    }
}
