using System;
using System.Collections.Generic;
using OpenTK.Mathematics;

/// <summary>
/// https://github.com/timprepscius/GeometricTools/tree/master/WildMagic5
/// </summary>
namespace IGX.Geometry.Common
{
    public enum WindingOrder
    {
        Clockwise,
        CounterClockwise,
        None
    }

    /// <summary>
    /// 주어진 값들중 최대값, 최소값 구하기
    /// 주어진 값이 유효한 값인지,
    /// 허용오차 내에 있는지,
    /// 각을 radian <--> degree 상호 변환,
    /// 값의 부호(+, -) return,
    /// 유효한 범위내의 값으로 Clamp하는 등
    /// </summary>
    public static class MathUtil
    {
        public const double PId = 3.14159265358979323846;
        public const double HalfPId = 0.5 * PId;
        public const double TwoPId = 6.283185307179586476925286766559;
        public const double FourPId = 2.0 * TwoPId;
        public const double SixthPId = PId / 6.0;		// 30 degrees
        public const double QuartPId = PId / 4.0;		// 30 degrees
        public const double ThirdPId = PId / 3.0;		// 60 degrees
        public const double TwoThirdPId = TwoPId / 3.0;	// 120 degrees

        public const double Deg2Radd = 0.017453292519943295769236907684886; // (PId / 180.0);
        public const double Rad2Degd = 57.295779513082320876798154814105; // (180.0 / PId);

        public const double Epsilond = 2.2204460492503131e-016;
        public const double Sqrt2Invd = 1.0 / Sqrtd;
        public const double Sqrtd = 1.41421356237309504880168872420969807;
        public const double Sqrt3d = 1.73205080756887729352744634150587236;

        public const float Pi = 3.14159265358979323846f;
        public const float PiOver2 = 0.5f * Pi;
        public const float PiOver4 = 0.25f * Pi;
        public const float TwoPi = 6.283185307179586476925286766559f;
        public const float FourPi = (float)FourPId;
        public const float SixthPi = (float)SixthPId; // 30 degrees
        public const float QuartPi = (float)QuartPId;		// 30 degrees
        public const float ThirdPi = (float)ThirdPId;		// 60 degrees
        public const float TwoThirdPi = (float)TwoThirdPId;    // 120 degrees

        public const float Deg2Rad = 0.017453292519943295769236907684886f; // (PId / 180.0);
        public const float Rad2Deg = 57.295779513082320876798154814105f; // (180.0 / PId);

        public const float Epsilon = 0.01f;
        public const float EpsilonParallel = 0.001f;
        public const float EpsilonAngle = 0.5f;
        public const float EpsilonAngleR = EpsilonAngle * Deg2Rad;
        public const float EpsilonLength = 5f;
        public const float EpsilonDistance = 0.5f;
        public const float EpsilonInterval = 0;

        public const float Sqrt2 = 1.41421356237309504880168872420969807f;
        public const float Sqrt3 = 1.73205080756887729352744634150587236f;
        public const float Sqrt2Inv = 1.0f / Sqrt2;

        public const float ZeroTolerance = 0.000001f;
        // 두 벡터 간의 회전을 나타내는 Quaternion을 생성하는 헬퍼 메서드
        public static Quaternion RotationQuaternionFromTwoVectors(Vector3 from, Vector3 to)
        {
            from = from.Normalized();
            to = to.Normalized();
            float dot = Vector3.Dot(from, to);
            Vector3 cross;
            if (dot < -0.9999f)
            { // 두 벡터가 거의 반대 방향일 때 (180도 회전)
                cross = Vector3.Cross(Vector3.UnitX, from); // 'from' 벡터에 수직인 임의의 벡터를 찾기 위해 Cross Product 사용
                if (cross.LengthSquared < 0.0001f) // from이 UnitX와 평행하다면
                {
                    cross = Vector3.Cross(Vector3.UnitY, from);
                }

                cross = cross.Normalized();
                return new Quaternion(cross.X, cross.Y, cross.Z, 0); // 180도 회전은 w=0 이고, x,y,z는 회전축
            }
            else if (dot > 0.9999f)
            {// 두 벡터가 거의 같은 방향일 때 (회전 없음)
                return Quaternion.Identity;
            }
            else
            {// 일반적인 경우
                cross = Vector3.Cross(from, to);
                // 쿼터니언 공식: (x, y, z, w) = (cross.x, cross.y, cross.z, dot + 1.0f).Normalized()
                // w = dot + 1.0f 를 사용하는 이유는 sqrt(2*(1+dot))을 줄인 형태
                Quaternion q = new(cross.X, cross.Y, cross.Z, dot + 1.0f);
                q.Normalize();
                return q;
            }
        }
        public static float AbsRoundTo05(float toRound05)
        {
            return (float)Math.Round(toRound05 * 2) / 2;
        }
        public static bool IsFinite(float d)
        {
            return !float.IsInfinity(d) && !float.IsNaN(d);
        }

        public static bool EpsilonEqual(float a, float b, float epsilon = ZeroTolerance)
        {
            return (float)Math.Abs(a - b) <= epsilon;
        }

        /// <summary>
        /// fvalue를 주어진 범위 내(low ~ high)의 값으로 변환하여 return
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="fvalue"></param>
        /// <param name="low"></param>
        /// <param name="high"></param>
        /// <returns></returns>
        public static T Clamp<T>(T fvalue, T low, T high) where T : IComparable
        {
            if (fvalue.CompareTo(low) < 0)
            {
                return low;
            }
            else
            {
                return fvalue.CompareTo(high) > 0 ? high : fvalue;
            }
        }

        public static float Clamp(float fvalue, float low, float high)
        {
            return fvalue < low ? low : fvalue > high ? high : fvalue;
        }

        public static int Clamp(int fvalue, int low, int high)
        {
            return fvalue < low ? low : fvalue > high ? high : fvalue;
        }

        public static int ClampListIndex(int index, int listSize)
        {
            index = ((index % listSize) + listSize) % listSize;

            return index;
        }

        // Returns the determinant of the 2x2 CombinedMatrix defined as
        // | x1 x2 |
        // | y1 y2 |
        //det(a_normalized, b_normalized) = sin(alpha) so it's similar to the dot product
        //Vector alignment dot det
        //Same:            1   0
        //Perpendicular:   0  -1
        //Opposite:       -1   0
        //Perpendicular:   0   1
        public static float Det2(float x1, float x2, float y1, float y2)
        {
            return (x1 * y2) - (y1 * x2);
        }

        /// <summary>
        /// N으로 나눈 나머지(양의 값) return
        /// </summary>
        /// <param name="f"></param>
        /// <param name="N"></param>
        /// <returns></returns>
        public static int ModuloClamp(int f, int N)
        {
            while (f < 0)
            {
                f += N;
            }

            return f % N;
        }

        public static float RangeClamp(float fvalue, float minmax)
        {
            return Clamp(fvalue, -Math.Abs(minmax), Math.Abs(minmax));
        }

        public static float SignedClamp(float f, float fMax)
        {
            return Clamp(Math.Abs(f), 0, fMax) * Math.Sign(f);
        }

        public static float SignedClamp(float f, float fMin, float fMax)
        {
            return Clamp(Math.Abs(f), fMin, fMax) * Math.Sign(f);
        }

        public static bool InRange(float f, float low, float high)
        {
            return f >= low && f <= high;
        }

        public static bool InRange(double f, double low, double high)
        {
            return f >= low && f <= high;
        }

        public static bool InRange(int f, int low, int high)
        {
            return f >= low && f <= high;
        }

        //private static bool IsFinite(float value)
        //{
        //    return !float.IsInfinity(value) && !float.IsNaN(value);
        //}

        public static double ClampAngleDeg(double theta, double min, double max)
        {
            double c = (min + max) * 0.5;
            double e = max - c;

            theta %= 80;
            theta -= c;

            if (theta < -180)
            {
                theta += 80;
            }
            else if (theta > 180)
            {
                theta -= 80;
            }

            if (theta < -e)
            {
                theta = -e;
            }
            else if (theta > e)
            {
                theta = e;
            }

            return theta + c;
        }

        public static float ClampAngleRad(float theta, float min, float max)
        {
            float c = (min + max) * 0.5f;
            float e = max - c;

            theta %= TwoPi;

            theta -= c;
            if (theta < -Math.PI)
            {
                theta += TwoPi;
            }
            else if (theta > Math.PI)
            {
                theta -= TwoPi;
            }

            if (theta < -e)
            {
                theta = -e;
            }
            else if (theta > e)
            {
                theta = e;
            }

            return theta + c;
        }

        //-----------------------------
        // Find Intersection
        //-----------------------------
        /// <summary>
        /// 교차 구간 계산, intervals [u0, u1] and [v0, v1]
        /// 반드시 u0 <= u1, v0 <= v1 이어야 함
        /// </summary>
        /// <param name="u0"></param>
        /// <param name="u1"></param>
        /// <param name="v0"></param>
        /// <param name="v1"></param>
        /// <returns></returns>
        public static List<float> FindIntersection(float u0, float u1, float v0, float v1)
        {
            List<float> result = new();
            if (u1 < v0 || u0 > v1)
            {
                return result; // Return empty List
            }

            if (u1 > v0)
            {
                if (u0 < v1)
                {
                    if (u0 < v0)
                    {
                        result.Add(v0);
                    }
                    else
                    {
                        result.Add(u0);
                    }

                    if (u1 > v1)
                    {
                        result.Add(v1);
                    }
                    else
                    {
                        result.Add(u1);
                    }

                    return result;
                }
                else // u0 == v1
                {
                    result.Add(u0);
                    return result;
                }
            }
            else // u1 == v0
            {
                result.Add(u1);
                return result;
            }
        }

        public static WindingOrder GetWindingOrder(Vector2[] points)
        {
            if (points.Length < 1)
            {
                return 0;
            }

            int k = 0;
            float xmin = points[0].X;
            float ymin = points[0].Y;

            int n = points.Length;

            for (int i = 1; i < n; i++)
            {
                if (points[i].Y > ymin)
                {
                    continue;
                }

                if (points[i].Y == ymin)
                {
                    if (points[i].X < xmin)
                    {
                        continue;
                    }
                }
                k = i;
                xmin = points[i].X;
                ymin = points[i].Y;
            }

            return k == 0
                ? IsPointLeftOfLineDirection(points[1], points[n - 1], points[0])
                : IsPointLeftOfLineDirection(points[(k + 1) % n], points[k - 1], points[k]);
        }

        private static WindingOrder IsPointLeftOfLineDirection(Vector2 point, Vector2 prev, Vector2 next)
        {
            float test = GetPointRelationToVectorAB(point, prev, next);
            return test == 0 ? 0 : test < 0 ? WindingOrder.Clockwise : WindingOrder.CounterClockwise;
        }

        public static float GetPointRelationToVectorAB(Vector2 point, Vector2 a, Vector2 b)
        {
            float determinant = ((a.X - point.X) * (b.Y - point.Y)) - ((a.Y - point.Y) * (b.X - point.X));
            return determinant;
        }

        public static int WrapSignedIndex(int val, int mod)
        {
            while (val < 0)
            {
                val += mod;
            }

            return val % mod;
        }

        public static void MinMax(float a, float b, float c, out float min, out float max)
        {
            if (a < b)
            {
                if (a < c)
                {
                    min = a;
                    max = b > c ? b : c;
                }
                else
                {
                    min = c;
                    max = b;
                }
            }
            else
            {
                if (a > c)
                {
                    max = a;
                    min = b < c ? b : c;
                }
                else
                {
                    min = b;
                    max = c;
                }
            }
        }

        public static int Max(int a, int b, int c)
        {
            return a > b && a > c ? a : b > c ? b : c;
        }

        public static float Max(float a, float b, float c)
        {
            return a > b && a > c ? a : b > c ? b : c;
        }

        public static double Max(double a, double b, double c)
        {
            return a > b && a > c ? a : b > c ? b : c;
        }

        public static int Min(int a, int b, int c)
        {
            return a < b && a < c ? a : b < c ? b : c;
        }

        public static float Min(float a, float b, float c)
        {
            return a < b && a < c ? a : b < c ? b : c;
        }

        public static double Min(double a, double b, double c)
        {
            return a < b && a < c ? a : b < c ? b : c;
        }

        ///// <summary>
        ///// 하나의 벡터가 주어졌을 때 정규 직교 벡터 계산
        ///// Duff et all method
        ///// https://graphics.pixar.com/library/OrthonormalB/paper.pdf
        ///// </summary>
        //public static void MakeUVnormalsFromW(Vector3 nID, out Vector3 b1, out Vector3 b2)
        //{
        //    if (nID.Z < 0.0)
        //    {
        //        float a = 1.0f / (1.0f - nID.Z);
        //        float b = nID.X * nID.Y * a;

        //        b1.X = 1.0f - nID.X * nID.X * a;
        //        b1.Y = -b;
        //        b1.Z = nID.X;
        //        b2.X = b;
        //        b2.Y = nID.Y * nID.Y * a - 1.0f;
        //        b2.Z = -nID.Y;
        //    }
        //    else
        //    {
        //        float a = 1.0f / (1.0f + nID.Z);
        //        float b = -nID.X * nID.Y * a;

        //        b1.X = 1.0f - nID.X * nID.X * a;
        //        b1.Y = b;
        //        b1.Z = -nID.X;
        //        b2.X = b;
        //        b2.Y = 1.0f - nID.Y * nID.Y * a;
        //        b2.Z = -nID.Y;
        //    }
        //}

        public static float InvSqrt(float f)
        {
            return 1 / (float)Math.Sqrt(f);
        }

        /// <summary>
        /// arctangent 값을 2 pi 범위로 확장하여 양의 값으로 return;
        /// </summary>
        /// <param name="y"></param>
        /// <param name="x"></param>
        /// <returns></returns>
        public static float Atan2Positive(float y, float x)
        {
            float theta = (float)Math.Atan2(y, x);
            if (theta < 0)
            {
                theta = (2 * Pi) + theta;
            }

            return theta;
        }

        /// <summary>
        /// 두 지점 사이의 값을 parameeter t에 대해 선형보간. a와 b 사이의 선형보간을 t에 의해서 계산한 후 리턴
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="t"></param>
        /// <returns></returns>
        public static float Lerp(float a, float b, float t)
        {
            return ((1.0f - t) * a) + (t * b);
        }

        public static Vector3 Slerp(Vector3 from, Vector3 to, float alpha)
        {
            float cosine = Vector3.Dot(from, to) / (from.Length * to.Length);
            float angle = (float)Math.Acos(cosine);
            float invSine = 1.0f / (float)Math.Sin(angle);

            // compute the scale factors
            float scale1 = (float)Math.Sin((1 - alpha) * angle) * invSine;
            float scale2 = (float)Math.Sin(alpha * angle) * invSine;

            // compute slerp-ed vector
            return (scale1 * from) + (scale2 * to);
        }

        /// <summary>
        /// parameter t의 a ~ b 사이 값을 보간, S shaped sigmoid like curve
        /// https://en.wikipedia.org/wiki/Smoothstep
        /// t <=0 : 0
        /// 0 <= t <=1 : 3 * t^2 - 2*t^2
        /// t >= 1
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="t"></param>
        /// <returns></returns>
        public static float SmoothStepAMD(float a, float b, float t)
        {
            t = t * t * (3.0f - (2.0f * t));
            return ((1.0f - t) * a) + (t * b);
        }

        /// <summary>
        /// parameter t의 a ~ b 사이 값을  보간, S shaped curve (AMD)
        /// Kep Perin
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="t"></param>
        /// <returns></returns>
        public static float SmoothstepKenPerin(float a, float b, float t)
        {
            t = Clamp(t, a, b);
            return t * t * t * ((t * ((t * 6) - 15)) + 10);
        }

        public static float SmoothstepPolynomial(int N, float x)
        {
            x = Clamp(x, 0, 1); // x must be equal to or between 0 and 1
            float result = 0;
            for (int n = 0; n <= N; ++n)
            {
                result += PascalTriangle(-N - 1, n) * PascalTriangle((2 * N) + 1, N - n) * (float)Math.Pow(x, N + n + 1);
            }

            return result;
        }

        // 2차 함수 풀이 : ax^2 + bx + c = 0
        // https://en.wikipedia.org/wiki/Quadratic_formula
        public static bool SolveQuadratic(float a, float b, float c, out float x1, out float x2)
        {
            x1 = 0;
            x2 = 0;

            // can't solve if a is zero.
            if (a == 0)
            {
                return false;
            }

            float part = (b * b) - (4 * a * c);
            // can't solve if part is negative (sqrt of negative number)
            if (part < 0)
            {
                return false;
            }

            float psqrt = Convert.ToSingle(Math.Sqrt(part));
            x1 = (-b + psqrt) / (2 * a);
            x2 = (-b - psqrt) / (2 * a);
            return true;
        }

        public static void Swap<T>(ref T a, ref T b)
        {
            T temp = a;
            a = b;
            b = temp;
        }

        // data set의 순서는 그대로 두고 index를 정렬
        public static List<int> IndirectIndexSort(List<Vector2> points)
        {
            List<int> hh = new();
            for (int i = 0; i < points.Count; i++)
            {
                hh.Add(i);
            }

            hh.Sort((a, b) => points[a].CompareTo(points[b]));
            return hh;
        }

        public static List<int> IndirectIndexSort(List<Vector3> points)
        {
            List<int> hh = new();
            for (int i = 0; i < points.Count; i++)
            {
                hh.Add(i);
            }

            hh.Sort((a, b) => points[a].CompareTo(points[b]));
            return hh;
        }

        public static int PascalTriangle(int a, int b)
        {
            int result = 1;
            for (int i = 0; i < b; ++i)
            {
                result *= (a - i) / (i + 1);
            }

            return result;
        }

        /// <summary>
        /// 호출자(Caller)에게 Iterater를 0 to (nMax-1) 사이 값으로 리턴
        /// </summary>
        public static IEnumerable<int> ModuloIteration(int nMaxExclusive, int nPrime = 31337)
        {
            int i = 0;
            bool done = false;

            while (!done)
            {
                yield return i; // 호출자(Caller)에게 컬렉션 데이타를 하나씩 리턴
                i = (i + nPrime) % nMaxExclusive;
                done = i == 0;
            }
        }
        public static Plane3f? GetPlane(List<Vector3> points)
        {
            int pointCount = points.Count;
            if (pointCount < 3) // 최소한 3개의 점이 필요
            {
                return null;
            }
            Vector3 mean = MeanPoint(points, pointCount);
            float xx, xy, xz, yy, yz, zz;
            StandardDeviation(points, mean, out xx, out xy, out xz, out yy, out yz, out zz);
            Normalize(pointCount, ref xx, ref xy, ref xz, ref yy, ref yz, ref zz);
            Vector3 normal = CalculateTangent(xx, xy, xz, yy, yz);
            return SetPlane(mean, normal);
            // ----
            static Vector3 MeanPoint(List<Vector3> points, int pointCount)
            {
                Vector3 mean = Vector3.Zero;
                foreach (Vector3 point in points)
                {
                    mean += point;
                }
                mean /= pointCount;
                return mean;
            }

            static void StandardDeviation(List<Vector3> points, Vector3 mean, out float xx, out float xy, out float xz, out float yy, out float yz, out float zz)
            {
                xx = xy = xz = yy = yz = zz = 0;
                foreach (Vector3 point in points)
                {
                    Vector3 diff = point - mean;
                    float x = diff.X, y = diff.Y, z = diff.Z;
                    xx += x * x;
                    xy += x * y;
                    xz += x * z;
                    yy += y * y;
                    yz += y * z;
                    zz += z * z;
                }
            }
            static void Normalize(int pointCount, ref float xx, ref float xy, ref float xz, ref float yy, ref float yz, ref float zz)
            {
                xx /= pointCount;
                xy /= pointCount;
                xz /= pointCount;
                yy /= pointCount;
                yz /= pointCount;
                zz /= pointCount;
            }
            static Vector3 CalculateTangent(float xx, float xy, float xz, float yy, float yz)
            {
                // 행렬을 사용하여 법선 벡터를 계산 (교차 곱 사용)
                Vector3 row1 = new(xx, xy, xz);
                Vector3 row2 = new(xy, yy, yz);
                Vector3 normal = Vector3.Normalize(Vector3.Cross(row1, row2));
                return normal;
            }
            static Plane3f SetPlane(Vector3 mean, Vector3 normal)
            {
                return new Plane3f(normal, -Vector3.Dot(normal, mean));
                //a = normal.X;
                //b = normal.Y;
                //c = normal.Z;

                //// 평면 방정식의 d 값 계산
                //d = -Vector3.Dot(normal, mean);
            }
        }
    }
}
