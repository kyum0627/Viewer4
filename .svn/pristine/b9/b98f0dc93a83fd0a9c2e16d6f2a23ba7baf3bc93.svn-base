using IGX.Geometry.Common;
using IGX.Geometry.DataStructure;
using IGX.Geometry.GeometryBuilder;
using OpenTK.Mathematics;
using SixLabors.ImageSharp.Processing;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace IGX.Geometry.Tessellation
{
    public readonly struct UnitPrimitiveMesh
    {
        public IReadOnlyList<Vector3> Vertices { get; }
        public IReadOnlyList<Vector3> Normals { get; }
        public IReadOnlyList<uint> Indices { get; }
        public UnitPrimitiveMesh(IReadOnlyList<Vector3> v, IReadOnlyList<Vector3> n, IReadOnlyList<uint> ind, IReadOnlyList<uint>? edgeInd = null)
        {
            Vertices = v ?? new List<Vector3>();
            Normals = n ?? new List<Vector3>();
            Indices = ind ?? new List<uint>();
        }
    }

    public class TessellationManager
    {
        public static readonly Dictionary<ParaPrimType, Func<PrimitiveBase, uint, bool, bool, (List<Vector3> positions, List<Vector3> normals, List<uint> faceIndices)>> tessellateFunctionMap = new()
        {
            { ParaPrimType.Box, (g, nseg, bcap, tcap) => GetTessellationResult<Box>(g, b => b.Tessellate(nseg, bcap, tcap)) },
            { ParaPrimType.CircularTorus, (g, nseg, bcap, tcap) => GetTessellationResult<CircularTorus>(g, c => c.Tessellate(nseg, bcap, tcap)) },
            { ParaPrimType.Cylinder, (g, nseg, bcap, tcap) => GetTessellationResult<Cylinder>(g, c => c.Tessellate(nseg, bcap, tcap)) },
            { ParaPrimType.EllipticalDish, (g, nseg, bcap, tcap) => GetTessellationResult<EllipticalDish>(g, c => c.Tessellate(nseg, bcap, tcap)) },
            { ParaPrimType.FacetVolume, (g, nseg, bcap, tcap) => GetTessellationResult<FacetVolume>(g, c => c.Tessellate(nseg, bcap, tcap)) },
            { ParaPrimType.Pyramid, (g, nseg, bcap, tcap) => GetTessellationResult<Pyramid>(g, c => c.Tessellate(nseg, bcap, tcap)) },
            { ParaPrimType.RectangularTorus, (g, nseg, bcap, tcap) => GetTessellationResult<RectangularTorus>(g, c => c.Tessellate(nseg, bcap, tcap)) },
            { ParaPrimType.Snout, (g, nseg, bcap, tcap) => GetTessellationResult<Snout>(g, c => c.Tessellate(nseg, bcap, tcap)) },
            { ParaPrimType.Sphere, (g, nseg, bcap, tcap) => GetTessellationResult<Sphere>(g, c => c.Tessellate(nseg, bcap, tcap)) },
            { ParaPrimType.SphericalDish, (g, nseg, bcap, tcap) => GetTessellationResult<SphericalDish>(g, c => c.Tessellate(nseg, bcap, tcap)) },
            { ParaPrimType.Line, (g, _, _, _) => (new List<Vector3>(), new List<Vector3>(), new List<uint>()) }
        };
        private static (List<Vector3> pos, List<Vector3> nor, List<uint> ind) GetTessellationResult<T>(PrimitiveBase primitive, Func<T, (List<Vector3>, List<Vector3>, List<uint>)> tessellateFunc) where T : PrimitiveBase
        {
            if (primitive is T specificPrimitive)
            {
                return tessellateFunc(specificPrimitive);
            }
            return (new List<Vector3>(), new List<Vector3>(), new List<uint>());
        }

        private readonly SemaphoreSlim semaphore = new(20); // 동시에 실행할 병렬 작업의 수를 제한 (최대 20개)
        public async Task<(List<Vector3> positions, List<Vector3> normals, List<uint> faceIndices)>
            RunTessellationAsync(PrimitiveBase primitive, uint n_seg, bool bcap, bool tcap)
        {
            if (tessellateFunctionMap.TryGetValue(primitive.GeometryType, out Func<PrimitiveBase, uint, bool, bool, (List<Vector3> positions, List<Vector3> normals, List<uint> faceIndices)>? tessellateFunc))
            {
                await semaphore.WaitAsync();
                try
                {
                    (List<Vector3> positions, List<Vector3> normals, List<uint> faceIndices) result = tessellateFunc(primitive, n_seg, bcap, tcap);
                    return result;
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"테셀레이션 오류: {ex.Message}");
                    return (new List<Vector3>(), new List<Vector3>(), new List<uint>());// 오류 발생 시 빈/기본 튜플 반환
                }
                finally
                {
                    semaphore.Release();
                }
            }
            else
            {
                Debug.WriteLine($"{primitive.GeometryType} 를 테셀레이션할 함수가 없음.");
                return (new List<Vector3>(), new List<Vector3>(), new List<uint>());// 함수를 찾을 수 없는 경우 빈/기본 튜플 반환
            }
        }
    }
    public class TessellationUtility
    {
        public static uint default_nsegs = 24;
        private readonly uint[] nseg = new uint[5] { 8, 16, 24, 32, 40 }; // 캐쉬해 두려는 단위 실린더 단면 조각 ...

        public static readonly ConcurrentDictionary<uint, List<Vector2>> cachedUnitCircles = new();
        public static readonly ConcurrentDictionary<(uint n_segs, bool bCap, bool tCap), UnitPrimitiveMesh> cachedUnitCylinders = new();

        public TessellationUtility()
        {
            for (int i = 0; i < 5; i++)
            {
                CreateUnitCircle(nseg[i], 0f);
                CreateUnitCylinder(nseg[i], true, true);
            }
        }
        public static IReadOnlyList<Vector2> CreateUnitCircle(uint n_segs, float startangle = 0)
        {
            return cachedUnitCircles.GetOrAdd(n_segs, key =>
            {
                (Vector2[] positionArray, _) = GeometryHelper.MakeArc2(1, (uint)key, MathHelper.TwoPi, startangle);
                return positionArray.ToList();
            });
        }
        public static UnitPrimitiveMesh CreateUnitCylinder(uint n_segs, bool bCap = false, bool tCap = false)
        {
            var cacheKey = (n_segs, bCap, tCap);
            return cachedUnitCylinders.GetOrAdd(cacheKey, key =>
            {
                Snout snout = new(Matrix4.Identity, new AABB3(-1, -1, -0.5f, 1, 1, 0.5f), 1, 1, 1);
                (List<Vector3> positions, List<Vector3> normals, List<uint> faceIndices) = snout.Tessellate(n_segs, key.bCap, key.tCap);
                return new UnitPrimitiveMesh(positions, normals, faceIndices);
            });
        }
        private static readonly Dictionary<uint, uint[]> _cylinderIndicesCache = new Dictionary<uint, uint[]>();

        public static uint[] GetCylinderIndices(uint nSegments)
        {
            if (_cylinderIndicesCache.TryGetValue(nSegments, out var indices))
            {
                return indices;
            }

            // 옆면 + 2개의 캡 = 총 인덱스 수
            indices = new uint[nSegments * 6 + nSegments * 3 + nSegments * 3];
            int index = 0;

            // 1. 옆면 인덱스 생성
            // 0: 하단 중심, 1..nSegs: 상단, 1+nSegs..2*nSegs: 하단
            // topCenterIndex: 1+2*nSegs
            for (uint i = 0; i < nSegments; i++)
            {
                uint next = (i + 1) % nSegments;

                // 상단 정점 (i, i+1)
                uint top1 = i + 1;
                uint top2 = next + 1;

                // 하단 정점 (i, i+1)
                uint bottom1 = i + 1 + nSegments;
                uint bottom2 = next + 1 + nSegments;

                // 옆면 사각형을 두 개의 삼각형으로 분할
                indices[index++] = top1;
                indices[index++] = bottom1;
                indices[index++] = bottom2;

                indices[index++] = top1;
                indices[index++] = bottom2;
                indices[index++] = top2;
            }

            // 2. 상단 캡 인덱스 생성
            uint topCenterIndex = 1 + 2 * nSegments;
            for (uint i = 0; i < nSegments; i++)
            {
                uint next = (i + 1) % nSegments;
                indices[index++] = topCenterIndex;
                indices[index++] = i + 1;
                indices[index++] = next + 1;
            }

            // 3. 하단 캡 인덱스 생성
            uint bottomCenterIndex = 0;
            for (uint i = 0; i < nSegments; i++)
            {
                uint next = (i + 1) % nSegments;
                indices[index++] = bottomCenterIndex;
                indices[index++] = nSegments + next + 1;
                indices[index++] = nSegments + i + 1;
            }

            // 계산된 인덱스를 캐시에 추가하고 반환
            _cylinderIndicesCache[nSegments] = indices;
            return indices;
        }


        public static void AddCircularCap(uint offset, uint n, List<Vector3> pos, List<Vector3> nor, List<uint> ind, bool bReverse = true)
        { // nID = 하나의 section을 구성하는 정점의 수
            List<Vector3> addedpos = pos.GetRange((int)offset, (int)n);
            Vector3 center = new(addedpos.Average(p => p.X), addedpos.Average(p => p.Y), addedpos.Average(p => p.Z));
            Vector3 normal = (addedpos[0] - center).Cross(addedpos[1] - center).Normalized();
            addedpos.Add(center);
            if (bReverse)
            {
                normal = -normal;
            }

            IEnumerable<Vector3> addednor = Enumerable.Repeat(normal, (int)n + 1);
            uint o = (uint)pos.Count;
            for (uint i = 0; i < n; i++)
            {
                if (bReverse)
                {
                    ind.AddRange(new uint[3] { o + n, o + ((i + 1) % n), o + i });
                }
                else
                {
                    ind.AddRange(new uint[3] { o + n, o + i, o + ((i + 1) % n) });
                }
            }
            pos.AddRange(addedpos);
            nor.AddRange(addednor);
        }

        public static (List<Vector3> Positions, List<Vector3> Normals) MatrixApply(Matrix4 Transformation, List<Vector3> positions, List<Vector3> normals)//, ref OOBB3 Oobb)
        {
            if (Transformation.IsDecomposable(out Vector3 scale, out Quaternion rotQuaternion, out Vector3 translation))
            {
                Matrix4 rotationMatrix = Matrix4.CreateFromQuaternion(rotQuaternion);
                return VertexTransformation(positions, normals, Transformation, rotationMatrix);
            }
            return (positions, normals);
            // ---
            static (List<Vector3>, List<Vector3>) VertexTransformation(List<Vector3> verts, List<Vector3> nors, Matrix4 m4, Matrix4 r)
            {
                List<Vector3> transformedVerts = new(verts.Count);
                List<Vector3> transformedNors = new(nors.Count);
                for (int i = 0; i < verts.Count; i++)
                {
                    transformedVerts.Add(verts[i].Transform(m4));
                    transformedNors.Add(nors[i].Transform(r));
                }
                return (transformedVerts, transformedNors);
            }
        }
        public static void ZigZag(List<uint> indices, uint top1, uint btm1, uint top2, uint btm2)
        {
            indices.AddRange(new uint[6] { top1, btm1, top2, top2, btm1, btm2 });
        }
        private static readonly Vector3[] _unitBoxPositions = new Vector3[]
        {
            // Front face (Z+)
            new(-0.5f, 0.5f, 0.5f), new(0.5f, 0.5f, 0.5f), new(0.5f, -0.5f, 0.5f), new(-0.5f, -0.5f, 0.5f),
            // Right face (X+)
            new(0.5f, 0.5f, 0.5f), new(0.5f, 0.5f, -0.5f), new(0.5f, -0.5f, -0.5f), new(0.5f, -0.5f, 0.5f),
            // Back face (Z-)
            new(0.5f, 0.5f, -0.5f), new(-0.5f, 0.5f, -0.5f), new(-0.5f, -0.5f, -0.5f), new(0.5f, -0.5f, -0.5f),
            // Left face (X-)
            new(-0.5f, 0.5f, -0.5f), new(-0.5f, 0.5f, 0.5f), new(-0.5f, -0.5f, 0.5f), new(-0.5f, -0.5f, -0.5f),
            // Top face (Y+)
            new(-0.5f, 0.5f, -0.5f), new(0.5f, 0.5f, -0.5f), new(0.5f, 0.5f, 0.5f), new(-0.5f, 0.5f, 0.5f),
            // Bottom face (Y-)
            new(-0.5f, -0.5f, 0.5f), new(0.5f, -0.5f, 0.5f), new(0.5f, -0.5f, -0.5f), new(-0.5f, -0.5f, -0.5f)
        };

        private static readonly Vector3[] _unitBoxNormals = new Vector3[]
        {
            // Front (+Z)
            new(0,0,1), new(0,0,1), new(0,0,1), new(0,0,1),
            // Right (+X)
            new(1,0,0), new(1,0,0), new(1,0,0), new(1,0,0),
            // Back (-Z)
            new(0,0,-1), new(0,0,-1), new(0,0,-1), new(0,0,-1),
            // Left (-X)
            new(-1,0,0), new(-1,0,0), new(-1,0,0), new(-1,0,0),
            // Top (+Y)
            new(0,1,0), new(0,1,0), new(0,1,0), new(0,1,0),
            // Bottom (-Y)
            new(0,-1,0), new(0,-1,0), new(0,-1,0), new(0,-1,0)
        };

        // 수정: 인덱스 순서 반전으로 오른손 규칙 맞춤 (반시계 방향)
        private static readonly uint[] _unitBoxIndices = new uint[]
        {
            // Front: 0->2->1, 3->2->0 (반시계)
            0, 2, 1,  0, 3, 2,
            // Right: 4->6->5, 4->7->6
            4, 6, 5,  4, 7, 6,
            // Back: 8->10->9, 8->11->10
            8, 10, 9,  8, 11, 10,
            // Left: 12->14->13, 12->15->14
            12, 14, 13,  12, 15, 14,
            // Top: 16->18->17, 16->19->18
            16, 18, 17,  16, 19, 18,
            // Bottom: 20->22->21, 20->23->22
            20, 22, 21,  20, 23, 22
        };
        public static (List<Vector3> Positions, List<Vector3> Normals, List<uint> Indices)
              SixFacetsVolume(float Xbottom = 1, float Ybottom = 1, float Xtop = 1, float Ytop = 1, float Xoffset = 0, float Yoffset = 0, float Height = 1)
        {
            if (Xbottom <= 1e-5f || Ybottom <= 1e-5f || Xtop <= 1e-5f || Ytop <= 1e-5f || Height <= 1e-5f)
            {
                return (new List<Vector3>(), new List<Vector3>(), new List<uint>());
            }

            // Scale: bottom/top 평균
            var scaleMatrix = MatrixExtensions.CreateTrapezoidScale(Xbottom, Ybottom, Xtop, Ytop, Height);

            // Shear: Z축 기준 X/Y shear
            var shearMatrix = Matrix4.Identity;
            shearMatrix.M31 = Xoffset / Height;  // Z -> X shear (3행 1열)
            shearMatrix.M32 = Yoffset / Height;  // Z -> Y shear (3행 2열)
            var transformMatrix = shearMatrix * scaleMatrix;

            // Positions 변환
            var finalPositions = new List<Vector3>(_unitBoxPositions.Length);
            for (int i = 0; i < _unitBoxPositions.Length; i++)
            {
                finalPositions.Add(MatrixExtensions.TransformPosition(_unitBoxPositions[i], transformMatrix));
            }

            // Normals: 측면은 외적, Top/Bottom은 InverseTranspose
            var finalNormals = new List<Vector3>(_unitBoxNormals.Length);
            var inverseTranspose = transformMatrix.InverseTranspose();

            // 각 면의 노멀 계산 (6면: Front, Right, Back, Left, Top, Bottom)
            for (uint face = 0; face < 6; face++)
            {
                Vector3 normal;
                if (face < 4) // 측면 (Front, Right, Back, Left)
                {
                    // 첫 번째 삼각형의 정점 가져오기 (예: 0,2,1)
                    int idx0 = (int)_unitBoxIndices[face * 6];     // 첫 번째 정점
                    int idx1 = (int)_unitBoxIndices[face * 6 + 1]; // 두 번째 정점
                    int idx2 = (int)_unitBoxIndices[face * 6 + 2]; // 세 번째 정점
                    Vector3 v0 = finalPositions[idx0];
                    Vector3 v1 = finalPositions[idx1];
                    Vector3 v2 = finalPositions[idx2];

                    // 두 변 계산
                    Vector3 edge1 = v1 - v0;
                    Vector3 edge2 = v2 - v0;

                    // 외적 -> 노멀 (오른손 규칙)
                    normal = Vector3.Cross(edge1, edge2).Normalized();
                }
                else // Top, Bottom
                {
                    // Top/Bottom은 InverseTranspose로 (스케일만 적용, shear 영향 적음)
                    normal = MatrixExtensions.TransformNormal( _unitBoxNormals[face * 4], inverseTranspose).Normalized();
                }

                // 해당 면의 4개 정점에 노멀 할당
                for (int i = 0; i < 4; i++)
                {
                    finalNormals.Add(normal);
                }
            }

            // Indices 그대로
            var finalIndices = new List<uint>(_unitBoxIndices);

            return (finalPositions, finalNormals, finalIndices);
        }
        public static (List<Vector3>, List<Vector3>, List<uint>) GenerateSphereShape(uint n_longi, float radius, float arc, float sampleStartAngle, float shift_z, float scale_z, float scale, float tolerance)
        {
            // elliptical dish : Radius, arc, startAngle, shift_z, scale_z, scale, tolerance
            // sphere          : Radius, Math.PI, 0f, 0f, 1f, scale, tolerance
            // spherical dish  : Radius, arc, startAngle, shift_z, 1f, scale, tolerance
            if (n_longi == 1)
            {
                n_longi = Sagitta.SegmentCount(MathUtil.TwoPi, radius, scale, tolerance);
            }
            //float error = Sagitta.BasedError(MathUtil.TwoPi, radius, scale, n_longi);

            bool is_sphere = IsSphere();

            const uint min_rings = 3; // 최소 링 수
            uint n_latti = (uint)Math.Max(min_rings, scale_z * n_longi * arc * (2.0f / MathUtil.TwoPi));

            uint[] u0 = new uint[n_latti]; // 각 링에 대한 샘플 수
            Vector2[] nors = new Vector2[n_latti]; // 각 링별 lattidude 값
            float del_beta = arc / (n_latti - 1); // del1 lattidude

            for (uint north = 0; north < n_latti; north++)
            {
                float lattidude = del_beta * north;
                nors[north].X = (float)Math.Cos(lattidude);
                nors[north].Y = (float)Math.Sin(lattidude);
                u0[north] = n_longi;
            }

            // 양 극점에서의 node는 가각 1개이므로 수자를 조정
            u0[0] = 1; // 북극점에서의 segment 수
            if (is_sphere)
            {
                u0[n_latti - 1] = 1; // 구일 경우 남극점의 segment 수
            }

            List<Vector3> normals = new();
            List<Vector3> vertices = new();
            List<uint> indices = new();

            for (int north = 0; north < n_latti; north++)
            {// 각각의 위도별
                float nz = nors[north].X;
                float z = (radius * scale_z * nz) + shift_z; // 반경,이심율, Shift 값을 고려한 lattitude
                float w = nors[north].Y;
                uint n = u0[north];

                double del_alpha = Math.PI * 2 / n;
                // 경도 좌표 계산
                for (int i = 0; i < n; i++)
                {
                    double phi = (del_alpha * i) + sampleStartAngle; // 현재 샘플의 φ 계산
                    float nx = (float)(w * Math.Cos(phi)); // x 좌표
                    float ny = (float)(w * Math.Sin(phi)); // z 좌표
                    normals.Add(new Vector3(nx, ny, nz / scale_z)); // 법선 추가
                    vertices.Add(new Vector3(radius * nx, radius * ny, z)); // 정점 추가
                }
            }

            uint n_prev = 0; // 이전 링의 시작 인덱스

            for (uint i_latt = 0; i_latt + 1 < n_latti; i_latt++)
            {
                uint n_curr = u0[i_latt]; // 현재 위도의 샘플 수
                uint n_next = u0[i_latt + 1]; // 다음 위도의 샘플 수
                uint next_id = n_prev + n_curr; // 다음 위도의 시작 인덱스

                if (n_curr < n_next)
                { // 현재 위도의 샘플 수가 다음 위도보다 적은 경우
                    for (uint i = 0; i < n_next; i++)
                    {
                        uint ii_n = i + 1;
                        uint i_c = n_curr * (i + 1) / n_next; // 현재 위도 샘플 인덱스
                        uint ii_c = n_curr * (ii_n + 1) / n_next; // 다음 위도 샘플 인덱스

                        i_c %= n_curr;
                        ii_c %= n_curr;
                        ii_n %= n_next;

                        if (i_c != ii_c)
                        { // 삼각형을 만들기 위한 인덱스 추가
                          //MakeTriangleIndices(ref hedges, n_prev + i_c, next_id + ii_n, n_prev + ii_c);
                            indices.AddRange(new uint[3] { n_prev + i_c, next_id + ii_n, n_prev + ii_c });
                        }
                        //MakeTriangleIndices(ref hedges, n_prev + i_c, next_id + i, next_id + ii_n);
                        indices.AddRange(new uint[3] { n_prev + i_c, next_id + i, next_id + ii_n });
                    }
                }
                else
                {// 현재 위도의 샘플 수가 다음 위도보다 많은 경우
                    for (uint i_c = 0; i_c < n_curr; i_c++)
                    {
                        uint ii_c = i_c + 1; // 다음 샘플 인덱스
                        uint i_n = n_next * i_c / n_curr; // 다음 위도 샘플 인덱스
                        uint ii_n = n_next * ii_c / n_curr; // 다음 위도 샘플 인덱스

                        i_n %= n_next;
                        ii_n %= n_next;
                        ii_c %= n_curr;
                        indices.AddRange(new uint[3] { n_prev + i_c, next_id + ii_n, n_prev + ii_c });

                        if (i_n != ii_n)
                        {
                            indices.AddRange(new uint[3] { n_prev + i_c, next_id + i_n, next_id + ii_n });
                        }
                    }
                }
                n_prev = next_id; // 다음 위도의 시작 인덱스 업데이트
            }

            return (vertices, normals, indices); // 생성된 메쉬 반환

            bool IsSphere()
            {
                if (Math.Abs(arc - Math.PI) < 1e-3)
                { // 아크가 π에 가까우면 구로 렌더링
                    arc = (float)Math.PI;
                    return true;
                }
                return false;
            }
        }
    }
}