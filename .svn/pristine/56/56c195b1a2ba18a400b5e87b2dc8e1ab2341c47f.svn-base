using System;
using System.Collections.Generic;
using System.Linq;
using OpenTK.Mathematics;
using IGX.Geometry.Common;
using IGX.Geometry.ConvexHull;

namespace IGX.Geometry.DataStructure
{
    public class Loop3 : IEquatable<Loop3>
    {
        public bool IsHole = false;
        public AABB3 box = AABB3.Empty;
        public OOBB3 oobb = OOBB3.Empty;
        public Vertex[] Vertices;
        public Vector3 COG = Vector3.Zero;
        public float Area = 0;
        public float Perimeter = 0;
        public Loop3()
        {
            Vertices = Array.Empty<Vertex>();
        }
        public Loop3(uint n)
        {
            Vertices = new Vertex[n];
        }
        //public void Reverse()
        //{
        //    Vertices.Reverse();
        //}
        public override String ToString()
        {
            String txt = string.Format("N Vertices = {0,6}\nID", Vertices.Length);
            for (int i = 0; i < Vertices.Length; i++)
            {
                txt += Vertices[i].ToString();
            }
            return txt;
        }
        public Loop3(Vertex[] vertices, bool isHole = false)
        { // 정점 배열을 받아서 컨투어 객체를 생성하며, AssemblyAABB 계산
            Vertices = vertices.Distinct().ToArray();
            Vertices.ToList().ForEach(v => box.Contain(v.Position));
        }
        public IEnumerable<Vector3> GetNormals() => Vertices.Select(vertex => vertex.Normal);  // 정점들의 법선 벡터를 반환
        public IEnumerable<Vector3> GetPoints() => Vertices.Select(vertex => vertex.Position); // 정점들의 위치 벡터를 반환
        public IEnumerable<Vector3> GetUniqueNormals() => Vertices.Select(vertex => vertex.Normal).Distinct();  // 중복되지 않는 법선 벡터 반환
        public IEnumerable<Vector3> GetUniquePoints() => Vertices.Select(vertex => vertex.Position).Distinct(); // 중복되지 않는 위치 벡터 반환
        // 정점 인덱스와 함께 중복되지 않는 법선 벡터를 반환
        public Dictionary<Vector3, List<int>> GetUniqueNormalsWithIndices() =>
            Vertices
                .Select((vertex, index) => new { vertex.Normal, index })
                .GroupBy(x => x.Normal)
                .ToDictionary(g => g.Key, g => g.Select(x => x.index).ToList());
        // 정점 인덱스와 함께 중복되지 않는 위치 벡터를 반환
        public Dictionary<Vector3, List<int>> GetUniquePointsWithIndices() =>
            Vertices
                .Select((vertex, index) => new { vertex.Position, index })
                .GroupBy(x => x.Position)
                .ToDictionary(g => g.Key, g => g.Select(x => x.index).ToList());
        // 정점들로부터 AABB를 계산
        public AABB3 GetBound()
        {
            if (Vertices == null || Vertices.Length == 0)
            {
                return AABB3.Empty;
            }

            box = AABB3.Empty;
            foreach (Vector3 p in GetPoints())
            {
                box.Contain(p);
            }
            return box;
        }
        private bool HasValidVertices() => Vertices?.Length >= 3; // 정점들이 유효한지 확인
        public bool AreVerticesOnTheSamePlane(float tolerance = 1e-05f)
        { // 정점들이 동일 평면에 있는지 확인
            if (!HasValidVertices())
            {
                throw new ArgumentException("평면 생성을 위해서는 최소 세 점 이상 필요함.");
            }

            List<Vector3> points = GetPoints().ToList();
            Plane3f? plane = MathUtil.GetPlane(points);
            if (plane != null)
            {
                float a = plane.Value.normal.X;
                float b = plane.Value.normal.X;
                float c = plane.Value.normal.X;
                float d = plane.Value.constant;
                return points.All(p => Math.Abs((a * p.X) + (b * p.Y) + (c * p.Z) + d) <= tolerance);
            }
            return false;
        }
        // 시계방향 여부 판단
        public static bool IsClockwise(Vertex[] vertices)
        {
            if (vertices == null || vertices.Length < 3)
            {
                return false;
            }

            float areaSum = 0f;
            for (int i = 0; i < vertices.Length; i++)
            {
                Vector3 current = vertices[i].Position;
                Vector3 next = vertices[(i + 1) % vertices.Length].Position;
                areaSum += ((current.X * next.Y) - (next.X * current.Y));  // 2D 교차곱 사용
            }
            return areaSum > 0;
        }

        // 질량 속성 계산 (면적, 둘레, 무게 중심, AssemblyAABB)
        public void CalculateMassProperties(Plane3f plane)
        {
            Area = 0;
            Perimeter = 0;
            COG = Vector3.Zero;
            box = AABB3.Empty;

            List<Vector3> vl = GetUniquePoints().ToList();
            int numVertices = vl.Count;

            if (numVertices < 3)
            {
                return;
            }

            Vector3 normal = plane.normal;
            if (normal.LengthSquared > 1 + float.Epsilon)
            {
                normal = Vector3.Normalize(normal);
            }

            for (int i = 0; i < numVertices; i++)
            {
                Vector3 currentVertex = vl[i];
                Vector3 nextVertex = vl[(i + 1) % numVertices];
                box.Contain(currentVertex);
                Vector3 edgeVector = nextVertex - currentVertex;

                Vector3 crossProduct = Vector3.Cross(currentVertex, nextVertex);
                float triangleArea = Vector3.Dot(crossProduct, normal) / 2;
                Area += triangleArea;
                Perimeter += edgeVector.Length;

                COG += currentVertex;
            }
            if (numVertices > 0)
            {
                COG /= numVertices;
            }
            oobb = ComputeFlatBox(vl, plane.normal);
        }

        // 평면에 대해 최소 면적 박스 계산
        public OOBB3 ComputeFlatBox(List<Vector3> points, Vector3 FaceNormal, float epsilon = float.Epsilon)
        {
            if (FaceNormal == Vector3.Zero)
            {
                return OOBB3.Empty;
            }
            Vector3 U = Vector3.Zero;
            Vector3 V = Vector3.Zero;
            FaceNormal = FaceNormal.MakeUVnormalsFromW(out U, out V);
            Vector3[] points3 = new Vector3[points.Count];
            Vector2[] points2 = new Vector2[points.Count];
            for (int k = 0; k < points.Count; k++)
            {
                Vector3 diff = points[k] - points[0];
                points2[k] = new Vector2(Vector3.Dot(U, diff), Vector3.Dot(V, diff));
                points3[k] = new Vector3(Vector3.Dot(U, diff), Vector3.Dot(V, diff), 0f);
            }
            MinimumAreaBox box2 = new(points2.ToList());
            //box2.Compute(points2.ToList());
            OOBB3 obb = OOBB3.Empty;
            obb.extent[0] = box2.MinBox.extent[0] + epsilon;
            obb.extent[1] = box2.MinBox.extent[1] + epsilon;
            obb.extent[2] = epsilon;
            obb.axisX = (box2.MinBox.Axis(0).X * U) + (box2.MinBox.Axis(0).Y * V);
            obb.axisY = (box2.MinBox.Axis(1).X * U) + (box2.MinBox.Axis(1).Y * V);
            obb.axisZ = FaceNormal;
            obb.center = points[0] + (box2.MinBox.center.X * U) + (box2.MinBox.center.Y * V);
            return obb;
        }

        // 2D 폴리곤 반환
        public Polygon2 Get2dPolygon(int ignore)
        {
            Polygon2 poly = new();
            List<Vector3> points = Vertices.Select(vertex => vertex.Position).ToList();

            box = AABB3.Empty;
            List<Vector2> points2D = points.Select(v => v.Get2DVector(ignore)).ToList();

            poly.points.AddRange(points2D);
            poly.GetBound();
            return poly;
        }

        // 무시된 축을 제외한 2D 벡터 리스트 반환
        public List<Vector2> Get2DVectors(int ignoredcoordinate)
        {
            return GetPoints().Select(v => v.Get2DVector(ignoredcoordinate)).ToList();
        }

        // 면적을 부호까지 포함하여 계산
        public float SignedArea(Plane3f plane)
        {
            return Vertices.Length < 3
                ? throw new InvalidOperationException("면적 계산에는 최소 세 점이 필요함.")
                : plane.normal.SignedArea(GetPoints().ToList());
        }
        public bool Equals(Loop3? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;
            if (this.Vertices.Length != other.Vertices.Length) return false;

            for (int startOffset = 0; startOffset < other.Vertices.Length; startOffset++)
            {
                bool isMatch = true;
                for (int i = 0; i < this.Vertices.Length; i++)
                {
                    int otherIndex = (startOffset + i) % other.Vertices.Length;
                    if (!this.Vertices[i].Equals(other.Vertices[otherIndex]))
                    {
                        isMatch = false;
                        break;
                    }
                }
                if (isMatch)
                {
                    return true;
                }
            }
            return false;
        }
        public override int GetHashCode()
        {
            unchecked // 오버플로 무시
            {
                int hash = 17;
                if (Vertices != null)
                {
                    foreach (var vertex in Vertices)
                    {
                        hash = hash * 23 + vertex.GetHashCode();
                    }
                }
                return hash;
            }
        }
    }
}
