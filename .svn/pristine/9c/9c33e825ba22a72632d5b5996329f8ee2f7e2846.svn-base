using IGX.ViewControl.Buffer.Common;
using OpenTK.Graphics.OpenGL4;
using System;
using System.Runtime.CompilerServices;

namespace IGX.ViewControl.Buffer
{
    public class ShaderStorageBuffer<TInstance> : MutableBuffer<TInstance> where TInstance : struct
    {
        private readonly object _bindLock = new();

        public ShaderStorageBuffer(ReadOnlySpan<TInstance> data, BufferUsageHint usageHint, bool keepCpuData = false)
            : base(data.ToArray(), BufferTarget.ShaderStorageBuffer, usageHint, keepCpuData)
        {
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot create ShaderStorageBuffer without an active OpenGL context.");
            }
            try
            {
                if (!data.IsEmpty)
                {
                    SetData(data);
                    CheckGLError();
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException("Failed to initialize ShaderStorageBuffer.", ex);
            }
        }

        public void BindBase(int bindingIndex)
        {
            if (IsDisposed) throw new ObjectDisposedException(nameof(ShaderStorageBuffer<TInstance>));
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot bind ShaderStorageBuffer without an active OpenGL context.");
            }
            if (bindingIndex < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(bindingIndex), "Binding index must be non-negative.");
            }

            lock (_bindLock)
            {
                GL.BindBufferBase(BufferRangeTarget.ShaderStorageBuffer, bindingIndex, Handle);
                CheckGLError();
            }
        }

        public void UpdateStorageData(int startIndex, ReadOnlySpan<TInstance> newData)
        {
            if (IsDisposed) throw new ObjectDisposedException(nameof(ShaderStorageBuffer<TInstance>));
            if (!keepCpuData)
            {
                throw new InvalidOperationException("CPU data is not maintained. Set keepCpuData to true in the constructor.");
            }
            if (startIndex < 0 || newData.Length < 0 || startIndex + newData.Length > Count)
            {
                throw new ArgumentOutOfRangeException(nameof(startIndex), "Storage data range is out of bounds.");
            }
            if (newData.IsEmpty) return;
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot update storage data without an active OpenGL context.");
            }

            var cpuData = CpuData;
            if (cpuData.IsEmpty)
            {
                throw new InvalidOperationException("CPU _instancedBuffer is not maintained.");
            }

            newData.CopyTo(cpuData.Slice(startIndex, newData.Length));

            try
            {
                lock (_bindLock)
                {
                    UpdateData(newData, (nint)(startIndex * Unsafe.SizeOf<TInstance>()));
                    CheckGLError();
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException("Failed to update _shader storage _instancedBuffer data.", ex);
            }
        }

        private static bool IsContextLikelyActive()
        {
            try
            {
                GL.GetError();
                return true;
            }
            catch
            {
                return false;
            }
        }

        private static void CheckGLError()
        {
            var error = GL.GetError();
            if (error != ErrorCode.NoError)
            {
                throw new InvalidOperationException($"OpenGL error: {error}");
            }
        }
    }
}