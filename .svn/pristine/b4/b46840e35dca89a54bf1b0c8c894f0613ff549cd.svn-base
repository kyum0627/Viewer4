using IGX.Geometry.Common;
using IGX.Geometry.ConvexHull;
using IGX.Geometry.DataStructure;
using IGX.Geometry.Tessellation;
using OpenTK.Mathematics;
using System;
using System.Collections.Generic;
using System.Linq;

namespace IGX.Geometry.GeometryBuilder
{
    public class CircularTorus : PrimitiveBase
    {
        public float Offset;
        public float Radius;
        public float Angle;
        public int GeometryID { get => InstanceData.GeometryID; set => InstanceData.GeometryID = value; }

        public CircularTorus(Matrix4 matrix, AABB3 bBoxLocal, float offset, float radius, float angle)
        {
            Offset = offset;
            Radius = radius;
            Angle = angle;
        }

        public override (List<Vector3> positions, List<Vector3> normals, List<uint> indices) Tessellate(uint n_seg, bool bcap = true, bool tcap = true)
        {
            uint nn = Sagitta.SegmentCount(Angle, Offset + Radius, 1, 5);
            uint n_longi = nn + 1;
            float del_beta = Angle / nn;

            List<Vector2> nor2 = TessellationUtility.CreateUnitCircle(n_seg).ToList();

            List<Vector3> section = nor2.ConvertAll(n => new Vector3(Radius * n.X, Radius * n.X, Radius * n.Y));
            for (int i = 0; i < n_longi; i++)
            {
                float beta = del_beta * i; float cosr = (float)Math.Cos(beta); float sinr = (float)Math.Sin(beta);
                Vector3 translate = new(Offset * cosr, Offset * sinr, 0f);

                for (int j = 0; j < n_seg; j++)
                {
                    Vector3 sectionPoint = section[j];
                    float x = (sectionPoint.X * cosr) + translate.X;
                    float y = (sectionPoint.Y * sinr) + translate.Y; float z = sectionPoint.Z + translate.Z;
                    Points.Add(new Vector3(x, y, z));

                    Vector3 normal = new Vector3(nor2[j].X * cosr, nor2[j].X * sinr, nor2[j].Y).Normalized();
                    Normals.Add(normal);
                }
            }

            CreateTorusIndices(n_longi, n_seg, Indices);

            if (bcap)
            {
                TessellationUtility.AddCircularCap(0, n_seg, Points, Normals, Indices, true);
            }
            if (tcap)
            {
                TessellationUtility.AddCircularCap(n_longi * n_seg, n_seg, Points, Normals, Indices, false);
            }

            (List<Vector3> Positions, List<Vector3> Normals) res = TessellationUtility.MatrixApply(InstanceData.Model, Points, Normals);
            Points = res.Positions;
            Normals = res.Normals;
            return (Points, Normals, Indices);
        }

        static void CreateTorusIndices(uint n_longi, uint n_segs, List<uint> indices)
        {
            for (uint i = 0; i < n_longi - 1; i++)
            {
                uint next_loop = (i + 1);
                for (uint j = 0; j < n_segs; j++)
                {
                    uint next_j = (j + 1) % n_segs;
                    TessellationUtility.ZigZag(indices,
                        (i * n_segs) + j, (next_loop * n_segs) + j, (i * n_segs) + next_j, (next_loop * n_segs) + next_j);
                }
            }
        }
    }
}