using OpenTK.Graphics.OpenGL4;
using System;
using System.Collections.Concurrent;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;
using Image = SixLabors.ImageSharp.Image;

namespace IGX.ViewControl.Buffer
{
    public sealed class Texture : IDisposable
    {
        private static readonly ConcurrentQueue<int> _pendingDeletionTextures = new();
        private readonly object _lockObject = new();

        public int Handle { get; private set; }
        public int Width { get; private set; }
        public int Height { get; private set; }
        private bool _isDisposed;

        public Texture(
            string path,
            TextureMinFilter minFilter = TextureMinFilter.Linear,
            TextureMagFilter magFilter = TextureMagFilter.Linear,
            TextureWrapMode wrapS = TextureWrapMode.Repeat,
            TextureWrapMode wrapT = TextureWrapMode.Repeat,
            bool generateMipmaps = false)
        {
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot create Texture without an active OpenGL context.");
            }
            if (string.IsNullOrEmpty(path) || !System.IO.File.Exists(path))
            {
                throw new ArgumentException("Invalid or non-existent file path.", nameof(path));
            }

            try
            {
                lock (_lockObject)
                {
                    Handle = GL.GenTexture();
                    CheckGLError();

                    GL.BindTexture(TextureTarget.Texture2D, Handle);
                    CheckGLError();

                    using var image = Image.Load<Rgba32>(path);
                    Width = image.Width;
                    Height = image.Height;

                    var pixelData = new byte[Width * Height * 4];
                    image.CopyPixelDataTo(pixelData);

                    GL.TexImage2D(
                        TextureTarget.Texture2D,
                        0,
                        PixelInternalFormat.Rgba,
                        Width,
                        Height,
                        0,
                        PixelFormat.Rgba,
                        PixelType.UnsignedByte,
                        pixelData
                    );
                    CheckGLError();

                    SetTextureParameters(minFilter, magFilter, wrapS, wrapT, generateMipmaps);

                    GL.BindTexture(TextureTarget.Texture2D, 0);
                    CheckGLError();
                }
            }
            catch (Exception ex)
            {
                if (Handle != 0)
                {
                    _pendingDeletionTextures.Enqueue(Handle);
                    Handle = 0;
                }
                throw new InvalidOperationException("Failed to create Texture.", ex);
            }
        }

        public Texture(
            ReadOnlySpan<byte> data,
            int width,
            int height,
            TextureMinFilter minFilter = TextureMinFilter.Linear,
            TextureMagFilter magFilter = TextureMagFilter.Linear,
            TextureWrapMode wrapS = TextureWrapMode.Repeat,
            TextureWrapMode wrapT = TextureWrapMode.Repeat,
            bool generateMipmaps = false)
        {
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot create Texture without an active OpenGL context.");
            }
            if (width <= 0 || height <= 0)
            {
                throw new ArgumentException("Width and height must be positive.", nameof(width));
            }
            if (data.Length < width * height * 4)
            {
                throw new ArgumentException("Data size is insufficient for the specified dimensions (RGBA format).", nameof(data));
            }

            try
            {
                lock (_lockObject)
                {
                    Handle = GL.GenTexture();
                    CheckGLError();

                    GL.BindTexture(TextureTarget.Texture2D, Handle);
                    CheckGLError();

                    Width = width;
                    Height = height;

                    var data2 = new byte[width * height * 4];

                    GL.TexImage2D(
                        TextureTarget.Texture2D,
                        0,
                        PixelInternalFormat.Rgba,
                        width,
                        height,
                        0,
                        PixelFormat.Rgba,
                        PixelType.UnsignedByte,
                        data2
                    );
                    CheckGLError();

                    SetTextureParameters(minFilter, magFilter, wrapS, wrapT, generateMipmaps);

                    GL.BindTexture(TextureTarget.Texture2D, 0);
                    CheckGLError();
                }
            }
            catch (Exception ex)
            {
                if (Handle != 0)
                {
                    _pendingDeletionTextures.Enqueue(Handle);
                    Handle = 0;
                }
                throw new InvalidOperationException("Failed to create Texture.", ex);
            }
        }

        public void UpdateData(ReadOnlySpan<byte> data, int x, int y, int width, int height)
        {
            if (_isDisposed)
            {
                throw new ObjectDisposedException(nameof(Texture));
            }
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot update texture data without an active OpenGL context.");
            }
            if (x < 0 || y < 0 || width <= 0 || height <= 0 || x + width > Width || y + height > Height)
            {
                throw new ArgumentException("Invalid region dimensions or coordinates.", nameof(width));
            }
            if (data.Length < width * height * 4)
            {
                throw new ArgumentException("Data size is insufficient for the specified region (RGBA format).", nameof(data));
            }

            try
            {
                lock (_lockObject)
                {
                    GL.BindTexture(TextureTarget.Texture2D, Handle);
                    CheckGLError();
                    var data2 = new byte[width * height * 4];

                    GL.TexSubImage2D(
                        TextureTarget.Texture2D,
                        0,
                        x,
                        y,
                        width,
                        height,
                        PixelFormat.Rgba,
                        PixelType.UnsignedByte,
                        data2
                    );
                    CheckGLError();

                    GL.BindTexture(TextureTarget.Texture2D, 0);
                    CheckGLError();
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException("Failed to update texture data.", ex);
            }
        }

        public void UpdateData(nint data, int x, int y, int width, int height)
        {
            if (_isDisposed)
            {
                throw new ObjectDisposedException(nameof(Texture));
            }
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot update texture data without an active OpenGL context.");
            }
            if (x < 0 || y < 0 || width <= 0 || height <= 0 || x + width > Width || y + height > Height)
            {
                throw new ArgumentException("Invalid region dimensions or coordinates.", nameof(width));
            }
            if (data == nint.Zero)
            {
                throw new ArgumentException("Data pointer cannot be null.", nameof(data));
            }

            try
            {
                lock (_lockObject)
                {
                    GL.BindTexture(TextureTarget.Texture2D, Handle);
                    CheckGLError();

                    GL.TexSubImage2D(
                        TextureTarget.Texture2D,
                        0,
                        x,
                        y,
                        width,
                        height,
                        PixelFormat.Rgba,
                        PixelType.UnsignedByte,
                        data
                    );
                    CheckGLError();

                    GL.BindTexture(TextureTarget.Texture2D, 0);
                    CheckGLError();
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException("Failed to update texture data.", ex);
            }
        }

        public void Bind(TextureUnit textureUnit = TextureUnit.Texture0)
        {
            if (_isDisposed)
            {
                throw new ObjectDisposedException(nameof(Texture));
            }
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot bind texture without an active OpenGL context.");
            }

            lock (_lockObject)
            {
                GL.ActiveTexture(textureUnit);
                GL.BindTexture(TextureTarget.Texture2D, Handle);
                CheckGLError();
            }
        }

        public static void ProcessPendingDeletions()
        {
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot process pending texture deletions without an active OpenGL context.");
            }

            while (_pendingDeletionTextures.TryDequeue(out int handle))
            {
                try
                {
                    GL.DeleteTexture(handle);
                    CheckGLError();
                    Console.WriteLine($"Texture {handle} deleted.");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Warning: Failed to delete texture {handle}: {ex.Message}");
                }
            }
        }

        public void Dispose()
        {
            lock (_lockObject)
            {
                if (_isDisposed)
                {
                    return;
                }

                if (Handle != 0)
                {
                    if (IsContextLikelyActive())
                    {
                        _pendingDeletionTextures.Enqueue(Handle);
                    }
                    else
                    {
                        Console.WriteLine($"Warning: Cannot delete texture {Handle} without an active OpenGL context. Enqueued for later deletion.");
                        _pendingDeletionTextures.Enqueue(Handle);
                    }
                    Handle = 0;
                }

                _isDisposed = true;
            }
            GC.SuppressFinalize(this);
        }

        private void SetTextureParameters(TextureMinFilter minFilter, TextureMagFilter magFilter, TextureWrapMode wrapS, TextureWrapMode wrapT, bool generateMipmaps)
        {
            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)minFilter);
            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)magFilter);
            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)wrapS);
            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)wrapT);

            if (generateMipmaps)
            {
                GL.GenerateMipmap(GenerateMipmapTarget.Texture2D);
            }
            CheckGLError();
        }

        private static bool IsContextLikelyActive()
        {
            try
            {
                GL.GetError();
                return true;
            }
            catch
            {
                return false;
            }
        }

        private static void CheckGLError()
        {
            var error = GL.GetError();
            if (error != ErrorCode.NoError)
            {
                throw new InvalidOperationException($"OpenGL error: {error}");
            }
        }
    }
}