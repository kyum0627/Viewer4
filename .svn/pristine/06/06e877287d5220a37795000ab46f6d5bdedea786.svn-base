using IGX.Geometry.Common;
using IGX.Geometry.ConvexHull;
using IGX.Geometry.DataStructure;
using OpenTK.Graphics.OpenGL4;
using OpenTK.Mathematics;
using System;
using System.Collections.Generic;
using System.Linq;
namespace IGX.Geometry.GeometryBuilder
{
    public interface IGXobject
    {
        Vector3 Scale { get; }
        Quaternion Rotation { get; }
        Vector3 Translation { get; }
        void Draw();
    }
    public interface IBoundable
    {
        AABB3 Aabb { get; set; }
        OOBB3 Oobb { get; set; }
    }
    public abstract class PrimitiveBase : IGXobject, IBoundable, IEquatable<PrimitiveBase>
    {
        //private Mesh _mesh = new Mesh();
        public List<Vector3> Points = new List<Vector3>();
        public List<Vector3> Normals = new List<Vector3>();
        public List<uint> Indices = new List<uint>();
        public (List<Vertex> vertices, List<uint> indices) MeshData()
        {
            return Points.Count != Normals.Count
                ? throw new InvalidOperationException("정점 위치와 법선 리스트의 길이가 동일해야 Vertex 객체를 생성할 수 있음.")
                : ((List<Vertex> vertices, List<uint> indices))(
                Points.Select((p, i) => new Vertex(p, Normals[i])).ToList(),
                Indices.ToList());
        }
        public uint ColorID { get; set; } = 1;
        public string GrandPrimType { get; set; } = string.Empty;
        public ParaPrimType GeometryType { get; set; } = ParaPrimType.None;
        public GeometryInstance InstanceData { get; set; } = new GeometryInstance();
        public AABB3 Aabb { get; set; } = AABB3.Empty;
        public OOBB3 Oobb { get; set; } = OOBB3.Empty;
        public PrimitiveType GLprimitive => PrimitiveType.Triangles;
        public Vector3 Scale { get; set; } = Vector3.One;
        public Quaternion Rotation { get; set; } = Quaternion.Identity;
        public Vector3 Translation { get; set; } = Vector3.Zero;
        public abstract (List<Vector3> positions, List<Vector3> normals, List<uint> indices) Tessellate(uint n_seg, bool bBcap = true, bool bTcap = true);
        public void SetTransform(Matrix4 matrix)
        {
            Rotation = matrix.ExtractRotation();
            Translation = matrix.ExtractTranslation();
        }
        public Triangle3f GetTriangle(int index, out AABB3 box)
        {
            int offset = index * 3;
            if (offset < 0 || offset + 2 >= Indices.Count)
            {
                throw new ArgumentOutOfRangeException(nameof(index), $"삼각형 인덱스 {index}는 유효 범위를 벗어남. 총 {Indices.Count / 3}개의 삼각형이 있음.");
            }
            Vector3[] v = new Vector3[]
            {
                Points[(int)Indices[offset]],
                Points[(int)Indices[offset + 1]],
                Points[(int)Indices[offset + 2]]
            };
            box = AABB3.Empty;
            box.Contain(v[0]);
            box.Contain(v[1]);
            box.Contain(v[2]);
            return new Triangle3f(v[0], v[1], v[2]);
        }

        /// <summary>
        /// 특정 지오메트리(메시) 내의 각 삼각형과 레이의 교차를 검사하여 가장 가까운 충돌 지점을 찾고,
        /// 필요한 경우 <paramref name="bestCandidate"/> 및 관련 정보를 업데이트
        /// 이 메서드는 <see cref="FindClosestObjectHitByRay"/>에서 호출됨.
        /// </summary>
        /// <param name="ray">충돌을 검사할 3D 레이</param>
        public bool Collide(Ray3f ray)
        {
            int numTriangles = Indices.Count / 3;
            float? closestDistance = float.MaxValue;

            for (int j = 0; j < numTriangles; j++)
            {
                Triangle3f triangle = GetTriangle(j, out AABB3 triangleAabb);
                if (triangleAabb.Intersects(ray, ref closestDistance))
                {
                    if (triangle.RayIntersectsTriangle(ray, out float intersectionDistance))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        public bool Equals(PrimitiveBase? other)
        {
            if (GeometryType != other.GeometryType) return false;
            if (Points.Count != other!.Points.Count) return false;
            if (Normals.Count != other.Normals.Count) return false;
            if (Indices.Count != other.Indices.Count) return false;
            if (InstanceData.Model != other.InstanceData.Model) return false;
            if (Points != other.Points) return false;
            if (Normals != other.Normals) return false;
            if (Indices != other.Indices) return false;
            return true;
        }
        public override int GetHashCode()
        {
            unchecked
            {
                int hash = 17;

                // Mesh 데이터 해시
                hash = hash * 23 + GeometryType.GetHashCode();
                hash = hash * 23 + InstanceData.Model.GetHashCode();
                hash = hash * 23 + Points.Aggregate(0, (acc, p) => acc ^ p.GetHashCode());
                hash = hash * 23 + Normals.Aggregate(0, (acc, n) => acc ^ n.GetHashCode());
                hash = hash * 23 + Indices.Aggregate(0, (acc, i) => acc ^ i.GetHashCode());
                hash = hash * 23 + InstanceData.Model.GetHashCode();

                return hash;
            }
        }
        // Add these lines inside the PrimitiveBase class declaration
        private int _vaoHandle;
        private int _vboHandle;
        private int _eboHandle;
        private bool _isInitialized = false;
        public void Initialize()
        {
            if (_isInitialized) return;

            // 1. VAO, VBO, EBO 생성
            _vaoHandle = GL.GenVertexArray();
            _vboHandle = GL.GenBuffer();
            _eboHandle = GL.GenBuffer();

            // 2. VAO 바인딩
            GL.BindVertexArray(_vaoHandle);

            // 3. VBO에 정점 위치 및 법선 데이터 업로드
            GL.BindBuffer(BufferTarget.ArrayBuffer, _vboHandle);
            var vertexData = new float[Points.Count * 6];
            for (int i = 0; i < Points.Count; i++)
            {
                vertexData[i * 6 + 0] = Points[i].X;
                vertexData[i * 6 + 1] = Points[i].Y;
                vertexData[i * 6 + 2] = Points[i].Z;
                vertexData[i * 6 + 3] = Normals[i].X;
                vertexData[i * 6 + 4] = Normals[i].Y;
                vertexData[i * 6 + 5] = Normals[i].Z;
            }
            GL.BufferData(BufferTarget.ArrayBuffer, vertexData.Length * sizeof(float), vertexData, BufferUsageHint.StaticDraw);

            // 4. EBO에 인덱스 데이터 업로드
            GL.BindBuffer(BufferTarget.ElementArrayBuffer, _eboHandle);
            GL.BufferData(BufferTarget.ElementArrayBuffer, Indices.Count * sizeof(int), Indices.ToArray(), BufferUsageHint.StaticDraw);

            // 5. 정점 속성 설정
            GL.EnableVertexAttribArray(0); // 위치
            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, false, 6 * sizeof(float), 0);
            GL.EnableVertexAttribArray(1); // 법선
            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, false, 6 * sizeof(float), 3 * sizeof(float));

            // 6. 바인딩 해제
            GL.BindVertexArray(0);
            _isInitialized = true;
        }
        public void Draw()
        {
            if (!_isInitialized)
            {
                Initialize(); // 초기화되지 않았다면 자동으로 초기화
            }
            GL.BindVertexArray(_vaoHandle);
            GL.DrawElements(PrimitiveType.Points, Indices.Count, DrawElementsType.UnsignedInt, 0);
            GL.BindVertexArray(0);
        }
        public void DrawAndDispose()
        {
            Initialize(); // 1. GPU에 데이터 업로드 및 초기화
            Draw();       // 2. 렌더링 명령 실행
            Dispose();    // 3. GPU 리소스 해제
        }
        public void Dispose()
        {
            if (!_isInitialized) return;

            GL.DeleteBuffer(_vboHandle);
            GL.DeleteBuffer(_eboHandle);
            GL.DeleteVertexArray(_vaoHandle);

            _isInitialized = false;
        }
    }
}
