using System;
using OpenTK.Mathematics;

namespace IGX.Geometry.Common
{
    /// <summary>
    /// 세그먼트를 세그먼트의 중점과 방향 벡터를 이용한 parametric DistanceManager 값으로 표현
    /// 시작점 parameter -0.5
    /// 끝점 parameter 0.5
    /// </summary>
	public struct Segment2f// : IParametricCurve2f
    {
        private Vector2 p0;
        private Vector2 p1;

        public Vector2 center;    // 선분의 중심
        public Vector2 direction; // Uni.Length
        public float extent;       // 선분의 길이 / 2

        /// <summary>
        /// 폐곡선 여부
        /// </summary>
        public bool IsClosed
        {
            get { return false; }
        }

        /// <summary>
        /// 세그먼트 길이
        /// </summary>
        public float Length
        {
            get { return 2 * extent; }
        }

        /// <summary>
        /// 세그먼트 시작점
        /// </summary>
        public Vector2 P0
        {
            get { return p0; }
            set { p0 = value; }
        }

        /// <summary>
        /// 세그먼트 끝점
        /// </summary>
        public Vector2 P1
        {
            get { return p1; }
            set { p1 = value; }
        }

        public Segment2f(bool bZero = true)
        {
            p0 = Vector2.Zero;
            p1 = Vector2.Zero;
            center = Vector2.Zero;
            direction = Vector2.Zero;
            extent = 0;
        }

        /// <summary>
        /// 시작점 p0ID, 끝점 p1으로 세그먼트 생성
        /// extent와 direction 계산
        /// </summary>
        /// <param name="A"></param>
        /// <param name="B"></param>
        public Segment2f(Vector2 A, Vector2 B)
        {
            p0 = A;
            p1 = B;
            direction = B - A;
            center = 0.5f * (A + B);
            extent = 0.5f * direction.Length;
            direction = Vector2.Normalize(direction); // d;
        }

        public Segment2f(float x0, float y0, float x1, float y1)
        {
            p0 = new Vector2(x0, y0);
            p1 = new Vector2(x1, y1);
            direction = p1 - p0;
            center = 0.5f * (p0 + p1);
            extent = 0.5f * direction.Length;
            direction = Vector2.Normalize(direction);// d;
        }

        /// <summary>
        /// 세그먼트의 중섬, 방향 및 extent 값으로 세그먼트 생성
        /// </summary>
        /// <param name="C"></param>
        /// <param name="dir"></param>
        /// <param name="ext"></param>
        public Segment2f(Vector2 C, Vector2 dir, float ext)
        {
            center = C;
            direction = Vector2.Normalize(dir);// d;
            extent = ext;
            p0 = C - (ext * direction);
            p1 = C + (ext * direction);
        }

        /// <summary>
        /// 이 세그먼트에서 점 p까지 최단 거리
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public float Distance(Vector2 p)
        {
            return (float)Math.Sqrt(DistanceSquared(P0, P1, p));
        }

        public float DistanceSquared(Vector2 pt)
        {
            return DistanceSquared(P0, P1, pt);
        }

        ///// <summary>
        ///// this 점에서 segment의 양 끝점, 수직 projection 중 최단 거리 계산
        ///// </summary>
        ///// <param name="seg"></param>
        ///// <returns></returns>
        //public static float DistanceManager(Vector2f vec, Segment2f seg)
        //{
        //    return vec.DistanceTo(GeometricTools.ClosestPointToSegment(vec, seg, true));
        //}

        //public float DistanceManager(Segment2f seg2, ref float[] parameter, ref Vector2f[] ControlPoints, ref float distanceSqr)
        //{
        //    DistanceSeg2Seg2 dist = new DistanceSeg2Seg2(this, seg2);
        //    dist.Compute();
        //    parameter = new float[2];
        //    parameter[0] = dist.s1Parameter;
        //    parameter[1] = dist.s2Parameter;

        //    ControlPoints = new Vector2f[2];
        //    ControlPoints[0] = dist.pointOnS1;
        //    ControlPoints[1] = dist.pointOnS2;

        //    distanceSqr = dist.distanceSqr;

        //    return dist.DistanceManager;
        //}

        /// <summary>
        /// 평면상의 점 pt에서 default_nsegs[a, b] 까지 최단 거리의 제곱을 return
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="pt"></param>
        /// <returns></returns>
        private static float DistanceSquared(Vector2 a, Vector2 b, Vector2 pt, float eps = MathUtil.Epsilon)
        {
            float vx = b.X - a.X, vy = b.Y - a.Y;
            float len2 = (vx * vx) + (vy * vy); // a, b 사이의 거리의 제곱

            float dx = pt.X - a.X;
            float dy = pt.Y - a.Y;

            if (len2 < eps)
            {
                return (dx * dx) + (dy * dy); // 선분의 길이가 거의 zero인 경우 pt에서 a까지 거리
            }

            float t = (dx * vx) + (dy * vy);  // 가로 길이간 곱 + 세로 길이간 곱

            if (t <= 0)  // pt가 a 밖에 존재하면 a ~ pt 간 거리 
            {
                return (dx * dx) + (dy * dy);
            }
            else if (t >= len2) // pt가 b 밖에 존재하면 b ~ pt 간 거리
            {
                dx = pt.X - b.X;
                dy = pt.Y - b.Y;
                return (dx * dx) + (dy * dy);
            }

            dx = pt.X - (a.X + (t * vx / len2));
            dy = pt.Y - (a.Y + (t * vy / len2));

            return (dx * dx) + (dy * dy);
        }

        public AABB2 GetBounds()
        {
            if (direction == Vector2.Zero)
            {
                return AABB2.Empty;
            }

            AABB2 bx = new(P0);
            bx.Contain(P1);

            return bx;
        }

        public bool Intersects(Segment2f seg2, float dotThresh = float.Epsilon)//, float intervalThresh = 0)
        {
            return GeometricTools.AreIntersect(this, seg2, true, dotThresh);
        }

        // t in range[0,1] spans arc
        /// <summary>
        /// 선분의 구간 [-extent, +extent]을 parametric 구간 [0, 1]에 대응시킬 때 parameter t인 점
        /// t가 구간[0, 1]을 벗어나면 선분 바깥의 점을 return
        /// </summary>
        /// <param name="t"></param>
        /// <returns></returns>
        public Vector2 GetPointAt(float t)
        {
            return center + (((2 * t) - 1) * extent * direction);
        }

        /// <summary>
        /// 선분 방향 바꾸기
        /// </summary>
		public void Reverse()
        {
            direction *= -1;
        }

        /// <summary>
        /// 선분의 시작점에거 선분 진행 방향으로 거리 a 떨어진 점
        /// </summary>
        /// <param name="a"></param>
        /// <returns></returns>
        public Vector2 SampleArcLength(float a)
        {
            return P0 + (a * direction);
        }

        /// <summary>
        /// 선분의 기울기, 전구간에서 같음
        /// </summary>
        /// <param name="t"></param>
        /// <returns></returns>
        public Vector2 TangentT(float t)
        {
            return direction;
        }

        /// <summary>
        /// 3차원 세그먼트로 좌표 복원, 2D -> 3D recover
        /// coordtorecover
        /// 0 : X coord recover = 0, Y, Z 값 불변
        /// 1 : Y coord recover = 1, Z, X 값 불변
        /// 2 : Z coord recover = 2, X, Y 값 불변
        /// </summary>
        /// <param name="plane"></param>
        /// <param name="s"></param>
        /// <param name="coordtorecover"></param>
        /// <returns></returns>
        public Segment3f To3D(Plane3f plane, Segment2f s, int coordtorecover)
        {
            float x0 = 0;
            float y0 = 0;
            float z0 = 0;
            float x1 = 0;
            float y1 = 0;
            float z1 = 0;

            float inv = 1 / plane.normal[coordtorecover];

            switch (coordtorecover)
            {
                case 0:
                    y0 = s.P0.X;
                    z0 = s.P0.Y;
                    x0 = inv * (plane.constant - (plane.normal.Y * y0) - (plane.normal.Z * z0));
                    y1 = s.P1.X;
                    z1 = s.P1.Y;
                    x1 = inv * (plane.constant - (plane.normal.Y * y1) - (plane.normal.Z * z1));
                    break;
                case 1:
                    z0 = s.P0.X;
                    x0 = s.P0.Y;
                    y0 = inv * (plane.constant - (plane.normal.Z * z0) - (plane.normal.X * x0));
                    z1 = s.P1.X;
                    x1 = s.P1.Y;
                    y1 = inv * (plane.constant - (plane.normal.Z * z1) - (plane.normal.X * x1));
                    break;
                case 2:
                    x0 = s.P0.X;
                    y0 = s.P0.Y;
                    z0 = inv * (plane.constant - (plane.normal.X * x0) - (plane.normal.Y * y0));
                    x1 = s.P1.X;
                    y1 = s.P1.Y;
                    z1 = inv * (plane.constant - (plane.normal.X * x1) - (plane.normal.Y * y1));
                    break;
            }

            return new Segment3f(new Vector3(x0, y0, z0), new Vector3(x1, y1, z1));
        }

        public override string ToString()
        {
            return string.Format("{0}, {1}", P0, P1);
        }

        public string ToString(string fmt)
        {
            return string.Format("{0}, {1}", P0.ToString(fmt), P1.ToString(fmt));
        }

        /// <summary>
        /// 두 점 p0ID, p1으로 선분 update
        /// </summary>
        /// <param name="p0"></param>
        /// <param name="p1"></param>
        void UpdateFromEndpoints(Vector2 p0, Vector2 p1)
        {
            center = 0.5f * (p0 + p1);
            direction = p1 - p0;
            extent = 0.5f * direction.Length;
            direction = Vector2.Normalize(direction);
        }
    }
}
