using OpenTK.Graphics.OpenGL4;
using OpenTK.Graphics;
using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace IGX.ViewControl.Buffer.Common
{
    public static class GLResourceManager
    {
        private static readonly ConcurrentQueue<int> _pendingDeletionHandles = new();
        public static void EnqueueForDeletion(int handle)
        {
            _pendingDeletionHandles.Enqueue(handle);
        }

        public static void ProcessPendingDeletions()
        {
            if (!IsContextActive())
            {
                // 컨텍스트가 없으면 삭제를 연기하거나 로깅
                return; // 또는 throw new InvalidOperationException("No active OpenGL context.");
            }

            if (_pendingDeletionHandles.IsEmpty)
                return;

            var handles = new List<int>();
            while (_pendingDeletionHandles.TryDequeue(out int handle))
            {
                handles.Add(handle);
            }

            if (handles.Count > 0)
            {
                GL.DeleteBuffers(handles.Count, handles.ToArray());
            }
        }
        private static bool IsContextActive()
        {
            try
            {
                GL.GetError();
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
    public abstract class GLBuffer<T> : IDisposable where T : struct
    {
        private const int InvalidHandle = 0;

        private readonly BufferUsageHint _usage;
        private bool _isDisposed;
        public int Handle { get; private set; }
        public BufferTarget BufferTarget { get; }
        public int Count { get; protected set; }
        public bool IsValid => Handle != InvalidHandle && !_isDisposed;
        public BufferUsageHint BufferUsageHint => _usage;
        public bool IsDisposed => _isDisposed;
        protected GLBuffer(BufferTarget target, BufferUsageHint usage)
        {
            BufferTarget = target;
            _usage = usage;
            Handle = GL.GenBuffer();
        }

        public virtual unsafe void SetData(ReadOnlySpan<T> data)
        {
            if (_isDisposed)
            {
                throw new ObjectDisposedException(nameof(GLBuffer<T>));
            }
            Bind();
            var size = data.Length * Unsafe.SizeOf<T>();
            var dataPtr = Unsafe.AsPointer(ref MemoryMarshal.GetReference(data));
            GL.BufferData(BufferTarget, new nint(size), (nint)dataPtr, _usage);
            Count = data.Length;
            Unbind();
        }
        public virtual unsafe void GetData(Span<T> destination)
        {
            if (_isDisposed)
            {
                throw new ObjectDisposedException(nameof(GLBuffer<T>));
            }
            if (destination.Length < Count)
            {
                throw new ArgumentException("Destination span is too small.", nameof(destination));
            }
            Bind();
            fixed (T* ptr = destination)
            {
                GL.GetBufferSubData(BufferTarget, nint.Zero, new nint(Count * Unsafe.SizeOf<T>()), (nint)ptr);
            }
            Unbind();
        }

        public virtual ReadOnlySpan<T> GetData()
        {
            T[] data = new T[Count];
            GetData(data);
            return data;
        }

        public virtual unsafe void UpdateData(ReadOnlySpan<T> data, nint offset)
        {
            if (_isDisposed)
            {
                throw new ObjectDisposedException(nameof(GLBuffer<T>));
            }
            Bind();
            var size = data.Length * Unsafe.SizeOf<T>();
            var dataPtr = Unsafe.AsPointer(ref MemoryMarshal.GetReference(data));
            GL.BufferSubData(BufferTarget, offset, new nint(size), (nint)dataPtr);
            Unbind();
        }

        public void Bind()
        {
            if (!IsValid)
            {
                throw new InvalidOperationException("Cannot bind an invalid or disposed _instancedBuffer.");
            }

            GL.BindBuffer(BufferTarget, Handle);
        }

        public void Unbind()
        {
            GL.BindBuffer(BufferTarget, 0);
        }
        protected virtual void Dispose(bool disposing)
        {
            if (_isDisposed) return;
            _isDisposed = true;

            if (Handle != InvalidHandle)
            {
                if (IsContextActive())
                {
                    GLResourceManager.EnqueueForDeletion(Handle);
                }
                else
                {
                    Console.WriteLine($"Warning: Buffer {Handle} could not be enqueued for deletion due to missing OpenGL context.");
                }
                Handle = InvalidHandle;
            }
        }

        private static bool IsContextActive()
        {
            try
            {
                GL.GetError();
                return true;
            }
            catch
            {
                return false;
            }
        }
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        ~GLBuffer()
        {
            Dispose(false);
        }
    }
}