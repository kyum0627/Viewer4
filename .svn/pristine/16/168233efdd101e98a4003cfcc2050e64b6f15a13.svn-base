using IGX.Geometry.Common;
using IGX.Geometry.DataStructure;
using IGX.Geometry.GeometryBuilder;
using IGX.Geometry.Tessellation;
using OpenTK.Mathematics;
using System.Collections.Concurrent;
using System.Diagnostics;

namespace IGX.Loader.AMFileLoader
{
    public class RvmLoader : ModelLoader
    {
        public TessellationManager tessellationManager = new();
        private static string? endianType;

        /// <summary>
        /// Binary로 저장된 RVM 파일을 읽어서 Parsing
        /// </summary>
        /// <param name="inputFileName"></param>
        public RvmLoader(string inputFileName)
        {
            Load(inputFileName);
        }

        public void Load(string filename)
        {
            Header.Name = filename;
            using (MemoryStream? stream = OpenStreamb(filename))
            {
                if (stream != null)
                {
                    Parseb(stream);
                }
            }
        }
        private void Parseb(MemoryStream stream)
        {
            Stopwatch parseStopwatch = Stopwatch.StartNew();

            // 1단계: 청크 데이터 파싱 (순차적 또는 병렬)
            int nvol = 0;
            MakeChunkDict(stream, out var chunkSpec, ref nvol);

            var primInsuObstChunks = chunkSpec
                .Where(c => c.Key.Item1 is "PRIM" or "INSU" or "OBST")
                .ToList();

            var allPrimitives = new ConcurrentBag<PrimitiveBase>();
            int nextGeometryID = -1;

            Parallel.ForEach(primInsuObstChunks, s =>
            {
                string chunktype = s.Key.Item1;
                var (_, _, _, _, assyid, chunkData) = s.Value;

                using (MemoryStream localStream = new(chunkData))
                {
                    var color = assemblies[assyid].Color;
                    var volume = ReadPRIMchunkb(localStream, assyid, chunktype, color, chunktype != "PRIM");

                    if (volume != null)
                    {
                        int geometryID = Interlocked.Increment(ref nextGeometryID);
                        volume.InstanceData.GeometryID = geometryID;
                        allPrimitives.Add(volume);
                    }
                }
            });

            parseStopwatch.Stop();
            Console.WriteLine($"[성능 측정] 파싱 단계 소요 시간: {parseStopwatch.ElapsedMilliseconds}ms");
            Stopwatch tessellationStopwatch = Stopwatch.StartNew();

            // 2단계: 테셀레이션 (파싱 완료 후 병렬로 수행)
            var tessellationTasks = allPrimitives.Select(volume =>
                Task.Run(() => tessellationManager.RunTessellationAsync(volume, TessellationUtility.default_nsegs, true, true))
            ).ToList();

            Task.WhenAll(tessellationTasks).Wait();
            tessellationStopwatch.Stop();
            Debug.WriteLine($"[성능 측정] 테셀레이션 단계 소요 시간: {tessellationStopwatch.ElapsedMilliseconds}ms");

            geometries = allPrimitives
                .OrderBy(item => item.InstanceData.GeometryID)
                .ToDictionary(item => item.InstanceData.GeometryID, item => item);

            modelBoundingBox = new AABB3();
            foreach (var geometry in geometries.Values)
            {
                modelBoundingBox.Contain(geometry.Aabb);
            }
        }
        private void MakeChunkDict(MemoryStream stream, out Dictionary<(string, long), (uint, uint, string, int, int, byte[])> chunkSpec, ref int nvol)
        {
            chunkSpec = [];
            string chunkType;
            int parent = -1;
            int gid = 0;
            Stack<int> parents = new();

            do
            {
                long startPosition = stream.Position;
                byte[] bytes = new byte[28];
                if (stream.Read(bytes, 0, bytes.Length) < 28)
                {
                    break;
                }

                chunkType = GetChunkID(bytes);
                GetChunkSpec(out uint nextheaderposition, out uint unknown, out uint version, bytes);

                long chunkDataLength = nextheaderposition - stream.Position;
                byte[] chunkData = new byte[chunkDataLength];
                stream.Read(chunkData, 0, (int)chunkDataLength);

                long position = startPosition + 28;

                if (chunkType == "HEAD")
                {
                    Header = ChunkParser.ChunkHEADb(new MemoryStream(chunkData), version);
                }
                else if (chunkType == "MODL")
                {
                    (Header.project, Header.Name) = ChunkParser.ChunkMODLb(new MemoryStream(chunkData));
                }
                else if (chunkType == "COLR")
                {
                    VolColor c = ChunkParser.ChunkCOLRb(new MemoryStream(chunkData));
                    if (!colors.TryGetValue(c.ColorKey, out _))
                    {
                        colors[c.ColorKey] = c;
                    }
                }
                else if (chunkType is "PRIM" or "INSU" or "OBST")
                {
                    chunkSpec[(chunkType, position)] = (nextheaderposition, version, assemblies[parent].Name, gid++, parent, chunkData);
                    nvol++;
                }
                else if (chunkType == "CNTB")
                {
                    parents.Push(parent);

                    var (name, translation, color, items) = ParseCNTBData(new MemoryStream(chunkData));

                    int aid = assemblies.Count;
                    chunkSpec[(chunkType, position)] = (nextheaderposition, version, name, aid, parent, chunkData);

                    Assembly currentAssy = new(parent, name, translation, color)
                    {
                        ID = aid
                    };
                    if (items != null)
                    {
                        currentAssy.Attributes.Add("items.AM_Type", items.AM_Type!);
                        currentAssy.Attributes.Add("items.AM_ID", items.AM_ID.ToString()!);
                        currentAssy.Attributes.Add("items.ModelType", items.ModelType!);
                    }
                    assemblies[aid] = currentAssy;
                    parent = aid;
                }
                else
                {
                    if (chunkType == "CNTE" && parents.Count > 0)
                    {
                        parent = parents.Pop();
                    }
                    chunkSpec[(chunkType, position)] = (nextheaderposition, version, chunkType, -1, parent, chunkData);
                }
                stream.Position = nextheaderposition;
            } while (chunkType != "END:" && chunkType != "EOF");
        }

        private (string name, Vector3 translation, uint color, Item? items) ParseCNTBData(MemoryStream stream)
        {
            string name = BinaryDataReader.ReadStringb(stream);
            float[] p = BinaryDataReader.ParseFloatsb(stream, 3);
            Vector3 translation = new(p[0], p[1], p[2]);
            Item? items = PartTypeParserByShipYard.ParseData(name);
            uint color = BinaryDataReader.ReadUint32(stream);

            return (name, translation, color, items);
        }

        private static MemoryStream? OpenStreamb(string fileName)
        {
            try
            {
                if (!File.Exists(fileName))
                {
                    throw new FileNotFoundException(ErrorMessages.FileNotFound + fileName);
                }
                using FileStream fileStream = new(fileName, FileMode.Open, FileAccess.Read);
                MemoryStream memoryStream = new();

                byte[] bytes = new byte[4];
                int bytesRead = fileStream.Read(bytes, 0, bytes.Length);
                if (bytesRead < 4)
                {
                    throw new InvalidDataException(ErrorMessages.InsufficientBytes + fileName);
                }
                endianType = EndianTypeChecker.CheckEndianType(bytes);
                fileStream.Position = 0;
                fileStream.CopyTo(memoryStream);
                memoryStream.Position = 0;
                return memoryStream;
            }
            catch (FileNotFoundException ex)
            {
                Console.Error.WriteLine(ErrorMessages.FileNotFound + ex.FileName);
                return null;
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine(ErrorMessages.UnexpectedError + ex.Message);
                return null;
            }
        }

        public Dictionary<int, IAssembly> GetAssemblies()
        {
            return assemblies;
        }

        private static string GetChunkID(byte[] bytes)
        {
            return $"{(char)bytes[3]}{(char)bytes[7]}{(char)bytes[11]}{(char)bytes[15]}";
        }

        private static void GetChunkSpec(out uint nextheaderposition, out uint unknown, out uint version, byte[] bytes)
        {
            nextheaderposition = BitConverter.ToUInt32(bytes, 16);
            unknown = BitConverter.ToUInt32(bytes, 20);
            version = BitConverter.ToUInt32(bytes, 24);

            if (BitConverter.IsLittleEndian)
            {
                nextheaderposition = BinaryDataReader.EndianConvert(nextheaderposition);
                unknown = BinaryDataReader.EndianConvert(unknown);
                version = BinaryDataReader.EndianConvert(version);
            }
        }

        private PrimitiveBase? ReadPRIMchunkb(MemoryStream stream, int assyid, string p_i_o, uint color, bool hasTransparency = false)
        {
            PrimitiveBase? primitive = null;
            ParaPrimType primitiveTypeToParse = (ParaPrimType)BinaryDataReader.ReadUint32(stream);

            Matrix4 oripos = ParseMatrix4(stream);
            AABB3 aabb = ReadAABB3(stream);

            if (hasTransparency)
            {
                SetTransParencyb(stream, ref color);
            }

            primitive = ParseEachPrimitive(stream, primitiveTypeToParse, oripos, aabb, primitive);
            if (primitive != null)
            {
                primitive.SetTransform(oripos);
                primitive.InstanceData.GeomType = primitiveTypeToParse;
                primitive.InstanceData.Model = oripos;
                primitive.GeometryType = primitiveTypeToParse;

                if (primitive.GeometryType != ParaPrimType.FacetVolume)
                {
                    (primitive.Aabb, primitive.Oobb) = GeometryFactory.UpdateAabbOobb(oripos, aabb);
                }
                SetPrimitiveData(assyid, p_i_o, color, primitive);
            }

            modelBoundingBox.Contain(aabb);
            return primitive;
        }
        private static AABB3 ReadAABB3(MemoryStream stream)
        {
            float[] p = BinaryDataReader.ParseFloatsb(stream, 6);
            AABB3 bBoxLocal = new(new Vector3(p[0], p[1], p[2]), new Vector3(p[3], p[4], p[5]));
            return bBoxLocal;
        }

        private static Matrix4 ParseMatrix4(MemoryStream stream)
        {
            float[] p = BinaryDataReader.ParseFloatsb(stream, 12);
            Matrix4 oripos = Matrix4.Identity;
            int k = 0;
            for (int i = 0; i < 4; i++)
            {
                for (int j = 0; j < 3; j++)
                {
                    oripos[i, j] = p[k++] * 1000f;
                }
            }
            oripos[3, 3] = 1f;
            return oripos;
        }

        private static PrimitiveBase? ParseEachPrimitive(MemoryStream stream, ParaPrimType primitiveTypeToParse, Matrix4 oripos, AABB3 aabb, PrimitiveBase? primitive)
        {
            if (PrimitiveBinaryDataReader.PrimParseFunctionMap.TryGetValue(primitiveTypeToParse, out Func<MemoryStream, Matrix4, AABB3, PrimitiveBase?>? parseFunction))
            {
                primitive = parseFunction(stream, oripos, aabb);
            }
            else
            {
                primitive = null;
            }
            return primitive;
        }

        private void SetPrimitiveData(int parent, string p_i_o, uint color, PrimitiveBase primitive)
        {
            primitive.GrandPrimType = p_i_o;
            primitive.InstanceData.GeometryID = geometries.Count;
            primitive.InstanceData.EassemblyID = parent;
            primitive.ColorID = color;
        }
        private static void SetTransParencyb(MemoryStream stream, ref uint color)
        {
            byte[] bytes = new byte[4];
            stream!.Read(bytes, 0, 4);
        }
    }
}