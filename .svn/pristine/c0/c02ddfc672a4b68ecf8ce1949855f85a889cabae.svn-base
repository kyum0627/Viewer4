namespace IGX.ViewControl.Render
{
    public static class ShaderSource2
    {
        private const string Version = @"#version 440 core";

        private const string Defines = @"
            #define HIDDEN_LAYER -1
            #define SHADE_MODE_DEFAULT 0
            #define SHADE_MODE_XRAY 1
            #define SHADE_MODE_WHITE 2
        ";

        // --- Uniform Blocks ---
        private const string CameraBlock = @"
            layout(std140, binding = 0) uniform CameraBlock {
                mat4 uView;
                mat4 uProjection;
                vec3 uViewPosition;
            };
        ";

        private const string LightBlock = @"
            layout(std140, binding = 1) uniform LightBlock {
                vec3 uLightPosition;
                vec3 uLightDirection;
                vec3 uLightColor;
                float uAmbientStrength;
                float uSpecularStrength;
                int   uShininess;
            };
        ";

        private const string ClippingBlock = @"
            const int MAX_CLIPPING_PLANES = 6;
            layout(std140, binding = 2) uniform ClippingBlock {
                int uNumClippingPlanes;
                vec4 uClippingPlanes[MAX_CLIPPING_PLANES];
            };
        ";

        // --- Instance Attribute Data ---
        private const string PositionNormal = @"
            layout(location = 0) in vec3 aPos;
            layout(location = 1) in vec3 aNormal;
        ";

        private const string AssemblyInfo = @"
            layout(location = 8) in int EassemblyID;
            layout(location = 9) in int MeshID;
            layout(location =10) in int GeometryType;
            layout(location =11) in int geoLayer;
        ";

        private const string InstanceData = PositionNormal + AssemblyInfo + @"
            layout(location = 2) in mat4 instanceModel;
            layout(location = 6) in vec4 instanceColor;
            layout(location = 7) in int selectMode;
        ";

        // --- Phong Lighting Function ---
        private const string LightingFunc = LightBlock + @"
            vec3 calculatePhongShading(vec3 fragmentPosition, vec3 fragmentNormal, vec4 objectColor)
            {
                vec3 norm = normalize(fragmentNormal);
                vec3 lightDir = normalize(uLightDirection);
                vec3 ambient = uAmbientStrength * uLightColor;

                float diff = max(dot(norm, lightDir), 0.0);
                vec3 diffuse = diff * uLightColor;

                vec3 halfwayDir = normalize(-lightDir);
                float spec = pow(max(dot(norm, halfwayDir), 0.0), uShininess);
                vec3 specular = uSpecularStrength * spec * uLightColor;

                vec3 result = (ambient + diffuse + specular) * objectColor.rgb;
                return result;
            }
        ";

        // ================================================================
        // G-Buffer Pass
        // ================================================================
        public const string gBufferVtx = Version + Defines + CameraBlock + InstanceData + @"
            uniform int shadeMode;

            out vec3 FragPos;
            out vec3 Normal;
            out vec4 AlbedoColor;

            flat out int vsOutObjectID;
            flat out int shadeModeIn;
            flat out int vsLayer;

            void main()
            {
                mat4 model = mat4(instanceModel);
                gl_Position = uProjection * uView * model * vec4(aPos, 1.0);
                FragPos = (model * vec4(aPos, 1.0)).xyz;
                Normal = mat3(transpose(inverse(model))) * aNormal;

                vsOutObjectID = EassemblyID;
                shadeModeIn = shadeMode;
                vsLayer = geoLayer;
                
                switch(shadeModeIn)
                {
                    case SHADE_MODE_XRAY:
                        AlbedoColor = vec4(0.05, 0.10, 0.25, 0.40);
                        break;
                    case SHADE_MODE_WHITE:
                        AlbedoColor = vec4(1, 1, 1, 1);
                        break;
                }

                if(selectMode == 99) AlbedoColor.a = 0;
            }";

        public const string gBufferFrg = Version + Defines + @"
            layout(location = 0) out vec3 gPosition;
            layout(location = 1) out vec3 gNormal;
            layout(location = 2) out vec4 gAlbedo;
            layout(location = 3) out int gObjectID;
            layout(location = 4) out float gXrayOverlapAccum;

            in vec3 FragPos;
            in vec3 Normal;
            in vec4 AlbedoColor;
            flat in int vsOutObjectID;
            flat in int shadeModeIn;
            flat in int vsLayer;

            void main()
            {
                if (AlbedoColor.a < 1 || vsLayer < HIDDEN_LAYER)
                {
                    discard;
                }

                gPosition = FragPos;
                gNormal = normalize(Normal);
                gAlbedo = AlbedoColor;
                gObjectID = vsOutObjectID;
                gXrayOverlapAccum = (shadeModeIn == 1) ? 0.1 : 0.0;
            }";

        // ================================================================
        // Outline Post Processing
        // ================================================================
        public const string outlinePostFrg = Version + CameraBlock + LightingFunc + @"
            out vec4 FragColor;
            in vec2 TexCoords;

            // --- G-_instancedBuffer Textures ---
            uniform sampler2D gPosition;
            uniform sampler2D gNormal;
            uniform sampler2D gAlbedo;
            uniform sampler2D gDepthStencil;
            uniform isampler2D gObjectID;
            uniform sampler2D gXrayOverlapAccum;

            // --- Screen Parameters ---
            uniform vec2 uScreenSize;
            uniform int uDrawEdge;
            uniform vec3 uEdgelineColor;
            uniform float uEdgelineThickness;

            const float DEPTH_THRESHOLD_WORLD = 0.5;
            const float NORMAL_THRESHOLD_DOT = 0.50;
            const float COLOR_THRESHOLD = 0.01;

            bool detectEdge(vec3 currentFragPos, vec3 currentNormal, float currentDepth, int currentObjectID, vec4 currentAlbedoColor)
            {
                vec2 texelSize = uEdgelineThickness / uScreenSize;
                vec2 offsets[4] = vec2[](
                    vec2(1.0, 0.0), vec2(-1.0, 0.0),
                    vec2(0.0, 1.0), vec2(0.0, -1.0)
                );

                for (int i = 0; i < 4; ++i)
                {
                    vec2 neighborTexCoords = TexCoords + offsets[i] * texelSize;

                    vec3 neighborFragPos = texture(gPosition, neighborTexCoords).rgb;
                    vec3 neighborNormal = texture(gNormal, neighborTexCoords).rgb;
                    float neighborDepth = texture(gDepthStencil, neighborTexCoords).r;
                    int neighborObjectID = texture(gObjectID, neighborTexCoords).r;
                    vec4 neighborAlbedo = texture(gAlbedo, neighborTexCoords);

                    if (currentObjectID != neighborObjectID) return true;
                    if (dot(currentNormal, neighborNormal) < NORMAL_THRESHOLD_DOT) return true;
                    if (abs(currentDepth - neighborDepth) > DEPTH_THRESHOLD_WORLD) return true;
                    if (distance(currentAlbedoColor.rgb, neighborAlbedo.rgb) > COLOR_THRESHOLD) return true;
                }
                return false;
            }
            
            void main()
            {
                if (texture(gAlbedo, TexCoords).a < 0.01)
                {
                    discard;
                }
                vec3 FragPos = texture(gPosition, TexCoords).rgb;
                vec3 Normal = normalize(texture(gNormal, TexCoords).rgb);
                vec4 AlbedoColor = texture(gAlbedo, TexCoords);
                float currentDepth = texture(gDepthStencil, TexCoords).r;
                int currentObjectID = texture(gObjectID, TexCoords).r;

                vec3 phongResult = calculatePhongShading(FragPos, Normal, AlbedoColor);

                if (uDrawEdge == 1)
                {
                    bool isEdge = detectEdge(FragPos, Normal, currentDepth, currentObjectID, AlbedoColor);
                    if (isEdge)
                    {
                        FragColor = vec4(uEdgelineColor, 1.0);
                        return;
                    }
                }
                FragColor = vec4(phongResult, AlbedoColor.a);
            }";

        public const string quadVtx = Version + @"
            layout (location = 0) in vec2 aPos;
            layout (location = 1) in vec2 aTexCoords;

            out vec2 TexCoords;

            void main()
            {
                TexCoords = aTexCoords;
                gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);
            }";

        // ================================================================
        // Simple Shader (No Normal)
        // ================================================================
        public const string simpleVertex_NoNormal = Version + CameraBlock + @"
            layout(location = 0) in vec3 aPos;
            uniform mat4 uModel;

            void main()
            {
                gl_Position = uProjection * uView * uModel * vec4(aPos, 1.0);
            }";

        public const string simpleFragment_NoNormal = Version + @"
            out vec4 FragColor;
            uniform vec4 uObjectColor;
    
            void main()
            {
                FragColor = uObjectColor;
            }";

        // ================================================================
        // Simple Shader (With Normal)
        // ================================================================
        public const string simpleVertex_WithNormal = Version + CameraBlock + PositionNormal + @"
            uniform mat4 uModel;

            out vec3 Normal;
            out vec3 FragPos;

            void main()
            {
                gl_Position = uProjection * uView * uModel * vec4(aPos, 1.0);
                FragPos = (uModel * vec4(aPos, 1.0)).xyz;
                Normal = mat3(transpose(inverse(uModel))) * aNormal;
            }";

        public const string simpleFragment_WithNormal = Version + CameraBlock + LightingFunc + @"
            out vec4 FragColor;
            uniform vec4 uObjectColor;
    
            in vec3 Normal;
            in vec3 FragPos;

            void main()
            {
                vec3 resultColor = calculatePhongShading(FragPos, Normal, uObjectColor);
                FragColor = vec4(resultColor, uObjectColor.a);
            }";

        // ================================================================
        // Instanced Shader
        // ================================================================
        public static readonly string VertexShaderSourceInstancedAttrib = Version + CameraBlock + InstanceData + @"
            out vec3 vNormal;
            out vec4 vObjectColor;
            out vec3 worldPos;
            void main()
            {
                mat4 model = mat4(instanceModel);
                vNormal = mat3(transpose(inverse(model))) * aNormal;
                vObjectColor = instanceColor;
                worldPos = (model * vec4(aPos, 1.0)).xyz;
                gl_Position = uProjection * uView * vec4(worldPos, 1.0);
            }";

        public static readonly string FragmentShaderSourceInstancedAttrib = Version + @"
            in vec3 vNormal;
            in vec4 vObjectColor;
            in vec3 worldPos;
            out vec4 FragColor;
            void main()
            {
                vec3 uLightColor = vec3(1, 1, 1);
                vec3 ambient = vec3(0.5,0.5,0.5);
                vec3 norm = normalize(vNormal);
                vec3 lightDir = vec3(0, -1, -1);
                float diff = max(dot(norm, lightDir), 0.0);
                vec3 diffuse = diff * uLightColor;

                vec3 result = ambient + diffuse;
                vec3 finalColor = result * vObjectColor.rgb;
                FragColor = vec4(finalColor, vObjectColor.a);
            }";

        // ================================================================
        // Forward Rendering
        // ================================================================
        public const string forwardVtx = Version + Defines + CameraBlock + InstanceData + @"
            uniform int shadeMode;

            out vec3 FragPos;
            out vec3 Normal;
            out vec4 vObjectColor;
            flat out int vsLayer;

            void main()
            {
                mat4 model = mat4(instanceModel);
                gl_Position = uProjection * uView * model * vec4(aPos, 1.0);
                FragPos = (model * vec4(aPos, 1.0)).xyz;
                Normal = mat3(transpose(inverse(model))) * aNormal;

                vsLayer = geoLayer;
                vObjectColor = instanceColor;

                if(selectMode == 99) vObjectColor.a = 0;
            }";

        public const string forwardFrg = Version + Defines + LightingFunc + @"
            out vec4 FragColor;

            in vec3 FragPos;
            in vec3 Normal;
            in vec4 vObjectColor;
            flat in int vsLayer;

            void main()
            {
                if (vsLayer < HIDDEN_LAYER) {
                    discard;
                }
                vec3 resultColor = calculatePhongShading(FragPos, Normal, vObjectColor);
                FragColor = vec4(resultColor, vObjectColor.a);
            }";

        // ================================================================
        // Background
        // ================================================================
        public const string backgroundVertexGlsl = @"
            #version 440 core
            layout(location = 0) in vec2 aPos;
            layout(location = 1) in vec2 aTexCoord;

            out vec2 TexCoord;

            void main()
            {
                gl_Position = vec4(aPos, 0.0, 1.0);
                TexCoord = aTexCoord;
            }
        ";

        public const string backgroundFragmentGlsl = @"
            #version 440 core
            in vec2 TexCoord;
            out vec4 FragColor;
            uniform sampler2D infoTexture;
            uniform vec2 iResolution;

            void main()
            {
                vec3 infogetLogo = mix(vec3(0.0, 0.0, 1.0), vec3(0.95, 0.95, 1.0), TexCoord.y + 0.6);
                vec2 logoSize = vec2(150.0, 51); 
                vec2 screenUV = TexCoord * iResolution;
                vec2 logoPos = vec2(iResolution.x - logoSize.x - 16.0, 16.0);

                vec2 localPos = screenUV - logoPos;
                bool inLogoRegion = all(greaterThanEqual(localPos, vec2(0.0))) &&
                                    all(lessThan(localPos, logoSize));

                vec4 result = vec4(infogetLogo, 1.0);
                if (inLogoRegion)
                {
                    vec2 logoUV = localPos / logoSize;
                    vec4 logo = texture(infoTexture, logoUV);
                    result = mix(result, logo, logo.a);
                }
                FragColor = result;
            }
        ";
    }
}
