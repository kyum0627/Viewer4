using IGX.Geometry.Common;
using IGX.Geometry.ConvexHull;
using IGX.Geometry.GeometryBuilder;
using OpenTK.Graphics.OpenGL4;
using OpenTK.Mathematics;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using static g3.ThreeMFReader;

namespace IGX.Geometry.DataStructure
{
    public enum SelectTo
    {
        None = 0,
        ColorChange = 1,
        Transparent = 2,
        LayerChange = 3,
        Measure = 4,
        Hide = 99
    }

    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public class VertexAttribute : Attribute
    {
        public int Location { get; set; }
        public int Size { get; set; }
        public All Type { get; set; } = All.Float;
        public bool Normalized { get; set; } = false;
        public int Divisor { get; }
    }
    public class GeometryInstance : IEquatable<GeometryInstance>
    {
        public Matrix4 Model { get; set; } = Matrix4.Identity;// scale, rotation, translation
        public Vector4 Color { get; set; }
        public SelectTo SelectionMode { get; set; } = SelectTo.None;
        public int EassemblyID { get; set; }
        public int GeometryID { get; set; }
        public int MeshID { get; set; }
        public ParaPrimType GeomType { get; set; }  // 12가지 유형 중 하나, 실린더, 박스, 구, ....
        public int Layer { get; set; }
        public static int SizeInBytes => Marshal.SizeOf(typeof(GeometryInstance));

        public bool Equals(GeometryInstance? other)
        {
            if (GeometryID != other!.GeometryID
                && EassemblyID != other.EassemblyID
                && GeomType != other.GeomType
                && Model != other.Model) return false;
            return true;
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct MatColInstance
    {
        [VertexAttribute(Location =  2, Size = 16)] public Matrix4 Model;
        [VertexAttribute(Location =  6, Size =  4)] public Vector4 Color;
        public static int SizeInBytes => Marshal.SizeOf(typeof(MatColInstance));
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct MeshInstanceGL
    {
        [VertexAttribute(Location =  2, Size =16)] public Matrix4 Model;
        [VertexAttribute(Location =  6, Size = 4)] public Vector4 Color;
        [VertexAttribute(Location =  7, Size = 1)] public int SelectionMode;
        [VertexAttribute(Location =  8, Size = 1, Type = All.Int)] public int EassemblyID;
        [VertexAttribute(Location =  9, Size = 1, Type = All.Int)] public int MeshId;
        [VertexAttribute(Location = 10, Size = 1, Type = All.Int)] public ParaPrimType GeomType;
        [VertexAttribute(Location = 11, Size = 1, Type = All.Int)] public int Layer;

        public static int SizeInBytes => Marshal.SizeOf(typeof(MeshInstanceGL));

        public MeshInstanceGL(GeometryInstance instanceData, string grandType)
        {
            EassemblyID = instanceData.EassemblyID;
            MeshId = instanceData.GeometryID;
            GeomType = instanceData.GeomType;
            if (grandType == "INSU")
            {
                Layer = 2;
            }
            else if (grandType == "OBST")
            {
                Layer = 3;
            }
            else
            {
                Layer = 1;
            }
            if (GeomType != ParaPrimType.FacetVolume)
            {
                Model.Row0 = Vector4.UnitX;
                Model.Row1 = Vector4.UnitY;
                Model.Row2 = Vector4.UnitZ;
                Model.Row3 = Vector4.UnitW;
            }
            else
            {
                Model = instanceData.Model;
            }
            Color = instanceData.Color; // 이미 Build 메서드에서 설정됨
            instanceData.SelectionMode = 0;
            SelectionMode = (int)instanceData.SelectionMode; // 그려라
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 16)]
    public struct SSBOInstanceElement
    {
        public int assemblyID;
        public int MeshId;
        public ParaPrimType PrimitiveType;
        public int geoLayer;
        public Matrix4 model;
        public Vector4 Color;
        public Vector3 AabbMin;
        public Vector3 AabbMax;
        public Vector2 _padding;
        public static int SizeInBytes => Marshal.SizeOf(typeof(SSBOInstanceElement));

        public void MakeInstanceBufferData(GeometryInstance instanceData)
        {
            assemblyID = instanceData.EassemblyID;
            MeshId = instanceData.GeometryID;
            PrimitiveType = instanceData.GeomType;
            geoLayer = 1;// if 0, do not draw
            if (PrimitiveType != ParaPrimType.FacetVolume)
            { // 각 vertex에 회전 및 이동 행렬 값이 이미 적용되어 있음. SSBO를 사용해서 인스턴싱하게 되면 고쳐야 함
                model = Matrix4.Identity;
            }
            else
            {
                model = instanceData.Model;
            }
            Color = instanceData.Color; // 이미 Build 메서드에서 설정됨
            //AabbMin = Aabb.min;
            //AabbMax = Aabb.max;
        }
        public readonly bool Equals(SSBOInstanceElement other)
        {
            return assemblyID == other.assemblyID && MeshId == other.MeshId && PrimitiveType == other.PrimitiveType
                && Color == other.Color
                && AabbMin == other.AabbMin && AabbMax == other.AabbMax;
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct Vertex : IEquatable<Vertex>
    {
        [VertexAttribute(Location = 0, Size = 3)] public Vector3 Position;
        [VertexAttribute(Location = 1, Size = 3)] public Vector3 Normal;
        public Vertex(Vector3 position, Vector3 normal)
        {
            Position = position;
            Normal = normal;
        }
        public static readonly int SizeInBytes = Marshal.SizeOf<Vertex>();
        public override readonly String ToString()
        {
            return Position.ToString() + "  " + Normal.ToString() + "\n";
        }
        public readonly float[] ToArray => new float[] { Position[0], Position[1], Position[2], Normal[0], Normal[1], Normal[2] };
        public bool Equals(Vertex other)
        {
            // Position과 Normal을 오차 범위 내에서 비교
            return Position.Equals(other.Position) &&
                   Normal.Equals(other.Normal);
        }
        public readonly bool Equals(Vertex? other, bool compareNormal = true)
        {// 비교할 때, Position만 비교할지, Position과 Normal을 비교할지 선택할 수 있도록 수정
            if (other == null)
            {
                return false;
            }

            return compareNormal ? Position == other.Value.Position && Normal == other.Value.Normal : Position == other.Value.Position;
        }

        public override readonly int GetHashCode()
        {// 기본적으로 Position과 Normal을 기반으로 해시값을 생성
            return GetHashCode(true);
        }
        public readonly int GetHashCode(bool compareNormal = true)
        {// 비교 기준에 따라 GetHashCode를 다르게 계산
            return compareNormal ? HashCode.Combine(Position, Normal) : Position.GetHashCode();
        }
    }
    public struct VertexAttributeData
    {
        public string FieldName { get; init; }
        public int Location { get; init; }
        public int Size { get; init; }
        public All GLType { get; init; }
        public bool Normalized { get; init; }
        public int Offset { get; init; }
        public int Divisor { get; init; }
        public bool IsMatrix4 { get; init; }
    }
    public class VertexListComparer : IEqualityComparer<List<Vertex>>
    {
        public bool Equals(List<Vertex> x, List<Vertex> y)
        {
            if (x == y) return true;
            if (x == null || y == null) return false;
            if (x.Count != y.Count) return false;

            // 리스트 내의 모든 Vertex를 순서대로 비교
            for (int i = 0; i < x.Count; i++)
            {
                // Vertex 객체의 동등성을 직접 비교 (예: 좌표 등)
                if (!x[i].Equals(y[i]))
                {
                    return false;
                }
            }
            return true;
        }

        public int GetHashCode(List<Vertex> obj)
        {
            // 모든 Vertex의 해시 코드를 조합하여 하나의 해시 코드 생성
            unchecked // 오버플로를 무시
            {
                int hash = 19;
                foreach (var vertex in obj)
                {
                    hash = hash * 31 + vertex.GetHashCode();
                }
                return hash;
            }
        }
    }
}
