using IGX.ViewControl.Buffer;
using IGX.ViewControl.Buffer.Common;
using OpenTK.Graphics.OpenGL4;
using System;

namespace IGX.ViewControl.Render
{
    public class ElementBuffer<TVertex, TIndex> : IDisposable
        where TVertex : struct where TIndex : struct
    {
        private readonly int _vao;
        private readonly VertexBuffer<TVertex> _vbo;
        private readonly IndexBuffer<TIndex> _ebo;
        private bool _isDisposed = false;
        public int VAO => _vao;
        public int IndexCount => _ebo.Count;
        public int VertexCount => _vbo.Count;
        public DrawElementsType ElementType => _ebo.GetDrawElementsType();

        private readonly object _vaoLock = new();

        public ElementBuffer(
            ReadOnlySpan<TVertex> vertices,
            ReadOnlySpan<TIndex> indices,
            BufferUsageHint vertexHint = BufferUsageHint.DynamicDraw,
            BufferUsageHint indexHint = BufferUsageHint.DynamicDraw)
        {
            if (vertices.IsEmpty) throw new ArgumentException("Vertex data cannot be empty.", nameof(vertices));
            if (indices.IsEmpty) throw new ArgumentException("Index data cannot be empty.", nameof(indices));

            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot create ElementBuffer without an active OpenGL context.");
            }

            try
            {
                _vao = GL.GenVertexArray();
                lock (_vaoLock)
                {
                    GL.BindVertexArray(_vao);
                }

                _vbo = new VertexBuffer<TVertex>(vertices.ToArray(), vertexHint, BufferTarget.ArrayBuffer);
                _vbo.SetAttributes();
                _ebo = new IndexBuffer<TIndex>(indices.ToArray(), indexHint, keepCpuData: true);
                _ebo.Bind();

                lock (_vaoLock)
                {
                    GL.BindVertexArray(0);
                }

                CheckGLError();
            }
            catch (Exception ex)
            {
                if (_vao != 0)
                {
                    GLResourceManager.EnqueueForDeletion(_vao);
                }
                throw new InvalidOperationException("Failed to initialize ElementBuffer.", ex);
            }
        }

        public void UpdateSingleVertex(int vertexIndex, TVertex newVertexData)
        {
            if (_isDisposed) throw new ObjectDisposedException(nameof(ElementBuffer<TVertex, TIndex>));
            _vbo.UpdateInstance(vertexIndex, newVertexData);
        }

        public void UpdateVertices(int startIndex, ReadOnlySpan<TVertex> newVertexData)
        {
            if (_isDisposed) throw new ObjectDisposedException(nameof(ElementBuffer<TVertex, TIndex>));
            _vbo.UpdateVertices(startIndex, newVertexData);
        }
        public void UpdateIndices(int startIndex, ReadOnlySpan<TIndex> indices)
        {
            if (_isDisposed) throw new ObjectDisposedException(nameof(ElementBuffer<TVertex, TIndex>));
            _ebo.UpdateIndices(startIndex, indices);
        }
        public void Draw(PrimitiveType primitiveType)
        {
            if (_isDisposed) throw new ObjectDisposedException(nameof(ElementBuffer<TVertex, TIndex>));
            lock (_vaoLock)
            {
                //Bind();
                _ebo.Draw(primitiveType);
                //Unbind();
            }
        }

        public void Draw(PrimitiveType primitiveType, int offset, int count)
        {
            if (_isDisposed) throw new ObjectDisposedException(nameof(ElementBuffer<TVertex, TIndex>));
            lock (_vaoLock)
            {
                //Bind();
                _ebo.Draw(primitiveType, offset, count);
                //Unbind();
            }
        }

        public void Bind()
        {
            if (_isDisposed) throw new ObjectDisposedException(nameof(ElementBuffer<TVertex, TIndex>));
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot bind VAO without an active OpenGL context.");
            }
            GL.BindVertexArray(_vao);
        }

        public void Unbind()
        {
            GL.BindVertexArray(0);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_isDisposed) return;

            if (disposing)
            {
                _vbo.Dispose();
                _ebo.Dispose();
            }

            if (IsContextLikelyActive() && GL.IsVertexArray(_vao))
            {
                GLResourceManager.EnqueueForDeletion(_vao);
            }
            else if (!IsContextLikelyActive())
            {
                Console.WriteLine("Warning: Cannot enqueue VAO deletion due to inactive OpenGL context.");
            }

            _isDisposed = true;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        ~ElementBuffer()
        {
            Dispose(false);
        }

        private static bool IsContextLikelyActive()
        {
            try
            {
                GL.GetError();
                return true;
            }
            catch
            {
                return false;
            }
        }

        private static void CheckGLError()
        {
            var error = GL.GetError();
            if (error != ErrorCode.NoError)
            {
                throw new InvalidOperationException($"OpenGL error: {error}");
            }
        }
    }
}