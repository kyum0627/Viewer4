using OpenTK.Mathematics;
using IGX.Geometry.Common;

namespace IGX.Geometry.Intersect
{
    public class IntersectTriangle3Plane3
    {
        public struct Result
        {
            public bool intersect;
            public int numIntersections;
            public bool isInterior;
            public Vector3[] point;
        }

        public Result Test(Plane3f plane, Triangle3f triangle)
        {
            // plane기준 점의 상대적인 위치를 count하면 교차 유형을 알 수 있음
            //   nID pID z  intersection
            //   ------------------------------------
            //   0 3 0  none
            //   0 2 1  vertex
            //   0 1 2  hedge
            //   0 0 3  triangle in the plane
            //   1 2 0  default_nsegs (2 halfedgeSet clipped)
            //   1 1 1  default_nsegs (1 hedge clipped)
            //   1 0 2  hedge
            //   2 1 0  default_nsegs (2 halfedgeSet clipped)
            //   2 0 1  vertex
            //   3 0 0  none

            Result result = new();
            float[] s = new float[3];
            int numPositive = 0, numNegative = 0, numZero = 0;
            for (int i = 0; i < 3; ++i)
            {
                s[i] = Vector3.Dot(plane.normal, triangle[i]) - plane.constant;
                if (s[i] > 0f)
                {
                    ++numPositive;
                }
                else if (s[i] < 0f)
                {
                    ++numNegative;
                }
                else
                {
                    ++numZero;
                }
            }

            if (numZero == 0 && numPositive > 0 && numNegative > 0)
            {
                result.intersect = true;
                result.numIntersections = 2;
                result.isInterior = true;
                return result;
            }

            if (numZero == 1)
            {
                result.intersect = true;
                for (int i = 0; i < 3; ++i)
                {
                    if (s[i] == 0f)
                    {
                        if (numPositive == 2 || numNegative == 2)
                        {
                            result.numIntersections = 1;
                        }
                        else
                        {
                            result.numIntersections = 2;
                            result.isInterior = true;
                        }
                        break;
                    }
                }
                return result;
            }
            if (numZero == 2)
            {
                result.intersect = true;
                result.numIntersections = 2;
                result.isInterior = false;
                return result;
            }

            if (numZero == 3)
            {
                result.intersect = true;
                result.numIntersections = 3;
            }
            else
            {
                result.intersect = false;
                result.numIntersections = 0;
            }
            return result;
        }

        public Result Compute(Plane3f plane, Triangle3f triangle)
        {
            // plane기준 점의 상대적인 위치를 count하면 교차 유형을 알 수 있음
            //   nID pID z  intersection
            //   ------------------------------------
            //   0 3 0  none
            //   0 2 1  vertex
            //   0 1 2  hedge
            //   0 0 3  triangle in the plane
            //   1 2 0  default_nsegs (2 halfedgeSet clipped)
            //   1 1 1  default_nsegs (1 hedge clipped)
            //   1 0 2  hedge
            //   2 1 0  default_nsegs (2 halfedgeSet clipped)
            //   2 0 1  vertex
            //   3 0 0  none

            Result result = new();
            float[] s = new float[3];
            int numPositive = 0, numNegative = 0, numZero = 0;

            for (int i = 0; i < 3; ++i)
            {
                s[i] = Vector3.Dot(plane.normal, triangle[i]) - plane.constant;
                if (s[i] > 0f)
                {
                    ++numPositive;
                }
                else if (s[i] < 0f)
                {
                    ++numNegative;
                }
                else
                {
                    ++numZero;
                }
            }

            if (numZero == 0 && numPositive > 0 && numNegative > 0)
            {
                result.intersect = true;
                result.numIntersections = 2;
                result.isInterior = true;
                float sign = 3f - (numPositive * 2f);
                for (int i0 = 0; i0 < 3; ++i0)
                {
                    if (sign * s[i0] > 0f)
                    {
                        int i1 = (i0 + 1) % 3, i2 = (i0 + 2) % 3;
                        float t1 = s[i1] / (s[i1] - s[i0]);
                        float t2 = s[i2] / (s[i2] - s[i0]);
                        result.point = new Vector3[2];
                        result.point[0] = triangle[i1] + (t1 * (triangle[i0] - triangle[i1]));
                        result.point[1] = triangle[i2] + (t2 * (triangle[i0] - triangle[i2]));
                        break;
                    }
                }
                return result;
            }

            if (numZero == 1)
            {
                result.intersect = true;
                for (int i0 = 0; i0 < 3; ++i0)
                {
                    if (s[i0] == 0f)
                    {
                        int i1 = (i0 + 1) % 3, i2 = (i0 + 2) % 3;
                        if (numPositive == 2 || numNegative == 2)
                        {
                            result.numIntersections = 1;
                            result.point = new Vector3[1];
                            result.point[0] = triangle[i0];
                        }
                        else
                        {
                            result.numIntersections = 2;
                            result.isInterior = true;
                            float t = s[i1] / (s[i1] - s[i2]);
                            result.point = new Vector3[2];
                            result.point[0] = triangle[i0];
                            result.point[1] = triangle[i1] + (t * (triangle[i2] - triangle[i1]));
                        }
                        break;
                    }
                }
                return result;
            }

            if (numZero == 2)
            {
                result.intersect = true;
                result.numIntersections = 2;
                result.isInterior = false;
                for (int i0 = 0; i0 < 3; ++i0)
                {
                    if (s[i0] != 0f)
                    {
                        int i1 = (i0 + 1) % 3, i2 = (i0 + 2) % 3;
                        result.point = new Vector3[2];
                        result.point[0] = triangle[i1];
                        result.point[1] = triangle[i2];
                        break;
                    }
                }
                return result;
            }

            if (numZero == 3)
            {
                result.intersect = true;
                result.numIntersections = 3;
                result.point = new Vector3[3];
                result.point[0] = triangle[0];
                result.point[1] = triangle[1];
                result.point[2] = triangle[2];
            }
            else
            {
                result.intersect = false;
                result.numIntersections = 0;
            }
            return result;
        }
    }
}
