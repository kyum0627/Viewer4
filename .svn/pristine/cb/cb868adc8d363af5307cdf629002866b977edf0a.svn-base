using System;
using System.Collections.Generic;
using OpenTK.Mathematics;
using System.Linq;
using IGX.Geometry.Common;

namespace IGX.Geometry.ConvexHull
{
    /// <summary>
    /// Object Oriented Bounding Box, 즉, Object의 local coordinate 기준 사각형
    /// </summary>
    public struct OOBB2 : IEquatable<OOBB2>
    {
        public Vector2 axisX;
        public Vector2 axisY;
        public Vector2 center;
        public Vector2 extent;

        //public float area;

        public static OOBB2 Empty = new(float.NaN);

        public OOBB2(float f)
        { // 중심이 (0,0,0) 박스 크기가 f 인 기본 박스 생성 
            center = Vector2.Zero;
            axisX = Vector2.UnitX; // default : global axis X
            axisY = Vector2.UnitY; // default : global axis Y
            extent = new Vector2(f, f);
            //area = f * f;
        }
        ///// <summary>
        ///// global coordinate 기준 zero size 박스
        ///// </summary>
        ///// <param name="center"></param>
        //public OOBB2(Vector2 center)
        //{
        //    this.center = center;
        //    axisX = Vector2.UnitX;
        //    axisY = Vector2.UnitY;
        //    extent = Vector2.Zero;
        //    area = 0;
        //    //index = new int[4];
        //}
        public float Area
        {
            get { return 2 * extent.X * 2 * extent.Y; }
            //set { area = value; }
        }

        public Vector2 Diagonal
        {
            get
            {
                return (extent.X * axisX) + (extent.Y * axisY) - ((-extent.X * axisX) - (extent.Y * axisY));
            }
        }

        public float MaxExtent
        {
            get { return Math.Max(extent.X, extent.Y); }
        }
        public float MinExtent
        {
            get { return Math.Min(extent.X, extent.Y); }
        }

        /// <summary>
        /// local 좌표 축
        /// </summary>
        /// <param name="i">0: x, 1:y, 2:z</param>
        /// <returns>i방향의 좌표축</returns>
        readonly public Vector2 Axis(int i)
        {
            return i == 0 ? axisX : axisY;
        }
        public void GetMinimumBox(Vector2[] points)
        {
            Vector2[] mPoints = ConvexHull2.Compute(new List<Vector2>(points)).ToArray();

            // ApprGaussian2 클래스 인스턴스 생성
            ApprGaussian2 apprGaussian2 = new();

            // Convex Hull 포인트를 사용하여 OOBB2 계산
            apprGaussian2.Fit(mPoints);
        }

        public void ComputeVertices(ref Vector2[] vertex)
        {
            Vector2 extAxis0 = extent.X * axisY;
            Vector2 extAxis1 = extent.Y * axisY;
            vertex[0] = center - extAxis0 - extAxis1;
            vertex[1] = center + extAxis0 - extAxis1;
            vertex[2] = center + extAxis0 + extAxis1;
            vertex[3] = center - extAxis0 + extAxis1;
        }

        /// <summary>
        /// OO박스가 v를 포함하도록 확장
        /// </summary>
        /// <param name="v"></param>
        public void Contain(Vector2 v)
        {
            Vector2 df = v - center;

            for (int k = 0; k < 2; ++k)
            {
                float t = Vector2.Dot(df, Axis(k));

                if (Math.Abs(t) > extent[k])
                {
                    float min = -extent[k];
                    float max = extent[k];

                    if (t < min)
                    {
                        min = t;
                    }
                    else if (t > max)
                    {
                        max = t;
                    }

                    extent[k] = (max - min) * 0.5f;
                    center += (max + min) * 0.5f * Axis(k);
                }
            }
        }

        /// <summary>
        /// OO 박스가 other OO Box를 포함하도록 확장
        /// </summary>
        /// <param name="other"></param>
        public void Contain(OOBB2 other)
        {
            Vector2[] v = other.Vertices();

            for (int k = 0; k < 4; ++k)
            {
                Contain(v[k]);
            }
        }

        /// <summary>
        /// Box 가 V를 포함하는지 검사
        /// </summary>
        /// <param name="v">검사할 점</param>
        /// <returns>포함하면 true</returns>
        public bool Contains(Vector2 v)
        {
            Vector2 df = v - center;

            return Math.Abs(Vector2.Dot(df, axisX)) <= extent.X &&
                    Math.Abs(Vector2.Dot(df, axisY)) <= extent.Y;
        }

        /// <summary>
        /// box 와 v 간 최단 거리
        /// </summary>
        /// <param name="v">거리를 계산할 점</param>
        /// <returns>거리</returns>
        public Vector2 ClosestPoint(Vector2 v)
        {
            Vector2 diff = v - center;

            float dist2 = 0;
            float delta;
            Vector2 closest = new();
            for (int i = 0; i < 2; ++i)
            {
                closest[i] = Vector2.Dot(diff, i == 0 ? axisX : axisY);
                float extent = i == 0 ? this.extent.X : this.extent.Y;

                if (closest[i] < -extent)
                {
                    delta = closest[i] + extent;
                    dist2 += delta * delta;
                    closest[i] = -extent;
                }
                else if (closest[i] > extent)
                {
                    delta = closest[i] - extent;
                    dist2 += delta * delta;
                    closest[i] = extent;
                }
            }
            return center + (closest.X * axisX) + (closest.Y * axisY);
        }

        /// <summary>
        /// box ~ v 까지 가리의 제곱
        /// </summary>
        /// <param name="v"></param>
        /// <returns></returns>
        public float DistanceSquared(Vector2 v)
        {
            v -= center;

            float dist2 = 0;
            float delta, c, extent;

            for (int i = 0; i < 2; ++i)
            {
                if (i == 0)
                {
                    c = Vector2.Dot(v, axisX);
                    extent = this.extent.X;
                }
                else
                {
                    c = Vector2.Dot(v, axisY);
                    extent = this.extent.Y;
                }
                if (c < -extent)
                {
                    delta = c + extent;
                    dist2 += delta * delta;
                }
                else if (c > extent)
                {
                    delta = c - extent;
                    dist2 += delta * delta;
                }
            }

            return dist2;
        }
        public bool HasApproximatedOOBB(int numPoints, List<Vector2> points, ref OOBB2 box)
        {
            ApprGaussian2 fitter = new();
            fitter.Fit(points.ToArray());

            if (fitter.GetShape() == ShapeType.Dimension2)
            {
                OOBB2 box2 = fitter.GetParameters();

                // LINQ를 사용하여 각 점에 대한 투영 계산
                List<Vector2> projections = points.Select(point =>
                    new Vector2(
                        Vector2.Dot(point - box2.center, box2.Axis(0)),
                        Vector2.Dot(point - box2.center, box2.Axis(1))
                    )
                ).ToList();

                // pmin과 pmax를 LINQ로 계산
                Vector2 pmin = new(projections.Min(p => p.X), projections.Min(p => p.Y));
                Vector2 pmax = new(projections.Max(p => p.X), projections.Max(p => p.Y));

                // 중심과 extents 갱신
                box2.center = box2.center + (0.5f * (pmin + pmax).X * box2.Axis(0)) + (0.5f * (pmin + pmax).Y * box2.Axis(1));
                box2.extent = new Vector2(0.5f * (pmax.X - pmin.X), 0.5f * (pmax.Y - pmin.Y));
                box = box2;
                return true;
            }

            return false;
        }

        /// <summary>
        /// box0와 box1을 병합
        /// </summary>
        /// <param name="box0"></param>
        /// <param name="box1"></param>
        /// <returns>병합한 OOBB2</returns>
        public static OOBB2 Merge(ref OOBB2 box0, ref OOBB2 box1)
        {
            OOBB2 box = new()
            {
                center = 0.5f * (box0.center + box1.center)
            };

            // 축 방향 결합
            box.axisX = Vector2.Dot(box0.axisX, box1.axisX) >= 0
                ? Vector2.Normalize(0.5f * (box0.axisX + box1.axisX))
                : Vector2.Normalize(0.5f * (box0.axisX - box1.axisX));
            box.axisY = -box.axisX.Perp();

            // LINQ를 활용하여 경계 계산
            Vector2 pmin = Vector2.Zero;
            Vector2 pmax = Vector2.Zero;

            // 경계를 업데이트하는 함수
            void UpdateBounds(OOBB2 boxToUpdate)
            {
                Vector2fTuple4 vertex = new();
                boxToUpdate.Vertices(ref vertex);

                IEnumerable<float[]> projections = vertex.ToBuffer().Select(v =>
                {// 각 정점에 대한 투영을 계산하고 min/max를 LINQ로 구하기
                    Vector2 diff = v - box.center;
                    return new[] { Vector2.Dot(diff, box.axisX), Vector2.Dot(diff, box.axisY) };
                });

                float projMin = projections.SelectMany(p => p).Min();
                float projMax = projections.SelectMany(p => p).Max();

                pmin = new Vector2(Math.Min(pmin.X, projMin), Math.Min(pmin.Y, projMin));
                pmax = new Vector2(Math.Max(pmax.X, projMax), Math.Max(pmax.Y, projMax));
            }

            // box0와 box1의 경계를 계산하여 pmin, pmax 갱신
            UpdateBounds(box0);
            UpdateBounds(box1);

            // 확장 크기와 중심 계산
            box.extent = 0.5f * (pmax - pmin);
            box.center += (box.axisX * (0.5f * (pmax.X + pmin.X))) + (box.axisY * (0.5f * (pmax.Y + pmin.Y)));

            return box;
        }

        public void Translate(Vector2 v)
        {
            center += v;
        }

        public Vector2[] Vertices()
        {
            Vector2[] v = new Vector2[4];
            Vertices(ref v);
            return v;
        }

        public void Vertices(ref Vector2[] vertex)
        {
            Vector2 extAxis0 = extent.X * axisX;
            Vector2 extAxis1 = extent.Y * axisY;

            vertex[0] = center - extAxis0 - extAxis1; // left bottom
            vertex[1] = center + extAxis0 - extAxis1; // right bottom
            vertex[2] = center + extAxis0 + extAxis1; // right top
            vertex[3] = center - extAxis0 + extAxis1; // left top
        }

        public void Vertices(ref Vector2fTuple4 vertex)
        {
            Vector2 extAxis0 = extent.X * axisX;
            Vector2 extAxis1 = extent.Y * axisY;

            vertex[0] = center - extAxis0 - extAxis1; // left bottom
            vertex[1] = center + extAxis0 - extAxis1; // right bottom
            vertex[2] = center + extAxis0 + extAxis1; // right top
            vertex[3] = center - extAxis0 + extAxis1; // left top
        }

        // IEquatable<OOBB2> 인터페이스 구현
        public bool Equals(OOBB2 other)
        {
            return center == other.center && axisX == other.axisX && axisY == other.axisY && extent == other.extent;
        }

        // object 타입의 Equals 메서드 재정의
        public override bool Equals(object? obj)
        {
            return (obj is OOBB2 other) && Equals(other);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hash = (int)2166136261;
                hash = (hash * 16777619) ^ center.GetHashCode();
                hash = (hash * 16777619) ^ axisX.GetHashCode();
                hash = (hash * 16777619) ^ axisY.GetHashCode();
                hash = (hash * 16777619) ^ extent.GetHashCode();
                return hash;
            }
        }

        public static bool operator ==(OOBB2 a, OOBB2 b)
        {
            return a.center == b.center
                && a.axisX == b.axisX
                && a.axisY == b.axisY
                && a.extent == b.extent;
        }

        public static bool operator !=(OOBB2 a, OOBB2 b)
        {
            return !(a == b);
        }
    }
}