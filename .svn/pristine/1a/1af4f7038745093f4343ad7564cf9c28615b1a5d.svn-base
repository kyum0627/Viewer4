using OpenTK.Mathematics;
using IGX.Geometry.Common;
using IGX.Geometry.DataStructure;
using IGX.Geometry.GeometryBuilder;
using IGX.Geometry.ConvexHull;
using IGX.Geometry.Tessellation;
using System.Linq;
using System.Diagnostics;

namespace IGX.Loader.AMFileLoader
{
    public class RevLoader : ModelLoader
    {
        private static int textlines = 0;
        private static List<string> stream = [];// List<string>();
        private readonly Stack<int> parentStack = new();// Stack<int>(); // 클래스 멤버로 이동
        private readonly TessellationManager tessellationManager = new();

        public RevLoader(string filename)
        {
            textlines = 0;
            Header.Name = filename;
            OpenStream(filename);
            parentStack.Clear(); // 파일 로드 시 스택 초기화
            Parse();
            stream.Clear();
        }
        private static void OpenStream(string fileName)
        {
            string fileContent = File.ReadAllText(fileName);
            stream = [.. fileContent.Split([Environment.NewLine], StringSplitOptions.None)];
        }
        private void Parse()
        {
            string chunkType = "";
            const int parent = -1; // 최상위 root node
            parentStack.Push(parent); // 초기 부모 ID 푸시
            do
            {
                chunkType = ProcessByChunk(parent);
            } while (chunkType != "END:" && chunkType != "EOF");
            progress.Add("Rev 읽기 완료\nID");
        }
        private string ProcessByChunk(int parent)
        {
            string datagroup = ReadChunkID(out uint kind, out uint version);
            Dictionary<string, Action<int>> ChunkFuncMap = new()
            {
                { "HEAD", _ => Header = ChunkHEAD() }, // file header
                { "MODL", _ =>
                    {
                        (Header.project, Header.Name) = ChunkMODL();
                        if (Header.project == "CNTB")
                        {
                            Header.project = "";
                            Header.Name = "";
                            textlines--;
                        }
                    }
                }, // model 시작
                { "CNTB", parent => ChunkCNTB(parent) }, // 변경된 ChunkCNTB 호출
                { "COLR", _ =>
                    {
                        VolColor c = ChunkCOLR();
                        if(!colors.TryGetValue(c.ColorKey, out VolColor? vc))
                        {
                            colors[c.ColorKey] = c;
                        }
                    }
                },//kind) }, // 모델에서 사용하고 있는 Color Table
                { "CNTE", _ => { if (parentStack.Count > 0) { parentStack.Pop(); } } }, // CNTE에서 스택에서 부모 ID를 꺼냄
                { "END:", _ => {} } // End of file or unnecessary data
            };

            if (ChunkFuncMap.TryGetValue(datagroup, out Action<int>? value))
            {
                value(parent);
            }
            if (textlines >= stream.Count - 1)
            {
                datagroup = "END:";
            }

            return datagroup;
        }
        private static string ReadChunkID(out uint nextheaderposition, out uint unknown)
        {
            if (textlines >= stream.Count)
            { // 무한 루프 방지
                return VeriftChunk(out nextheaderposition, out unknown);
            }
            string code = stream[textlines++]!;
            (nextheaderposition, unknown) = Parse2Uints();
            return GetChunkID(code);
            // ----
            static string VeriftChunk(out uint nextheaderposition, out uint unknown)
            {
                nextheaderposition = 1;
                unknown = 1;
                return "EOF";
            }
        }
        private static string GetChunkID(string code)
        {
            if (code.Length < 4)
            {// 길이가 4보다 작은 경우, 그 자체로 반환
                return code.PadRight(4, ' ');  // 최소 길이 4로 맞추기
            }
            return code[..4]; // 길이가 4 이상일 경우 첫 4자만 반환
        }
        private static FileInformation ChunkHEAD()
        {
            List<string> lines = GetLines(textlines, 5);  // 5개 줄을 한 번에 읽음
            textlines += 5;  // 텍스트 라인 넘버를 5만큼 증가시킴
            string info = lines[0];     // 첫 번째 줄 (AVEVA Marine HullDesign 등)
            string note = "";
            if (info.StartsWith("AVEVA"))
            { // "AVEVA"로 시작하는 경우, 두 번째 줄을 note로 처리
                note = lines[1];     // TRIBON이면 Skip
            }
            string date = lines[2];     // Mon Sep 21 14:09:44 2020
            string user = lines[3];     // PLM_INFO01 @HHI132948-28
            string encoding = lines[4]; // Unicode UTF-8
            return new FileInformation(info, note, date, user, encoding);
        }
        private static List<string> GetLines(int startIndex, int count)
        {
            return stream.GetRange(startIndex, count);  // stream에서 한 번에 여러 줄을 ...
        }
        private static (string project, string name) ChunkMODL()
        {
            string project = stream[textlines++]!;
            if (project.Length >= 4 && project[..4] == "CNTB")
            {
                return ("CNTB", "CNTB");
            }
            if (textlines < stream.Count)
            {
                string name = stream[textlines++]!;
                return (project, name);
            }
            throw new InvalidOperationException("데이터 파일 오류. 위치 : " + textlines.ToString());
        }
        private static VolColor ChunkCOLR()//uint kind)
        {
            (uint id, byte r, byte g, byte b) = Parse4Bytes();// 1    130    130    130
            return new VolColor(id, r, g, b);
        }
        private IAssembly ChunkCNTB(int parentId)
        {
            parentStack.Push(parentId); // 부모 ID를 스택에 푸시
            IAssembly currentAssy = new Assembly(parentId);
            //Assembly currentAssy = new(parentId); // 새 CNTB 생성, 부모 ID 설정
            string name = stream[textlines++];
            currentAssy.Name = name;
            currentAssy.Translation = ParseVector3();
            currentAssy.Color = Parse1Uint();

            currentAssy.ID = assemblies.Count; // ID를 먼저 할당
            assemblies[currentAssy.ID] = currentAssy; // 모델에 CNTB 추가

            Item? items = PartTypeParserByShipYard.ParseData(name);
            if (items != null)
            {
                currentAssy.Attributes.Add("items.AM_Type", items.AM_Type!);
                currentAssy.Attributes.Add("items.AM_ID", items.AM_ID.ToString()!);
                currentAssy.Attributes.Add("items.ModelType", items.ModelType!);
            }

            while (true)
            {
                string id = ReadChunkID(out uint unknown, out uint version);
                switch (id)
                {
                    case "CNTB":
                        ChunkCNTB(currentAssy.ID); // 자식 CNTB 호출 시 현재 어셈블리의 ID를 부모 ID로 전달
                        break;
                    case "PRIM":
                    case "OBST":
                    case "INSU":
                        PrimitiveBase? volume = ReadPRIMChunk(currentAssy.ID, currentAssy.Color, id, id != "PRIM");
                        if (volume != null)
                        {
                            currentAssy.AddGeometry(volume);//.GeometryID);
                                                            //(Volume.Mesh.Points, Volume.Mesh.Normals, Volume.Mesh.Indices, Volume.Mesh.edge_inds) =
                            TessellationManager.tessellateFunctionMap[volume.InstanceData.GeomType].Invoke(volume, TessellationUtility.default_nsegs, true, true);
                            geometries[volume.InstanceData.GeometryID] = volume;
                            currentAssy.AssemblyAABB.Contain(volume.Aabb);// InstanceData.Aabb);
                            if (!(currentAssy.ParentBomID == -1 || !assemblies.ContainsKey(currentAssy.ParentBomID))) // ParentID가 유효한 경우에만 접근
                            {
                                assemblies[currentAssy.ParentBomID].AssemblyAABB.Contain(volume.Aabb);
                            }
                        }
                        break;
                    case "CNTE":
                        if (!(currentAssy.ParentBomID == -1 || !assemblies.ContainsKey(currentAssy.ParentBomID))) // ParentID가 유효한 경우에만 접근
                        {
                            assemblies[currentAssy.ParentBomID].AssemblyAABB.Contain(currentAssy.AssemblyAABB);
                            assemblies[currentAssy.ParentBomID].SubEbom.Add(currentAssy.ID);
                        }
                        parentStack.Pop(); // CNTE를 만나면 스택에서 부모 ID를 꺼냄
                        return currentAssy; // CNTE를 만나면 현재 어셈블리 반환
                    default:
                        SkipUntilNotDefined();
                        break;
                }
                if (id == "EOF")
                {
                    break;
                }
            }

            return currentAssy;
        }

        private static void SkipUntilNotDefined()
        {
            string id = "";
            do
            {
                id = ReadChunkID(out uint unknown, out uint version); // 데이터 그룹 이름
            } while (id != "CNTB" && id != "CNTE" && id != "PRIM");
            textlines--;
        }

        #region primitive_chunk

        PrimitiveBase? ReadPRIMChunk(int parent, uint color, string prim_obst_insu, bool hasTransparency = false)
        {
            ParaPrimType prmtyp = (ParaPrimType)Parse1Uint();//11 : GeometryType 읽어 오기
            Matrix4 oripos = Matrix4.Identity;
            oripos = ParseMatrix4(); // 3 lines
            AABB3 aabb = ReadAABB3(); // 2 lines
            //modelBoundingBox.Contain(Aabb);
            SetTransparency(ref color, hasTransparency);
            PrimitiveBase? primitive = null;
            primitive = ParseDataByPrimitiveType(prmtyp, oripos, aabb, primitive);
            if (primitive != null)
            {
                primitive = SetPrimitiveData(parent, color, prim_obst_insu, primitive);
                primitive.InstanceData.Model = oripos;
                primitive.InstanceData.GeomType = prmtyp;
                primitive.InstanceData.Model = oripos;
                primitive.GeometryType = prmtyp;
                if (primitive.GeometryType != ParaPrimType.FacetVolume)
                {
                    (primitive.Aabb, primitive.Oobb) = GeometryFactory.UpdateAabbOobb(oripos, aabb);
                }
            }
            else
            {
                ;
            }
            //modelBoundingBox.Contain(aabb);
            return primitive;
            // ---------
            static void SetTransparency(ref uint color, bool hasTransparency)
            {
                byte w_value; // 투명도
                if (hasTransparency)// OBST 혹은 INSU인 경우
                {
                    w_value = (byte)Parse1Uint(); // 87,
                }
            }
            // -------
            PrimitiveBase SetPrimitiveData(int parent, uint color, string prim_obst_insu, PrimitiveBase primitive)
            {
                primitive.GrandPrimType = prim_obst_insu;
                primitive.InstanceData.EassemblyID = parent;  // 현재 부모 MeshID 설정
                primitive.ColorID = color;
                primitive.InstanceData.GeometryID = geometries.Count;
                return primitive;
            }
            // --------
            static PrimitiveBase? ParseDataByPrimitiveType(ParaPrimType prmtyp, Matrix4 oripos, AABB3 aabb, PrimitiveBase? primitive)
            {
                if (PRIMparseMethods.TryGetValue(prmtyp, out Func<Matrix4, AABB3, PrimitiveBase?>? parseFunc))
                {
                    primitive = parseFunc(oripos, aabb);
                }
                else
                {
                    ;// SkipUntilNotDefined(); // PRIM 내부에서 정의되지 않은 타입은 건너뛸 필요 없을 듯
                }
                return primitive;
            }
        }
        #endregion
        private static readonly Dictionary<ParaPrimType, Func<Matrix4, AABB3, PrimitiveBase?>> PRIMparseMethods = new()
        {
            { ParaPrimType.Pyramid, ReadPyramidRev },
            { ParaPrimType.Box, ReadBoxRev },
            { ParaPrimType.RectangularTorus, ReadRectangularTorusRev },
            { ParaPrimType.CircularTorus, ReadCircularTorusRev },
            { ParaPrimType.EllipticalDish, ReadElipticalDishRev },
            { ParaPrimType.SphericalDish, ReadSphericalDishRev },
            { ParaPrimType.Snout, ReadSnoutRev },
            { ParaPrimType.Cylinder, ReadCylinderRev },
            { ParaPrimType.Sphere, ReadSphereRev },
            { ParaPrimType.Line, ReadVolLineRev },
            { ParaPrimType.FacetVolume, ReadFacetVolumeRev }
        };
        private static Pyramid? ReadPyramidRev(Matrix4 matrix, AABB3 bBoxLocal)
        {// xb, yb, xt, yt, xo, yo, h
            float[] p = ParseFloats(4);
            float[] xo_yo__h = ParseFloats(3);
            List<float> pp = [];
            pp = [.. p];
            pp.AddRange(xo_yo__h);
            return GeometryFactory.BuildPyramid(matrix, bBoxLocal, [.. pp]);
        }
        private static Box? ReadBoxRev(Matrix4 matrix, AABB3 bBoxLocal)
        { // x, y, z
            float[] xyz = ParseFloats(3);
            return GeometryFactory.BuildBox(matrix, bBoxLocal, xyz);
        }
        private static RectangularTorus? ReadRectangularTorusRev(Matrix4 matrix, AABB3 bBoxLocal)
        {// r_in, r_out, h, angle
            float[] ri_ro_h_ang = ParseFloats(4);
            return GeometryFactory.BuildRectangularTorus(matrix, bBoxLocal, ri_ro_h_ang);
        }
        private static CircularTorus? ReadCircularTorusRev(Matrix4 matrix, AABB3 bBoxLocal)
        {// (r_out - r_in) /2, OffsetSurface(r_in), angle
            float[] rorohalf_ri_ang = ParseFloats(3);
            return GeometryFactory.BuildCircularTorus(matrix, bBoxLocal, rorohalf_ri_ang);
        }
        private static EllipticalDish? ReadElipticalDishRev(Matrix4 matrix, AABB3 bBoxLocal)
        { // base_r, h, z_offset, scale_z
            float[] r_h_zoffet_zsacle = ParseFloats(2);
            return GeometryFactory.BuildElipticalDish(matrix, bBoxLocal, r_h_zoffet_zsacle);
        }
        private static SphericalDish? ReadSphericalDishRev(Matrix4 matrix, AABB3 bBoxLocal)
        {// diameter, h,
            float[] d_h = ParseFloats(2);
            return GeometryFactory.BuildSpericalDish(matrix, bBoxLocal, d_h);
        }
        private static Snout? ReadSnoutRev(Matrix4 matrix, AABB3 bBoxLocal)
        { // r_b, r_t, xo, yo, h, xb_s, yb_s, xt_s, yt_s
            float[] rb_rt_xo_yo_h = ParseFloats(5); float[] xbs_ybs_xts_yts = ParseFloats(4);
            return GeometryFactory.BuildSnout(matrix, bBoxLocal, rb_rt_xo_yo_h, xbs_ybs_xts_yts);
        }
        private static Cylinder? ReadCylinderRev(Matrix4 matrix, AABB3 bBoxLocal)
        { // diameter, h
            float[] d_h = ParseFloats(2);
            return GeometryFactory.BuildCylinder(matrix, bBoxLocal, d_h);
        }
        private static Sphere? ReadSphereRev(Matrix4 matrix, AABB3 bBoxLocal)
        {// diameter
            float[] diameter = ParseFloats(1);
            return GeometryFactory.BuildSphere(matrix, bBoxLocal, diameter);
        }

        private static VolLine? ReadVolLineRev(Matrix4 matrix, AABB3 bBoxLocal)
        {
            float[] start_end = ParseFloats(2);
            return GeometryFactory.BuildVolLine(matrix, bBoxLocal, start_end);
        }
        class ttt
        {
            AABB3 box;
            Vector3 center;
            public ttt(AABB3 box, Vector3 center)
            {
                this.box = box;
                this.center = center;
            }
        }
        private static FacetVolume? ReadFacetVolumeRev(Matrix4 matrix, AABB3 bBoxLocal)
        {

            uint noOfFacets = Parse1Uint(); // 8, facet 수량
            List<Facet3> facets = [];
            int flatcounter = 0;
            bool b_all_triangles = true;

            Dictionary<Facet3, int> temp = new Dictionary<Facet3, int>();
            for (int i = 0; i < noOfFacets; i++)
            {
                Facet3? facet = ReadAFacet(ref flatcounter, ref b_all_triangles);//, i);
                if (facet != null)
                {
                    if (temp.TryGetValue(facet, out int index))
                    {
                        Console.WriteLine("중복 facet ", index);
                        continue;
                    }
                    temp[facet] = temp.Count;
                    facets.Add(facet);
                }
            }
            return new FacetVolume(matrix, bBoxLocal, facets, b_all_triangles);
        }

        private static Facet3? ReadAFacet(ref int flatcounter, ref bool b_all_triangles)//, int i)
        { // Facet3 하나를 읽는 메서드
            Facet3 facet = new();

            b_all_triangles = ReadOutterLoop(ref b_all_triangles, facet, out uint noOfHoles, out bool bflat); // Out Loop 파싱 후, 모두 삼각 메쉬이면 b_all_triangles 플래그를 true
            if (facet.Outter != null)
            {
                if (noOfHoles > 0) // hole loop가 있는 facet
                {
                    b_all_triangles = ReadHoleLoops(ref b_all_triangles, facet, noOfHoles);
                }

                facet.Oobb = OOBB3.Empty;
                if (bflat)
                {
                    flatcounter++;
                }
                return facet;
                //facets.Add(facet);
            }
            return null;
        }

        private static bool ReadOutterLoop(ref bool b_all_triangles, Facet3 facet, out uint noOfHoles, out bool bflat)
        { // Out Loop 파싱 메서드
            noOfHoles = Parse1Uint() - 1; // 홀의 수는 1 빼서 처리
            bflat = true;
            b_all_triangles = ParseLoop(ref b_all_triangles, out facet.Outter);
            if (facet.Outter != null)
            {
                bflat = IsFlat(facet.Outter.Vertices);
            }
            return b_all_triangles;
        }
        private static bool ReadHoleLoops(ref bool b_all_triangles, Facet3 facet, uint noOfHoles)
        { // Hole loops를 읽는 메서드
            for (int k = 0; k < noOfHoles; k++)
            {
                b_all_triangles = ParseLoop(ref b_all_triangles, out Loop3 hole);
                if (hole != null)
                {
                    hole.IsHole = true;
                    facet.Holes.Add(hole);
                }
            }
            return b_all_triangles;
        }
        private static bool ParseLoop(ref bool are_all_triangles, out Loop3 loop)
        {  // Loop 파싱 메서드
            uint noOfVertices = Parse1Uint(); // contour의 정점 수
            Vertex[] vertices = ParseVertices(noOfVertices);

            loop = TryCreateLoop(vertices, out are_all_triangles);
            return are_all_triangles;
            //return SetLoop(ref are_all_triangles, out loop, noOfVertices, Vertices);
        }
        private static Vertex[] ParseVertices(uint vertexCount)
        { // 정점들을 파싱하는 메서드
            Vertex[] vertices = new Vertex[vertexCount];
            for (int n = 0; n < vertexCount; n++)
            {
                Vector3 vertex = ParseVector3();
                Vector3 normal = ParseVector3();
                vertices[n] = new Vertex(vertex, normal);
            }
            return vertices;
        }
        //#endregion
        private static AABB3 ReadAABB3()
        {
            Vector3 b0 = ParseVector3();// * 1000;//15835.00        8811.43        5136.02
            Vector3 b1 = ParseVector3();// * 1000;//15970.00        8946.42        5146.12
            AABB3 bBoxLocal = new(b0, b1);
            return bBoxLocal;
        }
        private static Matrix4 ParseMatrix4()
        { // Column Major임에 유의 !!!!
            Vector4 u = 1000 * ParseVector4();//0.0010000        0.0000000        0.0000000        0.0000000 // mm 로 전환
            Vector4 v = 1000 * ParseVector4();//0.0000000        0.0010000        0.0000000        0.0000000 // mm 로 전환
            Vector4 w = 1000 * ParseVector4();//0.0000000        0.0000000        0.0010000        0.0000000 // mm 로 전환
            return new Matrix4(
                u.X, v.X, w.X, 0,
                u.Y, v.Y, w.Y, 0,
                u.Z, v.Z, w.Z, 0,
                u.W, v.W, w.W, 1);
        }
        private static (uint id, byte r, byte g, byte b) Parse4Bytes()
        {
            string text = stream[textlines++]!;
            string[] parts = text.Split(' ', StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length != 4)
            {
                throw new FormatException($"{textlines} Color MeshID, r, g, b 파싱 에러");
            }
            return !uint.TryParse(parts[0], out uint id) ||
                !byte.TryParse(parts[1], out byte r) ||
                !byte.TryParse(parts[2], out byte g) ||
                !byte.TryParse(parts[3], out byte b)
                ? throw new FormatException($"{textlines} Color 파싱 중 오류 발생")
                : (id, r, g, b);
        }
        private static Vector3 ParseVector3()
        {
            float[] p = ParseFloats(3);
            return new Vector3(p[0], p[1], p[2]);
        }
        private static Vector4 ParseVector4()
        {
            float[] p = ParseFloats(4);
            return new Vector4(p[0], p[1], p[2], p[3]);
        }
        private static float[] ParseFloats(int count)
        {
            string[] values = stream[textlines++].Split([' '], StringSplitOptions.RemoveEmptyEntries);
            if (values.Length != count)
            {
                throw new FormatException("파싱 에러");
            }

            float[] result = new float[count];
            for (int i = 0; i < count; i++)
            {
                if (!float.TryParse(values[i], out result[i]))
                {
                    throw new FormatException($"'{values[i]}'는 유효한 실수가 아님.");
                }
            }
            return result;
        }
        private static uint Parse1Uint()
        {
            string text = stream[textlines++]!;
            text = text.TrimStart().TrimEnd();
            return !uint.TryParse(text, out uint result) ? throw new FormatException($"{textlines}에서 uint 파싱 실패") : result;
        }
        //private static int Parse1Int()
        //{
        //    string text = stream[textlines++]!;
        //    text = text.TrimStart().TrimEnd();
        //    if (!int.TryParse(text, out int result))
        //    {
        //        throw new FormatException($"{textlines}에서 uint 파싱 실패");
        //    }
        //    return result;
        //}
        private static (uint, uint) Parse2Uints()
        {
            string text = stream[textlines++]!;
            string[] ff = text.Split([' '], StringSplitOptions.RemoveEmptyEntries);
            if (ff.Length != 2)
            {
                throw new FormatException($"{textlines} 두 개의 정수 값을 파싱하는 중 오류 발생");
            }
            return !uint.TryParse(ff[0], out uint value1) || !uint.TryParse(ff[1], out uint value2)
                ? throw new FormatException($"{textlines} 값 중 하나 또는 두 개 모두 uint 변환 실패")
                : ((uint, uint))(value1, value2);
        }
        private static Loop3 TryCreateLoop(Vertex[] vertices, out bool areAllTriangles)
        {
            areAllTriangles = true;
            if (vertices.Length > 3)
            {
                areAllTriangles = false;
            }

            Loop3 loop = new(vertices);
            if (vertices.Length == 3)
            { // 삼각형인 경우, 정상 여부 확인
                Vector3 e0 = vertices[1].Position - vertices[0].Position;
                Vector3 e1 = vertices[2].Position - vertices[0].Position;
                Vector3 ec = e0.Cross(e1);
                Vector3 nc = (vertices[0].Normal + vertices[1].Normal + vertices[2].Normal).Normalized();
                float check = ec.Normalized().Dot(nc);
            }
            return loop;
        }
    }
}