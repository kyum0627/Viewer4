using IGX.Geometry.Common;
using OpenTK.Mathematics;
using System.Runtime.InteropServices;

namespace IGX.ViewControl.Render
{
    public enum ViewDirection
    {
        LookAfter,
        LookForward,
        LookPort,
        LookStarboard,
        LookTop,
        LookBottom,
        LookISO,
        RotateAroundpZ,
        RotateAroundmZ
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct CameraData
    {
        public Matrix4 ViewMatrix;        // 64바이트
        public Matrix4 ProjectionMatrix;  // 64바이트
    }
    public interface IMyCamera
    {
        // 렌더링에 필요한 주요 행렬 및 벡터 속성
        Matrix4 ViewMatrix { get; }
        Matrix4 ProjectionMatrix { get; }
        Matrix4 ViewProjectionMatrix { get; }
        Matrix4 RotationMatrix { get; }
        Vector3 Position { get; } // 카메라의 월드 좌표
        Vector3 Target { get; }   // 카메라가 바라보는 지점 (Pivot + PanOffset)
        Vector3 Up { get; }       // 카메라의 상방 벡터

        // 카메라 상태 관련 속성
        float Radius { get; }       // 모델을 감싸는 구의 반지름 (FitToModel, Zoom 등의 기준)
        float Distance { get; }     // Pivot으로부터 카메라까지의 거리
        float ZoomScale { get; }    // 직교 투영에서 사용되는 줌 스케일
        float PerPixel { get; }     // 픽셀당 월드 유닛 크기 (객체 컬링 등에 활용)
        int ViewportWidth { get; }  // 뷰포트 너비
        int ViewportHeight { get; } // 뷰포트 높이

        // 카메라 조작 메서드
        void LookAfter() => SetViewDirection(ViewDirection.LookAfter);
        void LookForward() => SetViewDirection(ViewDirection.LookForward);
        void LookBottom() => SetViewDirection(ViewDirection.LookBottom);
        void LookTop() => SetViewDirection(ViewDirection.LookTop);
        void LookStarBoard() => SetViewDirection(ViewDirection.LookStarboard);
        void LookPort() => SetViewDirection(ViewDirection.LookPort);
        void LookISO() => SetViewDirection(ViewDirection.LookISO);
        void FitToModel(AABB3 boundingBox, ViewDirection viewDir = ViewDirection.LookISO);
        void SetViewDirection(ViewDirection direction);
        void SetViewportSize(int width, int height);
        void Pan(int x1, int y1, int x2, int y2);
        void Zoom(int x, int y, float zoomRatio);
        void Rotate(int x1, int y1, int x2, int y2);
        void Rotate90(int x1, int y1, int x2, int y2); // Rotate90, RotateScreenDelta90는 Rotate에 통합하거나 내부 구현으로 간주할 수 있지만, 외부 노출 필요 시 포
        void RotateScreenDelta90(bool aroundX);
        void UsePerspective(bool usePerspectiveProjection);// 투영 방식 설정
        Vector3 PixelToWorld(int x, int y); // 픽셀-월드 변환 (Picking 등에서 유용)
        void Fit(AABB3 boundingBox);
    }
    public class MyCamera : IMyCamera
    {
        public CameraData ToCameraData()
        {
            return new CameraData
            {
                ViewMatrix = this.ViewMatrix,
                ProjectionMatrix = this.ProjectionMatrix
            };
        }

        public float Radius { get; set; } = 1;
        public float Distance { get; private set; } = 10;
        public Vector3 Direction => RotationMatrix.Row0.Xyz;
        public Vector3 Right => RotationMatrix.Row1.Xyz;
        public Vector3 Up => RotationMatrix.Row2.Xyz;
        public Vector3 Position => Pivot - (Direction * Distance);
        public float ZoomScale { get; private set; }
        public Quaternion Rotation { get; private set; } = Quaternion.Identity;
        public Vector3 Pivot { get; private set; } = Vector3.Zero;
        public Vector3 PanOffset { get; private set; } = Vector3.Zero;
        public Matrix4 ProjectionMatrix { get; private set; } = Matrix4.Identity;
        public Vector3 Target => Pivot + PanOffset;
        public int ViewportWidth { get; private set; } = 1;
        public int ViewportHeight { get; private set; } = 1;
        public float PerPixel => Radius / ViewportHeight; // 기존 MyCamera의 Height 대신 ViewportHeight 사용
        private bool usePerspective = false;
        public Matrix4 ViewMatrix
        {
            get
            {
                if (usePerspective)
                {
                    Vector3 target = Pivot + PanOffset;
                    Vector3 eye = target - (Direction * Distance);
                    return Matrix4.LookAt(eye, target, Up);
                }
                else
                { // 직교 투영의 경우 TranslationMatrix와 RotationMatrix 사용
                    return TranslationMatrix * RotationMatrix;
                }
            }
        }

        public Matrix4 ViewProjectionMatrix => ProjectionMatrix * ViewMatrix;
        public Matrix4 ScaleMatrix => Matrix4.CreateScale(ZoomScale);
        public Matrix4 RotationMatrix => Matrix4.CreateFromQuaternion(Rotation);
        public Matrix4 TranslationMatrix => Matrix4.CreateTranslation(-Pivot + PanOffset);
        private float AspectRatio { get; set; } = 1f; // 초기값 1f로 변경하여 0으로 나누는 오류 방지
        private int HalfWidth => ViewportWidth / 2;
        private int HalfHeight => ViewportHeight / 2;

        private readonly float Fov = MathHelper.DegreesToRadians(60f);
        public float Near = 0.1f;
        public float Far = 1000f;

        public MyCamera(int w = 1, int h = 1)
        {
            Radius = 1.0f;
            Distance = 10.0f;
            Pivot = Vector3.Zero;
            SetViewportSize(w, h); // SetViewportSize 메서드를 통해 초기화
            ZoomScale = Radius;
            SetViewDirection(ViewDirection.LookStarboard);
        }
        public Matrix4 GetViewMatrix()
        {
            return Matrix4.LookAt(Position, Target, Up);
        }

        public Matrix4 GetProjectionMatrix(float aspect)
        {
            return Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(Fov), aspect, Near, Far);
        }
        public void FitToModel(AABB3 boundingBox, ViewDirection viewDir = ViewDirection.LookISO)
        {
            if (boundingBox == AABB3.Empty)
            {
                return;
            }

            Radius = boundingBox.MaxDim * 0.5f;
            Distance = Radius;
            ZoomScale = Radius;
            Pivot = boundingBox.Center;
            SetViewDirection(viewDir); // 뷰 방향 설정
            PanOffset = Vector3.Zero; // 모델 맞춤 시 팬 오프셋 초기화
            UpdateMatrix();
        }

        public void SetViewDirection(ViewDirection direction)
        {
            Quaternion rot = Quaternion.Identity;

            switch (direction)
            {
                case ViewDirection.LookForward:
                    rot = Quaternion.FromAxisAngle(-Vector3.UnitZ, MathF.PI / 2) * Quaternion.FromAxisAngle(Vector3.UnitY, -MathF.PI / 2); break;
                case ViewDirection.LookAfter:
                    rot = Quaternion.FromAxisAngle(Vector3.UnitZ, MathF.PI / 2) * Quaternion.FromAxisAngle(Vector3.UnitY, MathF.PI / 2); break;
                case ViewDirection.LookBottom:
                    rot = Quaternion.FromAxisAngle(Vector3.UnitY, MathF.PI) * Quaternion.FromAxisAngle(Vector3.UnitZ, MathF.PI); break;
                case ViewDirection.LookTop:
                    rot = Quaternion.FromAxisAngle(Vector3.UnitY, -MathF.PI) * Quaternion.FromAxisAngle(Vector3.UnitY, MathF.PI); break;
                case ViewDirection.LookStarboard:
                    rot = Quaternion.FromAxisAngle(Vector3.UnitX, -MathF.PI / 2); break;
                case ViewDirection.LookPort:
                    rot = Quaternion.FromAxisAngle(-Vector3.UnitX, MathF.PI / 2) * Quaternion.FromAxisAngle(Vector3.UnitZ, MathF.PI); break;
                case ViewDirection.LookISO:
                    rot = Quaternion.FromAxisAngle(Vector3.UnitX, -MathF.PI / 3) * Quaternion.FromAxisAngle(Vector3.UnitZ, MathF.PI / 6); break;
                case ViewDirection.RotateAroundpZ:
                    rot = Quaternion.FromAxisAngle(Vector3.UnitZ, MathF.PI / 12); break;
                case ViewDirection.RotateAroundmZ:
                    rot = Quaternion.FromAxisAngle(Vector3.UnitZ, -MathF.PI / 12); break;
            }
            if (direction == ViewDirection.RotateAroundpZ || direction == ViewDirection.RotateAroundmZ)
            {
                Rotation *= rot;
            }
            else
            {
                Rotation = rot;
            }

            UpdateMatrix();
        }
        public void Fit(AABB3 boundingBox)
        {
            if (boundingBox == AABB3.Empty)
            {
                return;
            }

            Radius = boundingBox.MaxDim * 0.5f;
            Distance = Radius;
            Pivot = boundingBox.Center;
            ZoomScale = Radius;
            PanOffset = Vector3.Zero;
            UpdateMatrix();
        }
        public void UsePerspective(bool usePerspectiveProjection)
        {
            usePerspective = usePerspectiveProjection;
            UpdateMatrix();
        }
        private void UpdateMatrix()
        {
            Near = MathF.Max(Distance * 0.01f, 0.01f);
            Far = Distance + (Radius * 4f);
            if (usePerspective)
            {
                ProjectionMatrix = Matrix4.CreatePerspectiveFieldOfView(Fov, AspectRatio, Near, Far);
            }
            else
            {
                float left = -AspectRatio * ZoomScale;
                float right = AspectRatio * ZoomScale;
                float bottom = -ZoomScale;
                float top = ZoomScale;
                Near = -Radius * 10f;
                Far = Radius * 20f;

                ProjectionMatrix = Matrix4.CreateOrthographicOffCenter(left, right, bottom, top, Near, Far);
            }
        }

        public void Pan(int x1, int y1, int x2, int y2)
        {
            Vector3 start = PixelToWorld(x1, y1);
            Vector3 end = PixelToWorld(x2, y2);
            Vector3 move = end - start;
            PanOffset += move;
            UpdateMatrix();
        }
        public void Zoom(int x, int y, float zoomRatio)
        {
            if (usePerspective)
            {
                Distance /= zoomRatio; // 줌 인 = 거리 줄이기, 줌 아웃 = 거리 늘리기
                Distance = MathF.Max(Distance, Radius * 0.01f); // 너무 가까이 못 가게 제한
            }
            else
            {
                if (ZoomScale > Radius * 100)
                {
                    ZoomScale = MathF.Min(ZoomScale, Radius * 100f);
                }
                else if (ZoomScale < Radius * 0.001)
                {
                    ZoomScale = MathF.Max(ZoomScale, Radius * 0.001f);
                }

                Vector3 pivotBefore = PixelToWorld(x, y);
                ZoomScale *= zoomRatio;
                ZoomScale = MathF.Max(ZoomScale, Radius * 0.0001f);

                UpdateMatrix();
                Vector3 pivotAfter = PixelToWorld(x, y);
                Vector3 correction = pivotBefore - pivotAfter;
                PanOffset -= correction;
            }
            UpdateMatrix();
        }
        public void Rotate90(int x1, int y1, int x2, int y2)
        {
            int dx = x2 - x1;
            int dy = y2 - y1;
            dx = 10;
            bool aroundX = true;
            if (Math.Abs(dx) > Math.Abs(dy))
            {
                aroundX = false;
            }
            RotateScreenDelta90(aroundX);
        }
        public void RotateScreenDelta90(bool aroundX)
        {
            Vector3 c0 = PixelToWorld(0, 0);
            Vector3 c1 = PixelToWorld(ViewportWidth, ViewportHeight);

            float r = (c1 - c0).Length * 0.5f;

            float sensitivity = (float)(Math.PI * r / Radius / ViewportWidth);
            const float ang = (float)(Math.PI / 2);
            Quaternion rot = Quaternion.Identity;
            if (aroundX)
            {
                rot = Quaternion.FromAxisAngle(Vector3.UnitY, ang); // 좌우 회전
            }
            else
            {
                rot = Quaternion.FromAxisAngle(Vector3.UnitX, ang); // 위아래 회전
            }

            Rotation = Quaternion.Normalize(rot * Rotation);
        }

        public void Rotate(int x1, int y1, int x2, int y2)
        {
            RotateScreenDelta(x2 - x1, y2 - y1);
        }
        public void RotateScreenDelta(int dx, int dy)
        {
            Vector3 c0 = PixelToWorld(0, 0);
            Vector3 c1 = PixelToWorld(ViewportWidth, ViewportHeight);
            float r = (c1 - c0).Length * 0.5f;
            float sensitivity = (float)(Math.PI * r / Radius / ViewportWidth);

            // 마우스 이동량을 회전으로 변환 (스크린 고정)
            float angleX = dx * sensitivity;
            float angleY = dy * sensitivity;

            // 카메라 기준 회전축: Y축 (yaw), X축 (pitch)
            Quaternion yaw = Quaternion.FromAxisAngle(Vector3.UnitY, angleX); // 좌우 회전
            Quaternion pitch = Quaternion.FromAxisAngle(Vector3.UnitX, angleY); // 위아래 회전

            Rotation = Quaternion.Normalize(yaw * pitch * Rotation);
        }

        public Vector3 PixelToWorld(int x, int y)
        {
            Vector3 origin = NDCtoView(x, y, 0);
            Ray3f ray = new(origin, RotationMatrix.Row0.Xyz);
            return ClosestPointOnRay(origin, ray);
        }
        private Vector3 NDCtoView(int x, int y, int z = 0)
        {
            Matrix4 inverse = Matrix4.Invert(ViewMatrix * ProjectionMatrix);
            Vector3 ndc = NDCoordinates(x, y);
            Vector3 clipCoords = new(ndc.X, ndc.Y, z);
            Vector3 viewCoords = clipCoords.Transform(inverse);
            return viewCoords;
        }
        private Vector3 ClosestPointOnRay(Vector3 point, Ray3f ray)
        {
            Vector3 originToPoint = point - ray.origin;
            float t = Vector3.Dot(originToPoint, ray.direction);

            return t < 0 ? ray.origin : ray.origin + (t * ray.direction);
        }

        private Vector3 NDCoordinates(int x, int y)
        {
            Vector2 ndc = new(ClampX(x), ClampY(y));
            ndc.X = (ndc.X / HalfWidth) - 1f;
            ndc.Y = 1f - (ndc.Y / HalfHeight);
            return new Vector3(ndc);
        }

        public void SetViewportSize(int width, int height)
        {
            if (width <= 0 || height <= 0)
            {
                throw new ArgumentException("뷰포트 크기는 양수여야 함");
            }

            ViewportWidth = width;
            ViewportHeight = height;
            AspectRatio = (float)width / height;
            UpdateMatrix();
        }
        public float ClampX(int x) { return MathUtil.Clamp(x, 1, ViewportWidth - 1); }
        public float ClampY(int y) { return MathUtil.Clamp(y, 1, ViewportHeight - 1); }
    }
}
