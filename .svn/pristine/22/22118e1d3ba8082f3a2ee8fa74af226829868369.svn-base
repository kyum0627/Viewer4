using IGX.Geometry.Common;
using IGX.Geometry.Tessellation;
using OpenTK.Mathematics;
using System;
using System.Collections.Generic;

namespace IGX.Geometry.GeometryBuilder
{
    public class Snout : PrimitiveBase
    {
        public float Rtop;
        public float Rbottom;
        public float Height;
        public float Xoffset;
        public float Yoffset;
        public float XbottomShear;
        public float YbottomShear;
        public float XtopShear;
        public float YtopShear;
        public int GeometryID { get => InstanceData.GeometryID; set => InstanceData.GeometryID = value; }

        public Snout(Matrix4 matrix,
            AABB3 bBoxLocal,
            float radiusBottom = 1f,
            float radiusTop = 1f,
            float height = 1f,
            float offsetX = 0f,
            float offsetY = 0f,
            float bottomShearX = 0f,
            float bottomShearY = 0f,
            float topShearX = 0f,
            float topShearY = 0f)
        {
            Rbottom = radiusBottom;
            Rtop = radiusTop;
            Height = height;

            Xoffset = offsetX;
            Yoffset = offsetY;
            XbottomShear = bottomShearX;
            YbottomShear = bottomShearY;
            XtopShear = topShearX;
            YtopShear = topShearY;
        }

        public Snout(Vector3 bottom, Vector3 top,
            float bottomRadius,
            float topradius = 0,
            float offsetX = 0f,
            float offsetY = 0f,
            float bottomShearX = 0f,
            float bottomShearY = 0f,
            float topShearX = 0f,
            float topShearY = 0f)
        {
            InstanceData.Model = InstanceData.Model.CalculateTRmatrix(bottom, top);
            Rbottom = bottomRadius;
            Rtop = topradius;
            Height = (top - bottom).Length;

            Xoffset = offsetX;
            Yoffset = offsetY;
            XbottomShear = bottomShearX;
            YbottomShear = bottomShearY;
            XtopShear = topShearX;
            YtopShear = topShearY;
        }

        public override (List<Vector3> positions, List<Vector3> normals, List<uint> indices) Tessellate(uint n_segs, bool bcap = true, bool tcap = true)
        {
            (Vector2[] vertexArray, Vector2[] norarr) = GeometryHelper.MakeArc2(1, (uint)n_segs, MathHelper.TwoPi, 0);
            List<Vector2> unitcircle = new(vertexArray);
            float h2 = Height * 0.5f;
            float x2 = Xoffset * 0.5f;
            float y2 = Yoffset * 0.5f;

            List<Vector3> btm = unitcircle.ConvertAll(p => Rbottom * new Vector3(p.X, p.Y, 0));
            List<Vector3> top = unitcircle.ConvertAll(p => Rtop * new Vector3(p.X, p.Y, 0));

            Vector2 slopeBtm = new((float)Math.Tan(XbottomShear), (float)Math.Tan(YbottomShear));
            Vector2 slopeTop = new((float)Math.Tan(XtopShear), (float)Math.Tan(YtopShear));

            List<Vector3> nor = new((int)n_segs);
            for (int i = 0; i < n_segs; i++)
            {
                float xb = btm[i].X - x2; float yb = btm[i].Y - y2; float zb = -h2 + (slopeBtm.X * btm[i].X) + (slopeBtm.Y * btm[i].Y);
                btm[i] = new Vector3(xb, yb, zb);
                float xt = top[i].X + x2; float yt = top[i].Y + y2; float zt = h2 + (slopeTop.X * top[i].X) + (slopeTop.Y * top[i].Y);
                top[i] = new Vector3(xt, yt, zt);
                Vector3 slant = top[i] - btm[i];
                Vector3 nnn = new Vector3(-btm[i].Y, btm[i].X, 0).Cross(slant).Normalized();
                nor.Add(nnn);
            }

            Points.AddRange(btm); Points.AddRange(top); Normals.AddRange(nor); Normals.AddRange(nor);
            for (uint i = 0; i < n_segs; i++)
            {
                TessellationUtility.ZigZag(Indices, n_segs + i, i, n_segs + ((i + 1) % n_segs), (i + 1) % n_segs);
            }

            if (bcap && Rbottom > 0)
            {
                TessellationUtility.AddCircularCap(0, n_segs, Points, Normals, Indices, true);
            }
            if (tcap && Rtop > 0)
            {
                TessellationUtility.AddCircularCap(n_segs, n_segs, Points, Normals, Indices, false);
            }

            (List<Vector3> Positions, List<Vector3> Normals) res = TessellationUtility.MatrixApply(InstanceData.Model, Points, Normals); Points = res.Positions;
            Normals = res.Normals;

            return (Points, Normals, Indices);
        }
    }
}