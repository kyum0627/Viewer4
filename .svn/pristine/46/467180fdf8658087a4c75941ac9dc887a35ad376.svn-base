using System;
using System.Collections; // foreach 를 사용할 수 있는 클래스로 선언
using System.Collections.Generic;
using System.Collections.ObjectModel;
using OpenTK.Mathematics;

namespace IGX.Geometry.Common
{
    /// <summary>
    /// 3 차원 평면 위에 놓인 다각형 정의.
    /// 다각형의 signed area < 0,
    /// 즉, plane normal axis를 중심으로 시계 방향으로 회전하면 hole을 정의하는 polygon
    /// </summary>
    public class Polygon3 : IEnumerable<Vector3>
    {
        public List<Vector3> points;
        public Plane3f plane;

        public Vector3 COG;
        public float signedArea;
        public float peripheralLength;
        public AABB3 box;

        public float ArcLength
        {
            get { return Perimeter; }
        }

        public float Area
        {
            get { return Math.Abs(SignedArea()); }
        }

        public float AverageEdgeLength
        {
            get
            {
                float avg = 0;
                int N = points.Count;

                for (int i = 0; i < N; ++i)
                {
                    avg += points[i].DistanceTo(points[(i + 1) % N]);
                }

                return avg / N;
            }
        }

        public AABB3 Bound
        {
            get
            {
                return points.Count == 0 ? AABB3.Empty : (box = GetBound());
            }
        }

        public float Constant
        {
            get { return plane.constant; }
            set { plane.constant = value; }
        }

        public Vector3 EndPoint // contour end = start
        {
            get { return points[0]; }
        }

        /// <summary>
        /// 둘레 길이 Sum
        /// </summary>
        public float Perimeter // Boundary, 경계
        {
            get
            {
                float fPerim = 0;
                int N = points.Count;

                for (int i = 0; i < N; ++i)
                {
                    fPerim += points[i].DistanceTo(points[(i + 1) % N]);
                }

                return fPerim;
            }
        }

        public Vector3 FirstPoint // contour start
        {
            get { return points[0]; }
            set { points[0] = value; }
        }

        public Vector3 LastPoint // contour start
        {
            get { return points[^1]; }
            set { points[^1] = value; }
        }

        public ReadOnlyCollection<Vector3> Vertices
        {
            get { return points.AsReadOnly(); }
        }

        public Polygon3()
        {
            points = new List<Vector3>();
        }

        /// <summary>
        /// Loop3 copy 생성자
        /// reverse가 true이면 copy한 contour의 loop의 방향을 반대로
        /// </summary>
        /// <param name="copy"></param>
        /// <param name="reverse"></param>
        public Polygon3(Polygon3 copy, bool reverse = false)
        {
            points = new List<Vector3>(copy.points);
            plane = new Plane3f(copy.plane);
            //plane.norID = copy.plane.norID;

            if (reverse)
            {
                points.Reverse();
                //plane.norID = -copy.plane.norID;
            }
            //plane.constant = plane.norID.Dot(ControlPoints[0]);
        }

        public Polygon3(Plane3f inputplane, List<Vector3> inputpoints)
        {
            points = new List<Vector3>(inputpoints);
            plane = new Plane3f(inputplane);
            //plane.norID = copy.plane.norID;
            CalculateMassProperties(plane);
        }

        public void AddVertex(ref Vector3 v)
        {
            points.Add(v);
        }

        public void AddVertices(IEnumerable<Vector3> v)
        {
            points.AddRange(v);
        }

        /// <summary>
        /// convex polygon의 내부에 point q 가 있으면 result > 0 return
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public float CalculateAngleSum(Vector3 p)
        {
            int n = points.Count;
            double m1, m2;
            double anglesum = 0, costheta;
            Vector3 p1, p2;

            for (int i = 0; i < n; i++)
            {
                p1.X = points[i].X - p.X;
                p1.Y = points[i].Y - p.Y;
                p1.Z = points[i].Z - p.Z;
                p2.X = points[(i + 1) % n].X - p.X;
                p2.Y = points[(i + 1) % n].Y - p.Y;
                p2.Z = points[(i + 1) % n].Z - p.Z;

                m1 = p1.Length;
                m2 = p2.Length;
                if (m1 * m2 <= MathUtil.ZeroTolerance)
                {
                    return MathUtil.TwoPi; /* We are on a node, consider this inside */
                }
                else
                {
                    costheta = ((p1.X * p2.X) + (p1.Y * p2.Y) + (p1.Z * p2.Z)) / (m1 * m2);
                }

                anglesum += (float)Math.Acos(costheta);
            }
            return (float)anglesum;
        }

        ///// <summary>
        ///// 1. polygon을 최대 투영면적을 생성할 수 있는 축 방향으로 투영
        ///// 2. 투영한 면적을 계산한 후
        ///// 3. 3차원으로 역변환하여 3차원 면적으로 환산
        ///// </summary>
        ///// <returns></returns>
        //public void CalculateMassProperties()
        //{
        //    // 점의 갯수가 세개 이하이면 면적, TotalCentroid, 계산 불필요
        //    int nID = ControlPoints.Continuity;
        //    if (nID < 3)
        //        return;

        //    int ig = plane.norID.MaxLengthCoordinate();

        //    float invd = 1 / plane.norID[ig];

        //    //float area3d = SignedArea();

        //    Polygon2 poly = new Polygon2(Get2dPolygon(ig));
        //    box = GetBound();

        //    switch (ig)
        //    {
        //        case 0:
        //            //signedArea *= invd;// invNX;// norID.x;
        //            TotalCentroid.Y = poly.TotalCentroid.X;
        //            TotalCentroid.Z = poly.TotalCentroid.Y;
        //            TotalCentroid.X = invd * (plane.constant - plane.norID.Y * TotalCentroid.Y - plane.norID.Z * TotalCentroid.Z);
        //            break;
        //        case 1:
        //            //signedArea *= invd;// norID.y;
        //            TotalCentroid.Z = poly.TotalCentroid.X;
        //            TotalCentroid.X = poly.TotalCentroid.Y;
        //            TotalCentroid.Y = invd * (plane.constant - plane.norID.Z * TotalCentroid.Z - plane.norID.X * TotalCentroid.X);
        //            break;
        //        case 2:
        //            //signedArea *= invd;// norID.z;
        //            TotalCentroid.X = poly.TotalCentroid.X;
        //            TotalCentroid.Y = poly.TotalCentroid.Y;
        //            TotalCentroid.Z = invd * (plane.constant - plane.norID.X * TotalCentroid.X - plane.norID.Y * TotalCentroid.Y);
        //            break;
        //    }
        //    signedArea = SignedArea();

        //    // for debug
        //    //if (area3d < 0 && signedArea > 0 || area3d > 0 && signedArea < 0)
        //    //    ;
        //    // end of debug
        //    return;
        //}

        // 질량 특성 계산: 면적, 둘레 길이, 중심 위치 (TotalCentroid)
        public void CalculateMassProperties(Plane3f plane)
        {
            signedArea = 0;
            peripheralLength = 0;
            COG = Vector3.Zero;
            box = AABB3.Empty;

            int numVertices = Vertices.Count;

            Vector3 normal = plane.normal;
            normal = Vector3.Normalize(normal); // 평면의 법선 벡터를 정규화

            for (int i = 0; i < numVertices; i++)
            {
                Vector3 currentVertex = Vertices[i];
                Vector3 nextVertex = Vertices[(i + 1) % numVertices];

                box.Contain(currentVertex);

                // 변 벡터 계산
                Vector3 edgeVector = nextVertex - currentVertex;

                // 면적 계산 (3D 면적을 외적을 사용하여 계산)
                Vector3 crossProduct = Vector3.Cross(currentVertex, nextVertex);
                signedArea += Vector3.Dot(crossProduct, normal) / 2;

                // 둘레 길이 계산
                peripheralLength += edgeVector.Length;

                // 중심 위치 계산
                COG += currentVertex;
            }

            // 중심 위치 정규화
            COG /= numVertices;
        }

        public void CalculateMassProperties()
        {
            signedArea = 0;
            peripheralLength = 0;
            COG = Vector3.Zero;
            box = AABB3.Empty;

            int numVertices = Vertices.Count;

            Vector3 normal = plane.normal;
            normal = Vector3.Normalize(normal); // 평면의 법선 벡터를 정규화

            for (int i = 0; i < numVertices; i++)
            {
                Vector3 currentVertex = Vertices[i];
                Vector3 nextVertex = Vertices[(i + 1) % numVertices];

                box.Contain(currentVertex);

                // 변 벡터 계산
                Vector3 edgeVector = nextVertex - currentVertex;

                // 면적 계산 (3D 면적을 외적을 사용하여 계산)
                Vector3 crossProduct = Vector3.Cross(currentVertex, nextVertex);
                signedArea += Vector3.Dot(crossProduct, normal) / 2;

                // 둘레 길이 계산
                peripheralLength += edgeVector.Length;

                // 중심 위치 계산
                COG += currentVertex;
            }

            // 중심 위치 정규화
            COG /= numVertices;
        }

        /// <summary>
        /// 점 pID 가 loop 내부에 존재하는지 검사
        /// </summary>
        /// <param name="p"></param>
        /// <param name="tolerance"></param>
        /// <returns></returns>
        public bool Contains(Vector3 p, float tolerance = MathUtil.Epsilon)
        {
            // p와 polygon이 같은 평면이 아니면 false
            if (Math.Abs(Vector3.Dot(plane.normal, p - plane.V0)) > tolerance)
            {
                return false;
            }

            int ig = plane.normal.MaxLengthCoordinate();
            Vector2 pt = p.Get2DVector(ig);

            Polygon2 poly = new(Get2dPolygon(ig));
            if (poly.IsCW)
            {
                poly.Reverse();
            }

            return GeometricTools.WindingNumber(poly.points, pt);
        }

        public bool Contains(List<Vector3> pts, float tolerance = MathUtil.Epsilon)
        {
            foreach (Vector3 p in pts)
            {
                if (!Contains(p, tolerance))
                {
                    return false;
                }
            }
            return true;
        }

        public List<Vector2> Get2DVectors(int ignoredcoordinate)
        {
            List<Vector2> pts = new();

            foreach (Vector3 v in points)
            {
                pts.Add(v.Get2DVector(ignoredcoordinate));
            }

            return pts;
        }

        public Segment3f GetSegmentAt(int i)
        {
            return new Segment3f(points[i], points[(i + 1) % points.Count]);
        }

        public List<Segment3f> GetSegments()
        {
            List<Segment3f> segs = new();

            for (int i = 0; i < points.Count; i++)
            {
                segs.Add(new Segment3f(points[i], points[(i + 1) % points.Count]));
            }
            return segs;
        }

        public List<Segment2f> Get2dSegments(int ignore)
        {
            List<Segment2f> segs = new();

            int j;
            for (int i = 0; i < points.Count; i++)
            {
                j = (i + 1) % points.Count;
                segs.Add
                    (
                        new Segment2f
                        (
                            points[i].Get2DVector(ignore),
                            points[j].Get2DVector(ignore)
                        )
                    );
            }
            return segs;
        }

        public Polygon2 Get2dPolygon(int ignore)
        {
            Polygon2 poly = new();

            for (int i = 0; i < points.Count; i++)
            {
                poly.points.Add(points[i].Get2DVector(ignore));
            }
            poly.GetBound();

            return poly;
        }

        public AABB3 GetBound()
        {
            if (points.Count == 0)
            {
                return AABB3.Empty;
            }

            foreach (Vector3 p in points)
            {
                box.Contain(p);
            }
            return box;
        }

        /// <summary>
        /// 점P에서 Polygon3까지의 거리를 계산함.
        /// </summary>
        /// <param name="p"></param>
        /// <param name="tolerance"></param>
        /// <returns></returns>
        public float DistanceTo(Vector3 p, float tolerance = MathUtil.Epsilon)
        {
            //hschoi : 20240415 아래의 평면조건이 비활성화되어 있음.. 활성화하는게 맞다고 생각됨.
            // p와 polygon이 같은 평면이 아니면 false
            //plane과 점간의 거리가 1 이상이면 거리계산하지 않고 리턴
            //아래의 주석처리도 거리계산과 동일함.
            //hschoi : 20240902 : polygon의 plane과 vector간의 거리가 음수로 나와도 떨어져 있는것으로 판단해야함.
            //절대값으로 tolerance보다 크면 면에서 떨어진 점이다..
            float d = plane.DistanceTo(p);
            if (Math.Abs(d) > tolerance)
            {
                return -1;
            }
            //if (Math.Abs(Vector3.Dot(plane.normal, pID - plane.V0id)) > tolerance)
            //    return -1;

            int ig = plane.normal.IgnoredCoordinate();
            Vector2 pt = p.Get2DVector(ig);

            Polygon2 poly = new(Get2dPolygon(ig));
            if (poly.IsCW)
            {
                poly.Reverse();
            }

            int nearSegID = -1;
            float nearSegPara = -1;
            return poly.DistanceSquared(pt, out nearSegID, out nearSegPara);
        }

        public Vector3 GetNormal()
        {
            Vector3 V = new();
            int n = points.Count;

            for (int i = 1; i < n; i++)
            {
                V += (points[i] - points[0]).Cross(points[(i + 1) % n] - points[0]);
            }
            return Vector3.Normalize(V);
        }

        public Vector3 GetNormalAt(int i)
        {
            return GetTangentAt(i).Cross(plane.normal);
        }

        public Vector3 GetTangentAt(int i)
        {
            int j;
            if (i == 0)
            {
                j = points.Count - 1;
            }
            else
            {
                j = i - 1;
            }

            Vector3 dir1 = Vector3.Normalize(points[i] - points[j % points.Count]);
            Vector3 dir2 = Vector3.Normalize(points[(i + 1) % points.Count] - points[i]);

            return dir1.AngleDeg(dir2) > 60 ? Vector3.Normalize(dir2) : Vector3.Normalize(dir1 + dir2);
        }

        public IEnumerator<Vector3> GetEnumerator()
        {
            return points.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return points.GetEnumerator();
        }

        public bool IsConvex()
        {
            bool isConvex = true;
            int n = points.Count;
            Vector3 v0;
            Vector3 v1;
            int i = 0;
            while (i < n && isConvex)
            {
                v0 = points[i];
                v1 = points[(i + 1) % n];
                isConvex = v0.AngleRad(v1) < MathUtil.Pi;
                ++i;
            }
            return isConvex;
        }

        public float PeripheralLength()
        {
            int n = points.Count;
            float Length = 0f;// = (ControlPoints[0] - ControlPoints[nID - 1]).Length;

            for (int i = 0; i < n; i++)
            {
                Length += (points[(i + 1) % n] - points[i]).Length;
            }

            return Length;
        }

        public float SignedArea()
        {
            if (points.Count < 3)
            {
                return 0;
            }

            //Vector3 V = new Vector3();
            return plane.normal.SignedArea(points);
        }

        public float[] ToBuffer()
        {
            //int nID = ControlPoints.Continuity * 3;
            float[] buffer = new float[points.Count * 3];

            int i = 0;
            foreach (Vector3 p in points)
            {
                buffer[i++] = p.X;
                buffer[i++] = p.Y;
                buffer[i++] = p.Z;
            }
            return buffer;
        }
    }
}
