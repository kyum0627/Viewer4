using IGX.Geometry.Common;
using IGX.Geometry.DataStructure;
using IGX.ViewControl.Buffer.Common;
using OpenTK.Graphics.OpenGL4;
using OpenTK.Mathematics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace IGX.ViewControl.Buffer
{
    public class ArrayBuffer<T> : MutableBuffer<T> where T : struct
    {
        private static readonly Dictionary<Type, VertexAttributeData[]> _cachedAttributes = new();
        private static readonly object _attributeLock = new();
        private readonly object _bindLock = new();

        public ArrayBuffer(ReadOnlySpan<T> data, BufferUsageHint usage, bool keepCpuData = true)
            : base(data.ToArray(), BufferTarget.ArrayBuffer, usage, keepCpuData)
        {
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot create ArrayBuffer without an active OpenGL context.");
            }
            try
            {
                if (!data.IsEmpty)
                {
                    SetData(data);
                    CheckGLError();
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException("Failed to initialize ArrayBuffer.", ex);
            }
        }

        public void SetAttributes()
        {
            if (IsDisposed) throw new ObjectDisposedException(nameof(ArrayBuffer<T>));
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot set attributes without an active OpenGL context.");
            }

            lock (_attributeLock)
            {
                if (!_cachedAttributes.ContainsKey(typeof(T)))
                {
                    CacheAttributes();
                }

                var attributes = _cachedAttributes[typeof(T)];
                if (attributes.Length == 0)
                {
                    throw new InvalidOperationException(
                        $"No vertex attributes defined for type '{typeof(T).Name}'. Ensure fields are decorated with VertexAttribute attributes."
                    );
                }

                try
                {
                    lock (_bindLock)
                    {
                        Bind();
                        int stride = Marshal.SizeOf<T>();

                        foreach (var attrData in attributes)
                        {
                            if (attrData.IsMatrix4)
                            {
                                for (int i = 0; i < 4; i++)
                                {
                                    GL.EnableVertexAttribArray(attrData.Location + i);
                                    GL.VertexAttribPointer(
                                        attrData.Location + i,
                                        4,
                                        VertexAttribPointerType.Float,
                                        false,
                                        stride,
                                        attrData.Offset + Vector4.SizeInBytes * i
                                    );
                                    GL.VertexAttribDivisor(attrData.Location + i, attrData.Divisor);
                                }
                            }
                            else
                            {
                                GL.EnableVertexAttribArray(attrData.Location);

                                if (attrData.GLType == All.Float || attrData.GLType == All.HalfFloat || attrData.GLType == All.Fixed ||
                                    attrData.Normalized && (attrData.GLType == All.UnsignedShort || attrData.GLType == All.UnsignedByte ||
                                                            attrData.GLType == All.Short || attrData.GLType == All.Byte))
                                {
                                    GL.VertexAttribPointer(
                                        attrData.Location,
                                        attrData.Size,
                                        (VertexAttribPointerType)attrData.GLType,
                                        attrData.Normalized,
                                        stride,
                                        attrData.Offset
                                    );
                                }
                                else if (attrData.GLType == All.Int || attrData.GLType == All.UnsignedInt)
                                {
                                    GL.VertexAttribIPointer(
                                        attrData.Location,
                                        attrData.Size,
                                        (VertexAttribIntegerType)attrData.GLType,
                                        stride,
                                        attrData.Offset
                                    );
                                }
                                else if (attrData.GLType == All.Double)
                                {
                                    GL.VertexAttribLPointer(
                                        attrData.Location,
                                        attrData.Size,
                                        (VertexAttribDoubleType)attrData.GLType,
                                        stride,
                                        attrData.Offset
                                    );
                                }
                                else
                                {
                                    Console.WriteLine(
                                        $"Warning: Unsupported VertexAttribute type {attrData.GLType} for field '{attrData.FieldName}' in type '{typeof(T).Name}'."
                                    );
                                    continue;
                                }

                                if (attrData.Divisor > 0)
                                {
                                    GL.VertexAttribDivisor(attrData.Location, attrData.Divisor);
                                }
                            }
                        }
                        CheckGLError();
                        Unbind();
                    }
                }
                catch (Exception ex)
                {
                    throw new InvalidOperationException("Failed to set vertex attributes.", ex);
                }
            }
        }

        public void AddData(ReadOnlySpan<T> dataToAdd)
        {
            if (IsDisposed) throw new ObjectDisposedException(nameof(ArrayBuffer<T>));
            if (!keepCpuData)
            {
                throw new InvalidOperationException("CPU data is not maintained. Set keepCpuData to true in the constructor.");
            }
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot add data without an active OpenGL context.");
            }

            var oldData = CpuData;
            var newData = new T[oldData.Length + dataToAdd.Length];
            oldData.CopyTo(newData.AsSpan(0));
            dataToAdd.CopyTo(newData.AsSpan(oldData.Length));

            try
            {
                lock (_bindLock)
                {
                    Resize(newData.Length);
                    UpdateData(newData.AsSpan(), 0);
                    CheckGLError();
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException("Failed to add data to ArrayBuffer.", ex);
            }
        }

        public void RemoveAt(int index)
        {
            if (IsDisposed) throw new ObjectDisposedException(nameof(ArrayBuffer<T>));
            if (!keepCpuData)
            {
                throw new InvalidOperationException("CPU data is not maintained. Set keepCpuData to true in the constructor.");
            }
            if (index < 0 || index >= CpuData.Length)
            {
                throw new ArgumentOutOfRangeException(nameof(index), "Index is out of bounds.");
            }
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot remove data without an active OpenGL context.");
            }

            var oldData = CpuData;
            var newData = new T[oldData.Length - 1];
            oldData.Slice(0, index).CopyTo(newData.AsSpan(0));
            oldData.Slice(index + 1).CopyTo(newData.AsSpan(index));

            try
            {
                lock (_bindLock)
                {
                    Resize(newData.Length);
                    UpdateData(newData.AsSpan(), 0);
                    CheckGLError();
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException("Failed to remove data from ArrayBuffer.", ex);
            }
        }

        public void UpdateInstance(T instanceData, int index)
        {
            if (IsDisposed) throw new ObjectDisposedException(nameof(ArrayBuffer<T>));
            if (!keepCpuData)
            {
                throw new InvalidOperationException("CPU data is not maintained. Set keepCpuData to true in the constructor.");
            }
            if (index < 0 || index >= CpuData.Length)
            {
                throw new ArgumentOutOfRangeException(nameof(index), "Instance index is out of bounds.");
            }
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot update instance without an active OpenGL context.");
            }

            var cpuData = CpuData;
            cpuData[index] = instanceData;

            try
            {
                lock (_bindLock)
                {
                    UpdateData(cpuData.Slice(index, 1), (nint)(index * Unsafe.SizeOf<T>()));
                    CheckGLError();
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"Failed to update instance at index {index}.", ex);
            }
        }

        public void UpdateData(int startIndex, ReadOnlySpan<T> newData)
        {
            if (IsDisposed) throw new ObjectDisposedException(nameof(ArrayBuffer<T>));
            if (!keepCpuData)
            {
                throw new InvalidOperationException("CPU data is not maintained. Set keepCpuData to true in the constructor.");
            }
            if (startIndex < 0 || newData.Length < 0 || startIndex + newData.Length > Count)
            {
                throw new ArgumentOutOfRangeException(nameof(startIndex), "Data range is out of bounds.");
            }
            if (newData.IsEmpty) return;
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot update data without an active OpenGL context.");
            }

            var cpuData = CpuData;
            newData.CopyTo(cpuData.Slice(startIndex, newData.Length));

            try
            {
                lock (_bindLock)
                {
                    UpdateData(newData, (nint)(startIndex * Unsafe.SizeOf<T>()));
                    CheckGLError();
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException("Failed to update ArrayBuffer data.", ex);
            }
        }

        public ReadOnlySpan<T> GetCpuData()
        {
            if (IsDisposed) throw new ObjectDisposedException(nameof(ArrayBuffer<T>));
            if (!keepCpuData)
            {
                throw new InvalidOperationException("CPU data is not maintained. Set keepCpuData to true in the constructor.");
            }
            return CpuData;
        }

        public void UploadAllData()
        {
            if (IsDisposed) throw new ObjectDisposedException(nameof(ArrayBuffer<T>));
            if (!keepCpuData)
            {
                throw new InvalidOperationException("CPU data is not maintained. Set keepCpuData to true in the constructor.");
            }
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot upload data without an active OpenGL context.");
            }

            try
            {
                lock (_bindLock)
                {
                    SetData(CpuData);
                    CheckGLError();
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException("Failed to upload all data to ArrayBuffer.", ex);
            }
        }

        private void CacheAttributes()
        {
            lock (_attributeLock)
            {
                if (_cachedAttributes.ContainsKey(typeof(T)))
                {
                    return;
                }

                List<VertexAttributeData> fieldAttributes = new();
                FieldInfo[] fields = typeof(T).GetFields(BindingFlags.Public | BindingFlags.Instance);

                foreach (FieldInfo field in fields)
                {
                    VertexAttribute? attribute = field.GetCustomAttribute<VertexAttribute>();
                    if (attribute != null)
                    {
                        if (field.FieldType == typeof(Matrix4))
                        {
                            fieldAttributes.Add(new VertexAttributeData
                            {
                                FieldName = field.Name,
                                Location = attribute.Location,
                                Size = 4,
                                GLType = All.Float,
                                Normalized = false,
                                Offset = (int)Marshal.OffsetOf<T>(field.Name),
                                Divisor = 1,
                                IsMatrix4 = true
                            });
                        }
                        else
                        {
                            fieldAttributes.Add(new VertexAttributeData
                            {
                                FieldName = field.Name,
                                Location = attribute.Location,
                                Size = attribute.Size,
                                GLType = attribute.Type,
                                Normalized = attribute.Normalized,
                                Offset = (int)Marshal.OffsetOf<T>(field.Name),
                                Divisor = 1
                            });
                        }
                    }
                    else
                    {
                        Console.WriteLine(
                            $"Warning: Field '{field.Name}' in type '{typeof(T).Name}' has no VertexAttribute attribute and will not be set as a vertex attribute."
                        );
                    }
                }

                _cachedAttributes[typeof(T)] = fieldAttributes.OrderBy(a => a.Location).ToArray();

                if (_cachedAttributes[typeof(T)].Length == 0)
                {
                    Console.WriteLine(
                        $"Warning: Type '{typeof(T).Name}' has no fields with VertexAttribute attributes. No vertex attributes will be set."
                    );
                }
            }
        }

        private static bool IsContextLikelyActive()
        {
            try
            {
                GL.GetError();
                return true;
            }
            catch
            {
                return false;
            }
        }

        private static void CheckGLError()
        {
            var error = GL.GetError();
            if (error != ErrorCode.NoError)
            {
                throw new InvalidOperationException($"OpenGL error: {error}");
            }
        }
    }
}