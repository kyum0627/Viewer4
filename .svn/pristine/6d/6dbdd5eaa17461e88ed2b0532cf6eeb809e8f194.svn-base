using System.Collections.Generic;
using OpenTK.Mathematics;
using IGX.Geometry.Common;

namespace IGX.Geometry.Intersect
{
    public class IntersectLine3Triangle3
    {
        Line3f line;
        Triangle3f triangle;

        //Vector3 triangleBary;
        //Vector3 point;

        public IntersectionResult3 result;

        public IntersectLine3Triangle3(Line3f L, Triangle3f T)
        {
            line = L;
            triangle = T;
        }

        public IntersectionType Test(Line3f line, Triangle3f triangle)
        {
            result = new IntersectionResult3();

            Vector3 diff = line.origin - triangle[0];
            Vector3 edge1 = triangle[1] - triangle[0];
            Vector3 edge2 = triangle[2] - triangle[0];
            Vector3 normal = edge1 * edge2;

            // Solve
            // Q + t*D = b1*E1 + b2*E2
            //  - Q = diff
            //  - D = line direction,
            //  - E1 = edge1
            //  - E2 = edge2
            //  - N = Cross(E1,E2)) by
            //    |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //    |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //    |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)

            float DdN = Vector3.Dot(line.direction, normal);
            float sign;
            if (DdN > 0)
            {
                sign = 1;
            }
            else if (DdN < 0)
            {
                sign = -1;
                DdN = -DdN;
            }
            else
            {
                // 평행, 같은 평면위에 있음
                result.status = IntersectionResult.INTERSECT;
                result.type = IntersectionType.LINE;
                return result.type;
            }

            float DdQxE2 = sign * line.direction.DotAfterCross(diff, edge2);
            if (DdQxE2 >= 0)
            {
                float DdE1xQ = sign * line.direction.DotAfterCross(edge1, diff);
                if (DdE1xQ >= 0)
                {
                    if (DdQxE2 + DdE1xQ <= DdN)
                    {
                        // 교차
                        result.status = IntersectionResult.INTERSECT;
                        result.type = IntersectionType.POINT;
                        return result.type;
                    }
                    // else: b1+b2 > 1, 교차하지 않음
                }
                // else: b2 < 0, 교차하지 않음
            }
            // else: b1 < 0, 교차하지 않음

            result.status = IntersectionResult.NOTINTERSECT;
            result.type = IntersectionType.NONE;
            return result.type;
        }

        public IntersectionType Compute()
        {
            result = new IntersectionResult3();

            Vector3 diff = line.origin - triangle[0];
            Vector3 edge1 = triangle[1] - triangle[0];
            Vector3 edge2 = triangle[2] - triangle[0];
            Vector3 normal = edge1.Cross(edge2);

            float DdN = Vector3.Dot(line.direction, normal);
            float sign;

            if (DdN > 0)
            {
                sign = 1;
            }
            else if (DdN < 0)
            {
                sign = -1;
                DdN = -DdN;
            }
            else
            {
                // 평행, 같은 평면위에 있음
                result.status = IntersectionResult.INTERSECT;
                result.type = IntersectionType.LINE;
                return result.type;
            }

            float DdQxE2 = sign * line.direction.DotAfterCross(diff, edge2);
            if (DdQxE2 >= 0)
            {
                float DdE1xQ = sign * line.direction.DotAfterCross(edge1, diff);
                if (DdE1xQ >= 0)
                {
                    if (DdQxE2 + DdE1xQ <= DdN)
                    {
                        // 교차
                        float QdN = -sign * Vector3.Dot(diff, normal);
                        float inv = 1 / DdN;

                        result.status = IntersectionResult.INTERSECT;
                        result.type = IntersectionType.POINT;
                        result.parameter1 = new Interval(QdN * inv, QdN * inv);
                        result.parameter2 = new Interval(1 - result.parameter2[1] - result.parameter2[2], DdQxE2 * inv);
                        //result.parameter2[1] = DdQxE2 * inv;
                        //result.parameter2[2] = DdE1xQ * inv;
                        //result.parameter2[0] = (float)1 - result.parameter2[1] - result.parameter2[2];
                        result.points = new List<Vector3>
                        {
                            line.origin + (result.parameter1[0] * line.direction)
                        };
                        return result.type;
                    }
                    // else: b1+b2 > 1, 교차하지 않음
                }
                // else: b2 < 0, 교차하지 않음
            }
            // else: b1 < 0, 교차하지 않음
            result.status = IntersectionResult.NOTINTERSECT;
            result.type = IntersectionType.NONE;
            return result.type;
        }
    }
}
