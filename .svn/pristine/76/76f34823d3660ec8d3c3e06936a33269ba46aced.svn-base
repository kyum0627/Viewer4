using System;
using System.Collections.Generic;
using OpenTK.Mathematics;

namespace IGX.Geometry.Common
{
    public struct Triangle3f
    {
        public Vector3 V0, V1, V2; // 삼각형을 구성하는 세 개의 꼭짓점

        public Segment3f[] LineSegments // 삼각형의 세 변을 반환하는 속성
        {
            get
            {
                Segment3f[] segs = new Segment3f[3]
                {
                    new(V0, V1), // V0와 V1을 잇는 변
                    new(V1, V2), // V1와 V2를 잇는 변
                    new(V2, V0)  // V2와 V0를 잇는 변
                };
                return segs;
            }
        }
        public Plane3f Plane // 삼각형이 속한 평면을 반환하는 속성
        {
            get
            {
                return new Plane3f(V0, V1, V2);
            }
        }

        public Triangle3f(Vector3 v0, Vector3 v1, Vector3 v2) // 삼각형 생성자
        {
            V0 = v0;
            V1 = v1;
            V2 = v2;
        }

        public float Area() // 삼각형의 면적을 계산하여 반환
        {
            return Math.Abs(SignedArea);
        }
        /// <summary>
        /// 레이(Ray)와 삼각형(Triangle) 간의 교차를 검사하는 메서드
        /// Möller–Trumbore 교차 알고리즘을 사용
        /// </summary>
        /// <param name="ray">충돌을 검사할 3D 레이</param>
        /// <param name="triangle">충돌을 검사할 3D 삼각형</param>
        /// <param name="distance">레이의 시작점으로부터 충돌 지점까지의 거리 충돌하지 않으면 <see cref="float.MaxValue"/></param>
        /// <returns>레이가 삼각형과 교차하면 true, 그렇지 않으면 false</returns>
        public bool RayIntersectsTriangle(Ray3f ray, out float distance)
        {
            Vector3 edge1 = V1 - V0;
            Vector3 edge2 = V2 - V0;

            Vector3 h = Vector3.Cross(ray.direction, edge2);
            float a = Vector3.Dot(edge1, h);
            distance = float.MaxValue;
            const float tolerance = 0.00001f;
            if (MathF.Abs(a) < tolerance)
            {
                return false;
            }

            float f = 1.0f / a;
            Vector3 s = ray.origin - V0;
            float u = f * Vector3.Dot(s, h);
            if (u < 0.0f || u > 1.0f)
            {
                return false;
            }

            Vector3 q = Vector3.Cross(s, edge1);
            float v = f * Vector3.Dot(ray.direction, q);
            if (v < 0.0f || u + v > 1.0f + tolerance)
            {
                return false;
            }

            float t = f * Vector3.Dot(edge2, q);
            if (t > tolerance)
            {
                distance = t; return true;
            }
            else
            {
                distance = float.MaxValue; return false;
            }
        }
        /// <summary>
        /// 점 P0, P1을 잇는 선분과 삼각형간 교차를 테스트하는 함수.
        /// </summary>
        /// <param name="P0">선분의 시작점</param>
        /// <param name="P1">선분의 끝점</param>
        /// <param name="T">교차를 테스트할 대상 삼각형</param>
        /// <param name="pts">교차점이 저장될 리스트</param>
        /// <returns>-1: 삼각형이 아님, 0: 교차 없음, 1: 한 점에서 교차, 2: 같은 평면</returns>
        public int Intersect(Vector3 P0, Vector3 P1, Triangle3f T, List<Vector3> pts)
        {
            Vector3 u, v, n;
            Vector3 dir, w0, w;
            float r, a, b;

            u = T.V1 - T.V0; // 삼각형의 첫 번째 변 벡터
            v = T.V2 - T.V0; // 삼각형의 두 번째 변 벡터
            n = Vector3.Cross(u, v); // 삼각형의 법선 벡터
            if (n == Vector3.Zero) // 법선이 0이면 세 점이 일직선에 있으므로 삼각형이 아님
            {
                return -1;
            }

            dir = P1 - P0; // 선분의 방향 벡터
            w0 = P0 - T.V0; // 선분 시작점에서 삼각형의 기준점(Vertex0)으로 가는 벡터
            a = -Vector3.Dot(Normal, w0); // 선분 시작점과 삼각형 평면의 법선 내적
            b = Vector3.Dot(Normal, dir); // 선분 방향과 삼각형 평면의 법선 내적
            if (Math.Abs(b) < MathUtil.Epsilon) // 선분이 평면과 평행한 경우
            {
                if (a == 0) // 선분이 삼각형과 동일 평면위에 있는 경우
                {
                    return 2;
                }
                else
                {
                    return 0; // 만나지 않음 (평면 밖에서 평행)
                }
            }

            r = a / b; // 평면과의 교차점까지의 선분 매개변수
            if (r < 0.0 || r > 1.0) // 교차점이 선분 밖에 있는 경우
            {
                return 0; // 만나지 않음
            }

            // 교차점을 계산하고 pts 리스트에 추가
            pts = new List<Vector3>
            {
                P0 + (r * dir) // 교차점
            };

            // 교차점이 삼각형 내부에 있는지 확인 (바리센트릭 좌표 사용)
            float uu, uv, vv, wu, wv, D;
            uu = Vector3.Dot(u, u);
            uv = Vector3.Dot(u, v);
            vv = Vector3.Dot(v, v);
            w = pts[0] - T.V0;
            wu = Vector3.Dot(w, u);
            wv = Vector3.Dot(w, v);
            D = (uv * uv) - (uu * vv); // 분모

            // 바리센트릭 좌표(s, t) 계산
            float s, t;
            s = ((uv * wv) - (vv * wu)) / D;
            if (s < 0.0 || s > 1.0) // 바리센트릭 좌표 s가 유효 범위를 벗어난 경우 (삼각형 외부)
            {
                return 0;
            }

            t = ((uv * wu) - (uu * wv)) / D;
            if (t < 0.0 || s + t > 1.0) // 바리센트릭 좌표 t 또는 s+t가 유효 범위를 벗어난 경우 (삼각형 외부)
            {
                return 0;
            }

            return 1; // 교차점이 삼각형 내부에 있음
        }

        public Vector3 Normal // 삼각형의 법선 벡터를 계산하여 반환
        {
            get
            {
                return Vector3.Normalize(Vector3.Cross(V1 - V0, V2 - V1));
            }
        }

        public Vector3 this[int key] // 인덱서를 통해 꼭짓점에 접근
        {
            get { return key == 0 ? V0 : key == 1 ? V1 : V2; }
            set
            {
                if (key == 0)
                {
                    V0 = value;
                }
                else if (key == 1)
                {
                    V1 = value;
                }
                else
                {
                    V2 = value;
                }
            }
        }

        /// <summary>
        /// 삼각형을 구성하는 세 점으로 나타낸 바리센트릭 좌표(barycentric coordinates)를 이용해 점의 위치 계산
        /// </summary>
        /// <param name="bary0">V0에 대한 가중치</param>
        /// <param name="bary1">V1에 대한 가중치</param>
        /// <param name="bary2">V2에 대한 가중치</param>
        /// <returns>3D 공간의 점</returns>
        public Vector3 PointAt(float bary0, float bary1, float bary2)
        {
            return (bary0 * V0) + (bary1 * V1) + (bary2 * V2);
        }

        /// <summary>
        /// 벡터 형태의 바리센트릭 좌표를 이용해 점의 위치 계산
        /// </summary>
        /// <param name="bary">바리센트릭 좌표 벡터 (x=bary0, y=bary1, z=bary2)</param>
        /// <returns>3D 공간의 점</returns>
        public Vector3 PointAt(Vector3 bary)
        {
            return (bary.X * V0) + (bary.Y * V1) + (bary.Z * V2);
        }

        /// <summary>
        /// 부호 있는 면적을 계산
        /// </summary>
        public float SignedArea
        {
            get
            {
                float area;
                Vector3 A = V1 - V0; // V0에서 V1로 가는 벡터
                Vector3 B = V2 - V1; // V1에서 V2로 가는 벡터

                // 2D 평면에서의 외적을 이용한 면적 계산 (2D 투영을 가정)
                area = (A.Y * B.X) - (A.X * B.Y);
                return area * 0.5f;
            }
        }

        /// <summary>
        /// 두 삼각형이 겹치는지 여부를 분리 축 정리(SAT)를 사용하여 빠르게 판별.
        /// </summary>
        public static bool IsCollide(Triangle3f t0, Triangle3f t1, float epsilon = 0f)
        {
            // 1. 삼각형 노멀 벡터를 분리 축으로 사용
            // t0의 법선이 분리축인지 확인
            if (IsSeparated(t0, t1, t0.Normal)) return false;
            // t1의 법선이 분리축인지 확인
            if (IsSeparated(t0, t1, t1.Normal)) return false;

            // 2. 에지-크로스-에지 분리 축을 사용
            for (int i0 = 0; i0 < 3; i0++) // t0의 각 변에 대해
            {
                for (int i1 = 0; i1 < 3; i1++) // t1의 각 변에 대해
                {
                    Vector3 edge0 = t0[i0] - t0[(i0 + 1) % 3]; // t0의 변
                    Vector3 edge1 = t1[i1] - t1[(i1 + 1) % 3]; // t1의 변
                    Vector3 separatingAxis = Vector3.Cross(edge0, edge1); // 두 변의 외적을 분리축으로 사용

                    // 분리축이 유효하고 두 삼각형을 분리하는지 확인
                    if (separatingAxis.LengthSquared > epsilon && IsSeparated(t0, t1, separatingAxis))
                    {
                        return false; // 분리됨, 교차하지 않음
                    }
                }
            }
            return true; // 모든 분리축 테스트를 통과했으므로 교차함
        }

        /// <summary>
        /// 주어진 축에 대해 두 삼각형이 분리되었는지 확인.
        /// </summary>
        /// <param name="t0">첫 번째 삼각형</param>
        /// <param name="t1">두 번째 삼각형</param>
        /// <param name="axis">분리 축</param>
        /// <returns>분리되면 true, 아니면 false</returns>
        private static bool IsSeparated(Triangle3f t0, Triangle3f t1, Vector3 axis)
        {
            // 축의 길이가 매우 작으면 유효한 분리축이 아님. (선형 의존성을 가질 때)
            if (axis.LengthSquared < MathUtil.Epsilon)
            {
                return false;
            }

            float min0, max0, min1, max1;
            ProjectPointsToAxis(t0, axis, out min0, out max0); // t0를 축에 투영
            ProjectPointsToAxis(t1, axis, out min1, out max1); // t1을 축에 투영

            if (max0 < min1 || max1 < min0) // 투영된 구간이 겹치지 않는지 확인
            {
                return true; // 분리됨
            }
            return false; // 분리되지 않음
        }

        /// <summary>
        /// 삼각형의 세 점들을 axis에 투영했을 때 최소, 최대 값 계산
        /// </summary>
        private static void ProjectPointsToAxis(Triangle3f triangle, Vector3 axis, out float fmin, out float fmax)
        {
            float dot0 = Vector3.Dot(axis, triangle.V0); // V0를 축에 투영
            float dot1 = Vector3.Dot(axis, triangle.V1); // V1를 축에 투영
            float dot2 = Vector3.Dot(axis, triangle.V2); // V2를 축에 투영

            fmin = Math.Min(dot0, Math.Min(dot1, dot2)); // 세 투영 값 중 최소값
            fmax = Math.Max(dot0, Math.Max(dot1, dot2)); // 세 투영 값 중 최대값
        }
    }
}