using IGX.Geometry.Common;
using IGX.Geometry.Common.OpenTKextension;
using IGX.Geometry.ConvexHull;
using OpenTK.Mathematics;
using System;
using System.Collections.Generic;
using System.Linq;

namespace IGX.Geometry.DataStructure.IgxMesh
{
    public class IgxMesh
    {
        public float Thickness;
        public bool IsFlat = true;
        public Dictionary<Vertex, int> VerticesMap { get; private set; } = new Dictionary<Vertex, int>(new VertexEqualityComparer(1e-03f, 0.866f));
        public List<Vertex> UniqueVertices { get; private set; } = new List<Vertex>();
        public List<int> VertexIndices { get; private set; } = new List<int>();
        public List<TrianglesAdjacency> Triangles { get; private set; } = new List<TrianglesAdjacency>();
        public List<HalfEdge> HalfEdges { get; private set; } = new List<HalfEdge>();
        public List<int> FaceToHalfEdgeMap { get; private set; } = new List<int>();
        public Dictionary<Eedge, List<int>> EdgeToTriangleMap { get; private set; } = new Dictionary<Eedge, List<int>>();
        public Dictionary<Eedge, int> EdgeToHalfEdgeMap { get; private set; } = new Dictionary<Eedge, int>();
        public List<SurfaceMesh> Surfaces { get; private set; } = new List<SurfaceMesh>();
        public float TotalVolume { get; private set; }
        public Vector3 TotalCentroid { get; private set; }
        public float TotalSurfaceArea { get; private set; }
        public List<int> AdjacentIndices => Triangles.SelectMany(t => new int[] { t.V0, t.V1, t.V2, t.AdjV0, t.AdjV1, t.AdjV2 }).ToList();
        public List<uint> Indices => Triangles.SelectMany(t => new uint[] { (uint)t.V0, (uint)t.V1, (uint)t.V2 }).ToList();
        public List<Vector3> Positions => UniqueVertices.Select(p => p.Position).ToList();
        public List<Vector3> Normals => UniqueVertices.Select(p => p.Normal).ToList();

        public SurfaceMesh? MoldSurface => Surfaces.Count > 0 ? Surfaces[0] : null;
        public SurfaceMesh? OffsetSurface => Surfaces.Count > 1 ? Surfaces[1] : null;

        public List<Vector3> SurfaceOutBoundaryPoints(int surfaceid)
        {
            if (surfaceid < 0 || surfaceid >= Surfaces.Count)
            {
                throw new ArgumentOutOfRangeException(nameof(surfaceid), "The surface index is out of range.");
            }
            var surf = Surfaces[surfaceid];
            return surf.BoundaryLoops
                        .SelectMany(loop => loop)
                        .Select(v => UniqueVertices[v].Position)
                        .ToList();
        }

        private void MatchSurfacePairs()
        {
            List<Vector3> norms = Surfaces.Select(s => s.Normal).ToList();
            List<System.Tuple<int, int>> matched = VectorPairFinder.FindOppositePairs(norms);
        }

        public void ProcessMesh(Vertex[] vtx,
            float positionTolerance = 1e-3f,
            float normalDotProductThreshold = 0.866f)
        {
            ProcessVertices(vtx, true);
            ComputeTriangleMetrics();
            ComputeTriangleAdjacency();
            FindSurfaces();
            MergeSurfaces(positionTolerance, normalDotProductThreshold);
            SortSurfacesByArea();
            ComputeMeshMetrics();

            if (Surfaces.Count < 2)
            {
                return;
            }

            IsFlat = MoldSurface.IsFlat;
            //SortMoldOffset();
            CalculateThickness();
        }
   
        private void CalculateThickness()
        {
            if (Surfaces.Count > 1 && Surfaces[1].Normal.Dot(Surfaces[0].Normal) <= -0.999f)
            {
                Thickness = MathUtil.AbsRoundTo05((Surfaces[1].Centroid - Surfaces[0].Centroid).Length);
                TotalCentroid = (Surfaces[1].Centroid + Surfaces[0].Centroid) * 0.5f;
            }
        }

        private readonly object _lockObject = new object();
        private void SortMoldOffsetByManhattanDistance()
        {
            if (Surfaces.Count <= 1)
            {
                return;
            }
            var moldSurface = this.MoldSurface;
            var offsetSurface = this.OffsetSurface;
            if (moldSurface == null || offsetSurface == null)
            {
                return;
            }

            if (moldSurface.Centroid.ManhattanDistance() > offsetSurface.Centroid.ManhattanDistance())
            {
                lock (_lockObject)
                {
                    if (Surfaces.Count > 1 && Surfaces[0] == moldSurface && Surfaces[1] == offsetSurface)
                    {
                        (Surfaces[0], Surfaces[1]) = (Surfaces[1], Surfaces[0]);
                    }
                }
            }
        }

        private void CheckMoldOffsetOfCurved()
        {
            if (Surfaces.Count < 2)
            {
                return;
            }

            var moldSurface = this.MoldSurface;
            var offsetSurface = this.OffsetSurface;

            if (moldSurface == null || offsetSurface == null)
            {
                return;
            }

            if (moldSurface.Normal.Y * moldSurface.Centroid.Y > 0)
            {
                lock (_lockObject)
                {
                    if (Surfaces.Count > 1 && Surfaces[0] == moldSurface && Surfaces[1] == offsetSurface)
                    {
                        (Surfaces[0], Surfaces[1]) = (Surfaces[1], Surfaces[0]);
                    }
                }
            }
        }
        private void CheckMoldOffsetOfFlat()
        {
            if (Surfaces.Count < 2)
            {
                return;
            }

            var moldSurface = this.MoldSurface;
            var offsetSurface = this.OffsetSurface;

            if (moldSurface == null || offsetSurface == null)
            {
                return;
            }

            var maxaxis = moldSurface.Normal.MaxLengthCoordinate();
            if (maxaxis == 0 || maxaxis == 2)
            {
                if (moldSurface.Normal[maxaxis] * moldSurface.Centroid[maxaxis] > 0)
                {
                    lock (_lockObject)
                    {
                        if (Surfaces.Count > 1 && Surfaces[0] == moldSurface && Surfaces[1] == offsetSurface)
                        {
                            (Surfaces[0], Surfaces[1]) = (Surfaces[1], Surfaces[0]);
                        }
                    }
                }
            }
        }

        public Vertex[] GetVertices(HalfEdge edge)
        {
            return new Vertex[2] { Vertex0(edge), Vertex1(edge) };
        }
        public Vertex Vertex0(HalfEdge edge)
        {
            return UniqueVertices[edge.vertex];
        }
        public Vertex Vertex1(HalfEdge edge)
        {
            return UniqueVertices[edge.next];
        }
        public Vertex OppositeVertex(HalfEdge edge)
        {
            return UniqueVertices[Opposite(edge)];
        }
        public int Opposite(HalfEdge edge)
        {
            return HalfEdges[edge.twin].next;
        }
        public void ProcessVertices(Vertex[] vtx, bool mergeVertices = true)
        {
            UniqueVertices.Clear();
            VerticesMap.Clear();
            for (int i = 0; i < vtx.Length; i += 3)
            {
                int[] vids = new int[3];
                for (int j = 0; j < 3; j++)
                {
                    var currentVertex = vtx[i + j];
                    if (mergeVertices)
                    {
                        if (VerticesMap.TryGetValue(currentVertex, out int vid))
                        {
                            vids[j] = vid;
                        }
                        else
                        {
                            vids[j] = VerticesMap.Count;
                            VerticesMap.Add(currentVertex, vids[j]);
                            UniqueVertices.Add(currentVertex);
                        }
                    }
                    else
                    {
                        vids[j] = UniqueVertices.Count;
                        UniqueVertices.Add(currentVertex);
                    }
                }
                var triangleIndex = Triangles.Count;
                Triangles.Add(new TrianglesAdjacency(vids[0], vids[1], vids[2]));
                var halfEdgeStartIndex = HalfEdges.Count;
                FaceToHalfEdgeMap.Add(halfEdgeStartIndex);
                for (int j = 0; j < 3; j++)
                {
                    var heIndex = HalfEdges.Count;
                    var startV = vids[j];
                    var endV = vids[(j + 1) % 3];
                    var nextHeIndex = (j == 2) ? halfEdgeStartIndex : heIndex + 1;
                    var he = new HalfEdge { vertex = endV, next = nextHeIndex, face = triangleIndex, twin = -1 };
                    HalfEdges.Add(he);
                    var edge = new Eedge(startV, endV);
                    var reverseEdge = new Eedge(endV, startV);
                    if (EdgeToHalfEdgeMap.TryGetValue(reverseEdge, out var twinHeIndex))
                    {
                        var twinHe = HalfEdges[twinHeIndex];
                        twinHe.twin = heIndex;
                        HalfEdges[twinHeIndex] = twinHe;
                        he.twin = twinHeIndex;
                        EdgeToHalfEdgeMap.Remove(reverseEdge);
                    }
                    else
                    {
                        EdgeToHalfEdgeMap[edge] = heIndex;
                    }
                    HalfEdges[heIndex] = he;
                }
            }
        }
        public void ComputeTriangleMetrics()
        {
            for (int i = 0; i < Triangles.Count; i++)
            {
                var triangle = Triangles[i];
                var v0 = UniqueVertices[triangle.V0].Position;
                var v1 = UniqueVertices[triangle.V1].Position;
                var v2 = UniqueVertices[triangle.V2].Position;
                triangle.Centroid = (v0 + v1 + v2) / 3.0f;
                var edge1 = v1 - v0;
                var edge2 = v2 - v0;
                var normalVector = Vector3.Cross(edge1, edge2);
                triangle.Area = normalVector.Length / 2.0f;
                triangle.Normal = (UniqueVertices[triangle.V0].Normal + UniqueVertices[triangle.V0].Normal + UniqueVertices[triangle.V0].Normal).Normalized();
                if (triangle.Area > 1e-6f)
                {
                    triangle.Normal = normalVector.Normalized();
                }
                else
                {
                    triangle.Normal = Vector3.Zero;
                }
                Triangles[i] = triangle;
            }
        }
        public void ComputeTriangleAdjacency()
        {
            for (int i = 0; i < Triangles.Count; i++)
            {
                var triangle = Triangles[i];
                var startHeIndex = FaceToHalfEdgeMap[i];
                var he01 = HalfEdges[startHeIndex];
                if (he01.twin != -1)
                {
                    var twinFaceIndex = HalfEdges[he01.twin].face;
                    var twinTriangle = Triangles[twinFaceIndex];
                    var he20_twin_index = HalfEdges[he01.twin].next;
                    var adjVertexIndex = HalfEdges[HalfEdges[he20_twin_index].next].vertex;
                    triangle.AdjV2 = adjVertexIndex;
                }
                else
                {
                    triangle.AdjV2 = -1;
                }
                var he12 = HalfEdges[he01.next];
                if (he12.twin != -1)
                {
                    var twinFaceIndex = HalfEdges[he12.twin].face;
                    var adjVertexIndex = Triangles[twinFaceIndex].V0;
                    triangle.AdjV0 = adjVertexIndex;
                }
                else
                {
                    triangle.AdjV0 = -1;
                }
                var he20 = HalfEdges[he12.next];
                if (he20.twin != -1)
                {
                    var twinFaceIndex = HalfEdges[he20.twin].face;
                    var adjVertexIndex = Triangles[twinFaceIndex].V1;
                    triangle.AdjV1 = adjVertexIndex;
                }
                else
                {
                    triangle.AdjV1 = -1;
                }
                Triangles[i] = triangle;
            }
        }
        private int GetOrAddVertexIndex(Vertex vertex)
        {
            if (VerticesMap.TryGetValue(vertex, out var vid))
            {
                return vid;
            }
            else
            {
                var newVid = VerticesMap.Count;
                VerticesMap[vertex] = newVid;
                UniqueVertices.Add(vertex);
                return newVid;
            }
        }
        public void FindSurfaces()
        {
            bool[] visitedTriangles = new bool[Triangles.Count];
            Surfaces.Clear();
            for (int i = 0; i < Triangles.Count; i++)
            {
                if (!visitedTriangles[i])
                {
                    var currentSurfaceTriangles = new List<int>();
                    var queue = new Queue<int>();
                    var boundaryHalfEdges = new List<int>();
                    Vector3 surfaceWeightedCentroidSum = Vector3.Zero;
                    Vector3 surfaceNormalSum = Vector3.Zero;
                    float surfaceAreaSum = 0.0f;
                    queue.Enqueue(i);
                    visitedTriangles[i] = true;
                    while (queue.Count > 0)
                    {
                        var currentTriangleIndex = queue.Dequeue();
                        currentSurfaceTriangles.Add(currentTriangleIndex);
                        var triangle = Triangles[currentTriangleIndex];
                        surfaceWeightedCentroidSum += triangle.Centroid * triangle.Area;
                        surfaceNormalSum += triangle.Normal * triangle.Area; surfaceAreaSum += triangle.Area;
                        var startHalfEdgeIndex = FaceToHalfEdgeMap[currentTriangleIndex];
                        var heIndex = startHalfEdgeIndex;
                        for (int j = 0; j < 3; j++)
                        {
                            var he = HalfEdges[heIndex];
                            if (he.twin == -1)
                            {
                                boundaryHalfEdges.Add(heIndex);
                            }
                            else
                            {
                                var neighborFaceIndex = HalfEdges[he.twin].face;
                                if (!visitedTriangles[neighborFaceIndex])
                                {
                                    visitedTriangles[neighborFaceIndex] = true;
                                    queue.Enqueue(neighborFaceIndex);
                                }
                            }
                            heIndex = he.next;
                        }
                    }
                    var newSurface = new SurfaceMesh(currentSurfaceTriangles);
                    if (surfaceAreaSum > 1e-6f)
                    {
                        newSurface.Centroid = surfaceWeightedCentroidSum / surfaceAreaSum;
                        if (surfaceNormalSum.LengthSquared > 1e-6f)
                        {
                            newSurface.Normal = surfaceNormalSum.Normalized();
                        }
                        else
                        {
                            newSurface.Normal = Triangles[currentSurfaceTriangles[0]].Normal;
                        }
                        newSurface.Area = surfaceAreaSum;
                        newSurface.BoundaryLoops = FindBoundaryLoops(boundaryHalfEdges, newSurface.Normal);
                        newSurface.FindGeometryCenter(this);
                        Surfaces.Add(newSurface);
                    }
                    else
                    {
                        Console.WriteLine($"Skipping degenerate surface starting at triangle {i} due to zero area.");
                    }
                }
            }
        }

        public List<List<int>> FindBoundaryLoops(List<int> boundaryHalfEdges, Vector3 surfaceNormal)
        {
            var outerLoops = new List<List<int>>();
            var holeLoops = new List<List<int>>();

            var vertexToHalfEdgeMap = new Dictionary<int, int>();
            foreach (var heIndex in boundaryHalfEdges)
            {
                var he = HalfEdges[heIndex];
                var startVertexIndex = HalfEdges[HalfEdges[he.next].next].vertex;
                vertexToHalfEdgeMap[startVertexIndex] = heIndex;
            }

            var visitedHalfEdges = new HashSet<int>();
            foreach (var startHeIndex in boundaryHalfEdges)
            {
                if (visitedHalfEdges.Contains(startHeIndex))
                {
                    continue;
                }

                var currentLoop = new List<int>();
                var currentHeIndex = startHeIndex;

                do
                {
                    visitedHalfEdges.Add(currentHeIndex);
                    var he = HalfEdges[currentHeIndex];
                    var startVertexIndex = HalfEdges[HalfEdges[he.next].next].vertex;
                    currentLoop.Add(startVertexIndex);

                    if (vertexToHalfEdgeMap.TryGetValue(he.vertex, out var nextHalfEdgeIndex))
                    {
                        currentHeIndex = nextHalfEdgeIndex;
                    }
                    else
                    {
                        break;
                    }
                } while (currentHeIndex != startHeIndex && !visitedHalfEdges.Contains(currentHeIndex));

                if (IsHole(currentLoop, surfaceNormal))
                {
                    holeLoops.Add(currentLoop);
                }
                else
                {
                    outerLoops.Add(currentLoop);
                }
            }
            var sortedLoops = new List<List<int>>();
            sortedLoops.AddRange(outerLoops);
            sortedLoops.AddRange(holeLoops);
            return sortedLoops;
        }

        private bool IsHole(List<int> loopVertices, Vector3 surfaceNormal)
        {
            var absNormal = new Vector3(Math.Abs(surfaceNormal.X), Math.Abs(surfaceNormal.Y), Math.Abs(surfaceNormal.Z));
            var majorAxis = 0;
            if (absNormal.Y > absNormal.X && absNormal.Y > absNormal.Z) majorAxis = 1;
            if (absNormal.Z > absNormal.X && absNormal.Z > absNormal.Y) majorAxis = 2;
            float signedArea = 0.0f;
            for (int i = 0; i < loopVertices.Count; i++)
            {
                var v1 = UniqueVertices[loopVertices[i]].Position;
                var v2 = UniqueVertices[loopVertices[(i + 1) % loopVertices.Count]].Position;
                switch (majorAxis)
                {
                    case 0:
                        signedArea += (v1.Y * v2.Z - v2.Y * v1.Z);
                        break;
                    case 1:
                        signedArea += (v1.Z * v2.X - v2.Z * v1.X);
                        break;
                    case 2:
                        signedArea += (v1.X * v2.Y - v2.X * v1.Y);
                        break;
                }
            }
            switch (majorAxis)
            {
                case 0: return Math.Sign(signedArea) != Math.Sign(surfaceNormal.X);
                case 1: return Math.Sign(signedArea) != Math.Sign(surfaceNormal.Y);
                case 2: return Math.Sign(signedArea) != Math.Sign(surfaceNormal.Z);
            }
            return false;
        }
        public void ComputeMeshMetrics()
        {
            TotalVolume = 0.0f;
            Vector3 totalWeightedCentroidSum = Vector3.Zero;
            TotalSurfaceArea = 0.0f;
            for (int i = 0; i < Triangles.Count; i++)
            {
                var triangle = Triangles[i];
                var v0 = UniqueVertices[triangle.V0].Position;
                var v1 = UniqueVertices[triangle.V1].Position;
                var v2 = UniqueVertices[triangle.V2].Position;
                var triangleCentroid = (v0 + v1 + v2) / 3.0f;
                triangle.Centroid = triangleCentroid;
                var edge1 = v1 - v0;
                var edge2 = v2 - v0;
                var normalVector = Vector3.Cross(edge1, edge2);
                var triangleArea = normalVector.Length / 2.0f;
                triangle.Area = triangleArea;
                triangle.Normal = normalVector.Normalized();
                Triangles[i] = triangle;
                TotalVolume += Vector3.Dot(v0, Vector3.Cross(v1, v2));
                TotalSurfaceArea += triangleArea;
                totalWeightedCentroidSum += triangleCentroid * triangleArea;
            }
            TotalVolume = MathF.Abs(TotalVolume / 6.0f);
            if (TotalSurfaceArea > 1e-6f)
            {
                TotalCentroid = totalWeightedCentroidSum / TotalSurfaceArea;
            }
        }
        public Vertex GetVertexByIndex(int index)
        {
            if (index < 0 || index >= UniqueVertices.Count)
            {
                throw new ArgumentOutOfRangeException(nameof(index), "The vertex index is out of range.");
            }
            return UniqueVertices[index];
        }
        public void ComputeAdjacencyInformation()
        {
            for (int i = 0; i < Triangles.Count; i++)
            {
                var currentTriangle = Triangles[i];
                var edge01 = new Eedge(currentTriangle.V0, currentTriangle.V1);
                var edge12 = new Eedge(currentTriangle.V1, currentTriangle.V2);
                var edge20 = new Eedge(currentTriangle.V2, currentTriangle.V0);
                UpdateAdjacency(ref currentTriangle, edge01, i, 0);
                UpdateAdjacency(ref currentTriangle, edge12, i, 1);
                UpdateAdjacency(ref currentTriangle, edge20, i, 2);
                Triangles[i] = currentTriangle;
            }
        }
        private void UpdateAdjacency(ref TrianglesAdjacency triangle, Eedge edge, int currentTriangleIndex, int edgeIndex)
        {
            if (EdgeToTriangleMap.TryGetValue(edge, out var adjacentTriangles) && adjacentTriangles.Count > 1)
            {
                var adjacentIndex = (adjacentTriangles[0] == currentTriangleIndex) ? adjacentTriangles[1] : adjacentTriangles[0];
                var adjacentTriangle = Triangles[adjacentIndex];
                int oppositeVertexIndex;
                if (adjacentTriangle.V0 != edge.V0 && adjacentTriangle.V0 != edge.V1)
                    oppositeVertexIndex = adjacentTriangle.V0;
                else if (adjacentTriangle.V1 != edge.V0 && adjacentTriangle.V1 != edge.V1)
                    oppositeVertexIndex = adjacentTriangle.V1;
                else
                    oppositeVertexIndex = adjacentTriangle.V2;
                switch (edgeIndex)
                {
                    case 0: triangle.AdjV2 = oppositeVertexIndex; break;
                    case 1: triangle.AdjV0 = oppositeVertexIndex; break;
                    case 2: triangle.AdjV1 = oppositeVertexIndex; break;
                }
            }
        }
        public void MergeSurfaces(float positionTolerance = 1e-3f, float normalDotProductThreshold = 0.866f)
        {
            var tempSurfaces = new List<SurfaceMesh>(Surfaces);
            var mergedIndices = new HashSet<int>();
            bool mergedInThisPass;
            do
            {
                mergedInThisPass = false;
                var nextSurfaces = new List<SurfaceMesh>();
                bool[] handled = new bool[tempSurfaces.Count];
                for (int i = 0; i < tempSurfaces.Count; i++)
                {
                    if (handled[i]) continue;
                    SurfaceMesh currentSurface = tempSurfaces[i];
                    bool merged = false;
                    for (int j = i + 1; j < tempSurfaces.Count; j++)
                    {
                        if (handled[j]) continue;
                        if (CanMerge(currentSurface, tempSurfaces[j], positionTolerance, normalDotProductThreshold))
                        {
                            var trianglesToMerge = new List<int>(currentSurface.Triangles);
                            trianglesToMerge.AddRange(tempSurfaces[j].Triangles);
                            var newSurface = new SurfaceMesh(trianglesToMerge);
                            newSurface.RecalculateSurfaceMetrics(this);
                            if (newSurface.Normal.X == float.NaN)
                                break;
                            newSurface.BoundaryLoops = FindBoundaryLoops(GetBoundaryHalfEdgesForSurface(newSurface).ToList(), newSurface.Normal);
                            currentSurface = newSurface;
                            handled[j] = true;
                            merged = true;
                            mergedInThisPass = true;
                        }
                    }
                    nextSurfaces.Add(currentSurface);
                    handled[i] = true;
                }
                tempSurfaces = nextSurfaces;
            } while (mergedInThisPass);
            Surfaces = tempSurfaces;
            foreach (var s in Surfaces)
            {
                s.GetSurfaceNormalsCount(this);
            }
        }
        public void SortSurfacesByArea()
        {
            Surfaces = Surfaces.OrderByDescending(s => s.Area).ToList();
        }
        private IEnumerable<int> GetBoundaryHalfEdgesForSurface(SurfaceMesh surface)
        {
            var boundaryHalfEdges = new List<int>();
            foreach (var triangleIndex in surface.Triangles)
            {
                boundaryHalfEdges.AddRange(GetBoundaryHalfEdgesForTriangle(triangleIndex));
            }
            return boundaryHalfEdges.Distinct();
        }
        private bool CanMerge(SurfaceMesh surface1, SurfaceMesh surface2, float posTolerance, float normalThreshold)
        {
            foreach (var loop1 in surface1.BoundaryLoops)
            {
                foreach (var loop2 in surface2.BoundaryLoops)
                {
                    if (loop1.Count != loop2.Count) continue;
                    for (int k = 0; k < loop1.Count; k++)
                    {
                        var v1a = UniqueVertices[loop1[k]].Position;
                        var v1b = UniqueVertices[loop1[(k + 1) % loop1.Count]].Position;
                        for (int l = 0; l < loop2.Count; l++)
                        {
                            var v2a = UniqueVertices[loop2[l]].Position;
                            var v2b = UniqueVertices[loop2[(l + 1) % loop2.Count]].Position;
                            if ((Vector3.Distance(v1a, v2a) < posTolerance && Vector3.Distance(v1b, v2b) < posTolerance) ||
                                (Vector3.Distance(v1a, v2b) < posTolerance && Vector3.Distance(v1b, v2a) < posTolerance))
                            {
                                var normalDot = Vector3.Dot(surface1.Normal, surface2.Normal);
                                return normalDot > normalThreshold;
                            }
                        }
                    }
                }
            }
            return false;
        }
        private IEnumerable<int> GetBoundaryHalfEdgesForTriangle(int triangleIndex)
        {
            var startHeIndex = FaceToHalfEdgeMap[triangleIndex];
            var heIndex = startHeIndex;
            for (int j = 0; j < 3; j++)
            {
                var he = HalfEdges[heIndex];
                if (he.twin == -1)
                {
                    yield return heIndex;
                }
                heIndex = he.next;
            }
        }
        public class NormalEqualityComparer : IEqualityComparer<Vector3>
        {
            private readonly float _threshold;
            public NormalEqualityComparer(float threshold)
            {
                _threshold = threshold;
            }
            public bool Equals(Vector3 v1, Vector3 v2)
            {
                return Vector3.Dot(v1.Normalized(), v2.Normalized()) >= _threshold;
            }
            public int GetHashCode(Vector3 obj)
            {
                return obj.X.GetHashCode() ^ obj.Y.GetHashCode() ^ obj.Z.GetHashCode();
            }
        }
    }
}