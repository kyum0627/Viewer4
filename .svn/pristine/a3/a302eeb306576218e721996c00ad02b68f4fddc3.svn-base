using IGX.Geometry.Common;
using OpenTK.Mathematics;
using System;
using System.Collections.Generic;

namespace IGX.Geometry.GeometryBuilder
{
    public static class LineStringTubeBuilder
    {
        /// <summary>
        /// LineString을 따라 각 세그먼트를 실린더로 만들어 튜브(mesh) 생성
        /// </summary>
        /// <param name="points">LineString 좌표</param>
        /// <param name="radius">튜브 반경</param>
        /// <param name="circleSegments">단면 원의 세그먼트 수</param>
        /// <param name="bCap">양 끝 Cap 생성 여부</param>
        /// <returns>Vertices, Normals, Indices</returns>
        public static (List<Vector3> vertices, List<Vector3> normals, List<int> indices)
            BuildLineStringTube(List<Vector3> points, float radius = 0.1f, int circleSegments = 12, bool bCap = true)
        {
            var vertices = new List<Vector3>();
            var normals = new List<Vector3>();
            var indices = new List<int>();

            if (points == null || points.Count < 2)
                return (vertices, normals, indices);

            Vector3 up = Vector3.UnitZ;
            int vertexOffset = 0;

            for (int i = 0; i < points.Count - 1; i++)
            {
                Vector3 p0 = points[i];
                Vector3 p1 = points[i + 1];
                Vector3 tangent = (p1 - p0).Normalized();

                // 임의 직교 벡터
                Vector3 normal0 = Vector3.Cross(tangent, up).LengthSquared > 1e-6 ? Vector3.Cross(tangent, up).Normalized() : Vector3.UnitX;
                Vector3 binormal0 = Vector3.Cross(tangent, normal0).Normalized();

                // 각 세그먼트 시작점
                for (int j = 0; j < circleSegments; j++)
                {
                    float theta = j / (float)circleSegments * MathF.Tau;
                    Vector3 offset = normal0 * MathF.Cos(theta) * radius + binormal0 * MathF.Sin(theta) * radius;
                    vertices.Add(p0 + offset);
                    normals.Add(offset.Normalized());
                }

                // 각 세그먼트 끝점
                for (int j = 0; j < circleSegments; j++)
                {
                    float theta = j / (float)circleSegments * MathF.Tau;
                    Vector3 offset = normal0 * MathF.Cos(theta) * radius + binormal0 * MathF.Sin(theta) * radius;
                    vertices.Add(p1 + offset);
                    normals.Add(offset.Normalized());
                }

                // 세그먼트 측면 삼각형
                for (int j = 0; j < circleSegments; j++)
                {
                    int next = (j + 1) % circleSegments;

                    int start0 = vertexOffset + j;
                    int start1 = vertexOffset + circleSegments + j;
                    int end0 = vertexOffset + next;
                    int end1 = vertexOffset + circleSegments + next;

                    indices.Add(start0);
                    indices.Add(start1);
                    indices.Add(end1);

                    indices.Add(start0);
                    indices.Add(end1);
                    indices.Add(end0);
                }

                vertexOffset += 2 * circleSegments;
            }

            if (bCap)
            {
                // --- Start Cap ---
                int startCenterIndex = vertices.Count;
                vertices.Add(points[0]);
                normals.Add(-(points[1] - points[0]).Normalized());

                for (int j = 0; j < circleSegments; j++)
                {
                    int next = (j + 1) % circleSegments;
                    indices.Add(startCenterIndex);
                    indices.Add(j + 1 < circleSegments ? j + 1 : 0);
                    indices.Add(j);
                }

                // --- End Cap ---
                int endCenterIndex = vertices.Count;
                vertices.Add(points[^1]);
                normals.Add((points[^1] - points[^2]).Normalized());

                int endOffset = vertices.Count - circleSegments - 1; // 마지막 세그먼트 시작 인덱스
                for (int j = 0; j < circleSegments; j++)
                {
                    int next = (j + 1) % circleSegments;
                    indices.Add(endCenterIndex);
                    indices.Add(endOffset + j);
                    indices.Add(endOffset + next);
                }
            }

            return (vertices, normals, indices);
        }
    }
}