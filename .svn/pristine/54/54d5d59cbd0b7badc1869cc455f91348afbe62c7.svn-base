using IGX.ViewControl.Buffer;
using IGX.ViewControl.Render.Materials;
using OpenTK.Graphics.OpenGL4;

namespace IGX.ViewControl.Render
{
    /// <summary>
    /// SSBO 기반 인스턴스 버퍼와 간접 드로잉 커맨드 버퍼를 결합한 클래스
    /// </summary>
    public class SsboIndirectCommandBuffer<TVertex, TIndex, TInstance> : IDisposable
        where TVertex : struct where TIndex : struct where TInstance : struct
    {
        private readonly DrawElementsInstancedBaseInstance<TVertex, TIndex, TInstance> buffer;
        private readonly IndirectBuffer<DrawElementsIndirectCommand> _indirectCommands;
        private bool _isDisposed = false;

        public int CommandCount => _indirectCommands.Count;
        public int InstanceCount => buffer.InstanceArrayCount;

        private readonly object _bufferLock = new();

        /// <summary>
        /// 생성자: SSBO 기반 인스턴스 버퍼와 간접 드로잉 커맨드 버퍼를 초기화합니다.
        /// </summary>
        /// <param name="vertices">정점 데이터</param>
        /// <param name="indices">인덱스 데이터</param>
        /// <param name="commands">간접 드로잉 커맨드 데이터</param>
        /// <param name="instances">인스턴스 데이터</param>
        /// <param name="instanceSSBOBindingIndex">인스턴스 SSBO에 바인딩할 인덱스</param>
        /// <param name="vertexHint">정점 버퍼 힌트</param>
        /// <param name="indexHint">인덱스 버퍼 힌트</param>
        /// <param name="commandHint">커맨드 버퍼 힌트</param>
        /// <param name="instanceHint">인스턴스 버퍼 힌트</param>
        public SsboIndirectCommandBuffer(
            ReadOnlySpan<TVertex> vertices,
            ReadOnlySpan<TIndex> indices,
            ReadOnlySpan<DrawElementsIndirectCommand> commands,
            ReadOnlySpan<TInstance> instances,
            int instanceSSBOBindingIndex,
            BufferUsageHint vertexHint = BufferUsageHint.StaticDraw,
            BufferUsageHint indexHint = BufferUsageHint.StaticDraw,
            BufferUsageHint commandHint = BufferUsageHint.StaticDraw,
            BufferUsageHint instanceHint = BufferUsageHint.DynamicDraw)
        {
            if (vertices.IsEmpty) throw new ArgumentException("Vertex data cannot be empty.", nameof(vertices));
            if (indices.IsEmpty) throw new ArgumentException("Index data cannot be empty.", nameof(indices));
            if (commands.IsEmpty) throw new ArgumentException("Command data cannot be empty.", nameof(commands));
            if (instances.IsEmpty) throw new ArgumentException("Instance data cannot be empty.", nameof(instances));

            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot create MultiDrawElementsIndirect without an active OpenGL context.");
            }

            try
            {
                // DrawElementsInstanced 대신 DrawElementsInstancedBaseInstance 사용
                buffer = new DrawElementsInstancedBaseInstance<TVertex, TIndex, TInstance>(
                    vertices, indices, instances, instanceSSBOBindingIndex, vertexHint, indexHint, instanceHint);

                lock (_bufferLock)
                {
                    // 간접 커맨드 버퍼 초기화
                    _indirectCommands = new IndirectBuffer<DrawElementsIndirectCommand>(commands.ToArray(), commandHint);
                }
                CheckGLError();
            }
            catch (Exception ex)
            {
                buffer?.Dispose();
                throw new InvalidOperationException("Failed to initialize SsboIndirectCommandBuffer.", ex);
            }
        }

        // 기존과 동일한 Draw 함수
        public void Draw(PrimitiveType type)
        {
            if (_isDisposed) throw new ObjectDisposedException(nameof(SsboIndirectCommandBuffer<TVertex, TIndex, TInstance>));
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot draw without an active OpenGL context.");
            }

            lock (_bufferLock)
            {
                buffer.Bind();
                _indirectCommands.Bind();
                GL.MultiDrawElementsIndirect(
                    type,
                    buffer.ElementType,
                    nint.Zero,
                    CommandCount,
                    0);
                CheckGLError();
                buffer.Unbind();
                _indirectCommands.Unbind();
            }
        }

        // 모든 데이터 업데이트 함수는 내부 버퍼를 호출
        public void UpdateVertices(int startIndex, ReadOnlySpan<TVertex> newVertexData) => buffer.UpdateVertices(startIndex, newVertexData);
        public void UpdateVertices(ReadOnlySpan<TVertex> newVertexData) => buffer.UpdateVertices(0, newVertexData);
        public void UpdateIndices(ReadOnlySpan<TIndex> indices) => buffer.UpdateIndices(0, indices);
        public void UpdateInstances(ReadOnlySpan<TInstance> instances) => buffer.UpdateInstanceData(instances);
        public void UpdateCommands(ReadOnlySpan<DrawElementsIndirectCommand> commands) => _indirectCommands.UpdateData(commands);
        public void UpdateSingleVertex(int vertexIndex, TVertex newVertexData) => buffer.UpdateSingleVertex(vertexIndex, newVertexData);
        public void UpdateSingleInstance(int index, TInstance instance) => buffer.UpdateSingleInstance(index, instance);

        // 크기 변경 함수도 내부 버퍼의 함수를 호출
        public void ResizeInstanceBuffer(int newSize) => buffer.ResizeInstanceBuffer(newSize);
        public void ResizeCommandBuffer(int newSize) => _indirectCommands.Resize(newSize);
        public void RemoveInstance(int index) => buffer.RemoveInstance(index);
        public void AddInstance(TInstance instance) => buffer.AddInstance(instance);

        // Bind/Unbind 함수
        public void Bind()
        {
            if (_isDisposed) throw new ObjectDisposedException(nameof(SsboIndirectCommandBuffer<TVertex, TIndex, TInstance>));
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot bind buffers without an active OpenGL context.");
            }
            lock (_bufferLock)
            {
                buffer.Bind();
                _indirectCommands.Bind();
            }
        }

        public void Unbind()
        {
            lock (_bufferLock)
            {
                buffer.Unbind();
                _indirectCommands.Unbind();
            }
        }

        // IDisposable 패턴 구현
        protected virtual void Dispose(bool disposing)
        {
            if (_isDisposed) return;
            if (disposing)
            {
                buffer?.Dispose();
                _indirectCommands?.Dispose();
            }
            _isDisposed = true;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        ~SsboIndirectCommandBuffer()
        {
            Dispose(false);
        }

        private static bool IsContextLikelyActive()
        {
            try { GL.GetError(); return true; } catch { return false; }
        }

        private static void CheckGLError()
        {
            var error = GL.GetError();
            if (error != ErrorCode.NoError)
            {
                throw new InvalidOperationException($"OpenGL error: {error}");
            }
        }
    }
}