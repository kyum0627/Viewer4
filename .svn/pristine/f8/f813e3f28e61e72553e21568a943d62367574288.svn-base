using System;
using OpenTK.Mathematics;

/// <summary>
/// 참고 : https://www.geometrictools.com/
/// </summary>
namespace IGX.Geometry.Common
{
    public enum CircleCalculationOption
    {
        None,        // 외접원도 내접원도 계산하지 않음
        Circumscribed, // 외접원만 계산
        Inscribed,    // 내접원만 계산
        Both         // 외접원과 내접원 모두 계산
    }

    public class Circle3 : IEquatable<Circle3>
    {
        public Vector3 center;
        public Plane3f plane;
        public Vector3 axisX, axisY;

        public float radius;
        public bool isReversed;

        public float Length { get { return MathUtil.ThirdPi * radius; } }
        public float Area { get { return MathUtil.Pi * radius * radius; } }
        public float Diameter { get { return 2 * radius; } }

        public readonly bool HasArcLength = true;
        public readonly bool IsClosed = true;

        /// <summary>
        /// 원의 둘레
        /// </summary>
        public float PeripheralLength { get { return MathUtil.TwoPi * radius; } }

        public Circle3(Vector3 P1, Vector3 P2, Vector3 P3, CircleCalculationOption option = CircleCalculationOption.Both)
        {
            // 세 점을 기준으로 벡터 계산
            Vector3 p1_2 = P1 - P2;
            Vector3 p2_3 = P2 - P3;
            Vector3 p3_1 = P3 - P1;

            // 변의 길이 제곱 계산 (한 번만 계산)
            float aa = p3_1.LengthSquared;
            float bb = p1_2.LengthSquared;
            float cc = p2_3.LengthSquared;

            // 변의 길이 계산 (반드시 길이 제곱을 기반으로 계산)
            float a = (float)Math.Sqrt(aa);
            float b = (float)Math.Sqrt(bb);
            float c = (float)Math.Sqrt(cc);

            // 가중치 계산 (중간 값 계산)
            float alpha = a * (bb + cc - aa);
            float beta = b * (cc + aa - bb);
            float gamma = c * (aa + bb - cc);

            // 외적 계산 (p1_2와 p2_3 벡터)
            Vector3 crossProduct = Vector3.Cross(p1_2, p2_3);

            // 삼각형 면적 계산 (외적의 크기 / 2)
            float area = 0.5f * crossProduct.Length;

            // 면적이 매우 작으면 (0에 가까우면) 반지름을 계산할 수 없음
            if (area < 1e-6f)
            {
                // 삼각형이 일직선상에 있을 때 반지름을 계산할 수 없으므로 처리
                radius = 0;
                center = Vector3.Zero;
                return;
            }

            // 옵션에 따라 반지름 계산
            if (option == CircleCalculationOption.Circumscribed || option == CircleCalculationOption.Both)
            {
                // 외접원 반지름 계산 (외접원의 반지름 공식)
                radius = (a * b * c) / (4.0f * area);

                // 외접원 중심 (외심) 계산
                center = GetCircumCenter(P1, P2, P3);
            }

            if (option == CircleCalculationOption.Inscribed || option == CircleCalculationOption.Both)
            {
                // 내접원 반지름 계산 (내접원의 반지름 공식)
                float semiPerimeter = (a + b + c) / 2.0f;  // 반둘레 계산
                radius = area / semiPerimeter;

                // 내접원 중심 (내심) 계산
                center = GetInCenter(P1, P2, P3);
            }

            // 중심 계산 (가중 평균)
            float invSum = 1.0f / (alpha + beta + gamma);

            // 평면의 법선 벡터 계산
            plane.normal = Vector3.Normalize(crossProduct);
            plane.constant = Vector3.Dot(plane.normal, P1);
        }

        // 외심 계산 (외접원의 중심)
        private Vector3 GetCircumCenter(Vector3 P1, Vector3 P2, Vector3 P3)
        {
            // 길이 제곱을 미리 계산하여 성능을 최적화
            float a2 = P1.LengthSquared;
            float b2 = P2.LengthSquared;
            float c2 = P3.LengthSquared;

            // 외접원의 중심 계산
            float d = 2 * ((P1.X * (P2.Y - P3.Y)) + (P2.X * (P3.Y - P1.Y)) + (P3.X * (P1.Y - P2.Y)));

            float ux = (((a2) * (P2.Y - P3.Y)) + ((b2) * (P3.Y - P1.Y)) + ((c2) * (P1.Y - P2.Y))) / d;
            float uy = (((a2) * (P3.X - P2.X)) + ((b2) * (P1.X - P3.X)) + ((c2) * (P2.X - P1.X))) / d;

            return new Vector3(ux, uy, 0); // 2D 평면에서 계산한다고 가정
        }

        // 내심 계산 (내접원의 중심)
        private Vector3 GetInCenter(Vector3 P1, Vector3 P2, Vector3 P3)
        {
            // 각 변의 길이 계산
            float a = (P2 - P3).Length;
            float b = (P3 - P1).Length;
            float c = (P1 - P2).Length;

            // 내심은 가중 평균을 이용하여 계산
            float p = a + b + c; // 삼각형의 둘레
            float x = ((a * P1.X) + (b * P2.X) + (c * P3.X)) / p;
            float y = ((a * P1.Y) + (b * P2.Y) + (c * P3.Y)) / p;

            return new Vector3(x, y, 0); // 2D 평면에서 계산한다고 가정
        }
        public (Plane3f pln, Vector3 center, float radius) Outside(Vector3 P1, Vector3 P2, Vector3 P3)
        {
            Plane3f pln = new(P1, P2, P3);
            // 3D 점들을 평면에 투영
            Vector2 p1 = P1.ProjectToPlane(pln);
            Vector2 p2 = P2.ProjectToPlane(pln);
            Vector2 p3 = P3.ProjectToPlane(pln);

            // 2D 평면에서 외접원 계산
            Circle2 c2 = new();
            (Vector2 c, float r) = c2.Outside(p1, p2, p3); // p1ID, p2, p3의 외접원 계산

            // 외접원 중심을 3D로 변환
            center = c.ProjectBackTo3D(pln); // 2D 좌표를 3D 평면에 투영하여 변환
            radius = r;
            return (pln, center, radius);
        }
        public (Plane3f plane, Vector3 center, float radius) Inside(Vector3 P1, Vector3 P2, Vector3 P3)
        {
            Plane3f pln = new(P1, P2, P3);
            // 3D 점들을 평면에 투영
            Vector2 p1 = P1.ProjectToPlane(pln);
            Vector2 p2 = P2.ProjectToPlane(pln);
            Vector2 p3 = P3.ProjectToPlane(pln);

            // 2D 평면에서 내접원 계산
            Circle2 c2 = new();
            (Vector2 c, float r) = c2.Inside(p1, p2, p3); // p1ID, p2, p3의 외접원 계산

            // 외접원 중심을 3D로 변환
            center = c.ProjectBackTo3D(pln); // 2D 좌표를 3D 평면에 투영하여 변환
            radius = r;
            return (pln, center, radius);
        }

        public Circle3(Vector3 P1, Vector3 P2, Vector3 P3, bool bOutside = true)
        {
            if (bOutside)
            {
                (plane, center, radius) = Outside(P1, P2, P3);
            }
            else
            {
                (plane, center, radius) = Inside(P1, P2, P3);
            }
        }
        public Circle3(Vector3 c, Vector3 axisX, Vector3 axisY, float r)
        {
            isReversed = false;
            center = c;

            if (r > 0)
            {
                radius = r;
            }
            else
            {
                radius = (axisY - c).Length;
            }

            plane.normal = Vector3.Normalize(Vector3.Cross(axisX - c, axisY - c));
            plane.constant = Vector3.Dot(plane.normal, c);
            plane.normal.MakeUVnormalsFromW(out axisY, out plane.normal);

            //hschoi : 20240215 추가
            this.axisX = axisX;
            this.axisY = axisY;
        }
        public Circle3(Vector3 center, float radius)
        {
            plane = new Plane3f(Vector3.UnitZ, center.Z);
            this.center = center;
            this.radius = radius;
        }

        /// <summary>
        /// radian to degree [ 0, 360 ]
        /// </summary>
        /// <param name="degrees"></param>
        /// <returns></returns>
        public Vector3 GetPointAtAngle(float degrees)
        {
            float theta = degrees * MathUtil.Deg2Rad;
            float cos = (float)Math.Cos(theta);
            float sin = (float)Math.Sin(theta);
            return center + (cos * radius * axisX) + (sin * radius * axisY);
        }

        /// <summary>
        /// 원 주위 parameter t에서의 점의 좌표
        /// </summary>
        /// <param name="t">range[0, 1]</param>
        /// <returns></returns>
        public Vector3 GetPointAtPamameter(float t)
        {
            float theta = isReversed ? -t * MathUtil.TwoPi : t * MathUtil.TwoPi;
            float cos = (float)Math.Cos(theta);
            float sin = (float)Math.Sin(theta);
            return center + (cos * radius * axisX) + (sin * radius * axisY);
        }

        /// <summary>
        /// 원의 시작점에서 원을 따라 a 만큼 이동한 원의 parameter
        /// </summary>
        /// <param name="a"></param>
        /// <returns></returns>
		public Vector3 GetParameterALength(float a)
        {
            float t = a % Length; // a의 절대값이 원 둘레보다 큰 경우 clamping
            float theta = isReversed ? -t * (float)MathUtil.TwoPId : t * (float)MathUtil.TwoPId;
            float cos = (float)Math.Cos(theta);
            float sin = (float)Math.Sin(theta);
            return center + (cos * radius * axisX) + (sin * radius * axisY);
        }

        public void Reverse()
        {
            isReversed = !isReversed;
        }

        public bool Equals(Circle3 c, float tolerance)
        {
            return tolerance < 0
                ? throw new ArgumentException("epsilon < 0")
                : Math.Abs(c.radius - radius) < tolerance &&
                   center.Equals(c.center) &&
                   plane.Equals(c.plane);
        }

        public bool Equals(Circle3? c) => radius.Equals(c!.radius) && center.Equals(c!.center);

        public override bool Equals(object? obj)
        {
            if (obj is null || !(obj is Circle2))
            {
                return false;
            }

            Circle3 c = (Circle3)obj;

            // Compare all fields including tolerance for Radius and center
            return Math.Abs(c.radius - radius) < float.Epsilon &&
                   center.Equals(c.center) &&
                   plane.Equals(c.plane);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hash = (int)2166136261;
                // Suitable nullity checks etc, of course :)
                hash = (hash * 16777619) ^ center.GetHashCode();
                hash = (hash * 16777619) ^ radius.GetHashCode();
                hash = (hash * 16777619) ^ plane.GetHashCode();
                return hash;
            }
        }
    }
}
