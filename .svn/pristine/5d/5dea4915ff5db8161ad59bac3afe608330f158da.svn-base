using IGX.Geometry.DataStructure;
using IGX.Geometry.GeometryBuilder;
using IGX.ViewControl.Render.ClipPlane;
using IGX.ViewControl.Render.Materials;
using OpenTK.GLControl;
using OpenTK.Graphics.OpenGL4;
using OpenTK.Mathematics;
using static System.Windows.Forms.VisualStyles.VisualStyleElement;

namespace IGX.ViewControl.Render
{
    /// <summary>
    /// 보조 렌더링 패스들을 총괄하는 클래스.
    /// </summary>
    internal class RendererAuxilliary : IRenderer
    {
        private readonly IgxViewAPI _apis;
        //private readonly SceneManager _ sceneManager;
        private readonly GLControl _glControl;

        // 각 보조 렌더링 기능을 독립된 패스로 분리
        private BackGroundRenderer? infogetLogo;
        private RendererVector arrow;
        private ObjectBoxRenderer? objectBox;
        private ClipPlaneSystem? clippingBox;
        private RendererNormalVectors _normalVectors;
        private RendererCoordinates _coordinates;
        private DrawElementsIndirect<Vertex, uint, MatColInstance> _designed;
        private SceneParameters SceneParameters => _apis.Scene;
        private AuxillaryDrawSetting DrawWhat => _apis.Drawing;
        private SelectionManager Selection => _apis.SelectionManager;

        public RendererAuxilliary(IgxViewAPI apis, GLControl glControl)
        {
            _apis = apis;
            _glControl = glControl;
        }
        RendererInstancedMesh<Vertex, uint, MatColInstance> _arrowMeshIndex;
        RendererVector arrowsInstanced;
        public void Initialize(int width, int height)
        {
            _glControl.MakeCurrent();

            // 각 보조 렌더링 클래스 초기화
            infogetLogo = new BackGroundRenderer();

            var (vertices, indices, instances) = ArrowData.GeneratePareneMesh();
            ReadOnlySpan<MatColInstance> initialinstance = new MatColInstance[100];
            _arrowMeshIndex = new RendererInstancedMesh<Vertex, uint, MatColInstance>(vertices.ToArray(), indices.ToArray(), initialinstance);
            arrowsInstanced = new RendererVector(_arrowMeshIndex, instances);
            
            Shader shader = new Shader(ShaderSource.VertexShaderSourceInstancedAttrib, ShaderSource.FragmentShaderSourceInstancedAttrib, false);
            _normalVectors = new RendererNormalVectors(arrowsInstanced, shader);
            var coordinstances = new MatColInstance[3];

            _coordinates = new RendererCoordinates(vertices.ToArray(), indices.ToArray(), coordinstances.ToArray(), shader);
            objectBox = new ObjectBoxRenderer();
            clippingBox = new ClipPlaneSystem(SceneParameters.Camera);
        }

        public void Draw(IMyCamera camera, bool drawClipplane)
        {
            // 보조 렌더링은 후처리 패스 이후에 그려지므로 깊이 테스트를 다시 활성화
            GL.Enable(EnableCap.DepthTest);
            GL.DepthMask(true);
            GL.Disable(EnableCap.Blend);

            if (DrawWhat.CompanyLogo)
            {// 배경 그리기
                infogetLogo!.Draw(_glControl.Width, _glControl.Height);
            }

            if (DrawWhat.Coordinates)
            {// 좌표계 그리기
                _coordinates.Draw(camera, SceneParameters.CoordinatePosition, 1);
            }

            if (Selection.PickedItems.Count > 0)
            {// 선택된 객체 그리기
                Selection.SelectedObjectsDetails(DrawWhat.BoxIsOOBB);
                // 선택된 객체 박스는 항상 맨 위에 그려져야 하므로 깊이 테스트 비활성화
                GL.Enable(EnableCap.DepthTest);
                GL.DepthMask(true);
                if (DrawWhat.ObjectBox)
                {
                    objectBox!.Render(Selection.BoxesToDraw, camera, SceneParameters.BoxColor);
                }
                if (DrawWhat.Normals)
                {
                    _normalVectors.Renderer(Selection.NormalsToDraw, camera, SceneParameters.VectorColor, SceneParameters.VectorSize);
                }
            }

            if (DrawWhat.ClipPlanes && drawClipplane)
            {// 클립 볼륨 그리기
                clippingBox!.ResetBox(SceneParameters.TotalBoundingBox);
                clippingBox!.Draw(camera);
            }
        }

        public void Resize(int width, int height)
        {
            // AuxiliarySceneManager의 자식들은 Resize 메서드가 필요 없음 (현재 로직상)
            // 필요한 경우 여기에 로직 추가 가능
        }

        public void Dispose()
        {
            infogetLogo?.Dispose();
            //drawVectors?.Dispose();
            objectBox?.Dispose();
            clippingBox?.Dispose();
        }
    }
}