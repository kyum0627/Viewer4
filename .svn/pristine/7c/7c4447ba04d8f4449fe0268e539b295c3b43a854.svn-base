using IGX.ViewControl.Buffer;
using OpenTK.Graphics.OpenGL4;
using System.Runtime.CompilerServices;

namespace IGX.ViewControl.Render
{
    public class DrawElementsInstanced<TVertex, TIndex, TInstance> : IDisposable
        where TVertex : struct where TIndex : struct where TInstance : struct
    {
        public int VAO => _elementBuffer.VAO;
        private readonly ElementBuffer<TVertex, TIndex> _elementBuffer;
        private readonly ArrayBuffer<TInstance> _instanceBuffer;
        private bool _isDisposed = false;

        public int InstanceArrayCount => _instanceBuffer.Count;
        public DrawElementsType ElementType => _elementBuffer.ElementType;

        private readonly object _vaoLock = new();

        public DrawElementsInstanced(
            ReadOnlySpan<TVertex> vertices,
            ReadOnlySpan<TIndex> indices,
            ReadOnlySpan<TInstance> instances,
            BufferUsageHint vertexHint = BufferUsageHint.DynamicDraw,
            BufferUsageHint indexHint = BufferUsageHint.DynamicDraw,
            BufferUsageHint instanceHint = BufferUsageHint.DynamicDraw)
        {
            if (vertices.IsEmpty) throw new ArgumentException("Vertex data cannot be empty.", nameof(vertices));
            if (indices.IsEmpty) throw new ArgumentException("Index data cannot be empty.", nameof(indices));
            if (instances.IsEmpty) throw new ArgumentException("Instance data cannot be empty.", nameof(instances));

            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot create DrawElementsInstanced without an active OpenGL context.");
            }

            try
            {
                _elementBuffer = new ElementBuffer<TVertex, TIndex>(vertices, indices, vertexHint, indexHint);
                lock (_vaoLock)
                {
                    Bind();
                    _instanceBuffer = new ArrayBuffer<TInstance>(instances.ToArray(), instanceHint, keepCpuData: true);
                    _instanceBuffer.SetAttributes();
                    Unbind();
                }
                CheckGLError();
            }
            catch (Exception ex)
            {
                _elementBuffer?.Dispose();
                throw new InvalidOperationException("Failed to initialize DrawElementsInstanced.", ex);
            }
        }

        public void Draw(PrimitiveType primitiveType)
        {
            if (_isDisposed) throw new ObjectDisposedException(nameof(DrawElementsInstanced<TVertex, TIndex, TInstance>));
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot draw without an active OpenGL context.");
            }

            lock (_vaoLock)
            {
                Bind();
                GL.DrawElementsInstanced(primitiveType, _elementBuffer.IndexCount, _elementBuffer.ElementType, nint.Zero, _instanceBuffer.Count);
                CheckGLError();
                Unbind();
            }
        }

        public void ResizeInstanceBuffer(int newSize)
        {
            if (_isDisposed) throw new ObjectDisposedException(nameof(DrawElementsInstanced<TVertex, TIndex, TInstance>));
            if (newSize < InstanceArrayCount) throw new ArgumentException("New size cannot be smaller than the current instance count.", nameof(newSize));

            lock (_vaoLock)
            {
                Bind();
                _instanceBuffer.Resize(newSize);
                Unbind();
            }
        }

        public void RemoveInstance(int index)
        {
            if (_isDisposed || index < 0 || index >= InstanceArrayCount) return;

            var cpuData = _instanceBuffer.CpuData;
            if (cpuData.IsEmpty) return;

            for (int i = index; i < cpuData.Length - 1; i++)
            {
                cpuData[i] = cpuData[i + 1];
            }

            lock (_vaoLock)
            {
                Bind();
                _instanceBuffer.Resize(InstanceArrayCount - 1); Unbind();
            }
        }

        public void AddInstance(TInstance instance)
        {
            if (_isDisposed) return;

            lock (_vaoLock)
            {
                Bind();
                _instanceBuffer.Resize(InstanceArrayCount + 1);
                _instanceBuffer.UpdateInstance(InstanceArrayCount - 1, instance);
                Unbind();
            }
        }

        public void UpdateInstanceData(ReadOnlySpan<TInstance> instances)
        {
            if (_isDisposed) return;

            lock (_vaoLock)
            {
                Bind();
                _instanceBuffer.UpdateData(instances, 0);
                Unbind();
            }
        }

        public void UpdateSingleInstance(int index, TInstance instance)
        {
            if (_isDisposed) return;

            lock (_vaoLock)
            {
                Bind();
                _instanceBuffer.UpdateInstance(index, instance);
                Unbind();
            }
        }

        public void UpdateVertices(int startIndex, ReadOnlySpan<TVertex> newVertexData)
        {
            if (_isDisposed) return;

            lock (_vaoLock)
            {
                Bind();
                _elementBuffer.UpdateVertices(startIndex, newVertexData);
                Unbind();
            }
        }
        public void UpdateIndices(int startIndex, ReadOnlySpan<TIndex> newIndices)
        {
            if (_isDisposed) return;

            lock (_vaoLock)
            {
                Bind();
                _elementBuffer.UpdateIndices(startIndex, newIndices);
                Unbind();
            }
        }

        public void UpdateSingleVertex(int vertexIndex, TVertex newVertexData)
        {
            if (_isDisposed) return;

            lock (_vaoLock)
            {
                Bind();
                _elementBuffer.UpdateSingleVertex(vertexIndex, newVertexData);
                Unbind();
            }
        }

        public void UpdateInstanceBuffer(TInstance[] instanceData, int offset, int count)
        {
            if (_isDisposed) throw new ObjectDisposedException(nameof(DrawElementsInstanced<TVertex, TIndex, TInstance>));
            if (offset < 0 || count <= 0 || offset + count > instanceData.Length)
            {
                throw new ArgumentException("Invalid offset or count.", nameof(instanceData));
            }

            lock (_vaoLock)
            {
                Bind();
                _instanceBuffer.UpdateData(instanceData.AsSpan(offset, count), offset * Unsafe.SizeOf<TInstance>());
                Unbind();
            }
        }

        public ReadOnlySpan<TInstance> GetData()
        {
            if (_isDisposed) throw new ObjectDisposedException(nameof(DrawElementsInstanced<TVertex, TIndex, TInstance>));
            return _instanceBuffer.GetData();
        }

        public void Bind()
        {
            if (_isDisposed) throw new ObjectDisposedException(nameof(DrawElementsInstanced<TVertex, TIndex, TInstance>));
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot bind VAO without an active OpenGL context.");
            }
            _elementBuffer.Bind();
        }

        public void Unbind()
        {
            _elementBuffer.Unbind();
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_isDisposed) return;

            if (disposing)
            {
                _elementBuffer.Dispose();
                _instanceBuffer.Dispose();
            }

            _isDisposed = true;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        ~DrawElementsInstanced()
        {
            Dispose(false);
        }

        private static bool IsContextLikelyActive()
        {
            try
            {
                GL.GetError();
                return true;
            }
            catch
            {
                return false;
            }
        }

        private static void CheckGLError()
        {
            var error = GL.GetError();
            if (error != ErrorCode.NoError)
            {
                throw new InvalidOperationException($"OpenGL error: {error}");
            }
        }
    }
}