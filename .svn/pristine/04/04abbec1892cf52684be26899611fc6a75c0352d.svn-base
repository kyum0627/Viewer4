using System;
using System.Collections.Generic;
using OpenTK.Mathematics;
using IGX.Geometry.Common;

namespace IGX.Geometry.Intersect
{
    public class IntersectLine2Segment2
    {
        Line2f line;
        Segment2f segment;

        public IntersectionResult2 result;

        public IntersectLine2Segment2(Line2f L, Segment2f seg)
        {
            line = L;
            segment = seg;
        }

        /// <summary>
        /// 교차점 계산
        /// </summary>
        /// <returns></returns>
        public bool Compute(float eps = MathUtil.Epsilon)
        {
            // 이미 계산된 놈인지 ??  
            if (result.status != IntersectionResult.NOTCOMPUTED)
            {
                return result.status == IntersectionResult.INTERSECT;
            }

            // 아직 계산 안한 놈만, line이나 segment의 direction이 단위 벡터가 아니면 사용 방법 오류 return
            if (!line.direction.IsNormalized() || !segment.direction.IsNormalized())
            {
                result.type = IntersectionType.EMPTY;
                result.status = IntersectionResult.INVALID;
                return false;
            }

            Vector2 s = Vector2.Zero;
            // 교차 유형 판단

            IntersectLine2Line2 l2l2 = new(line, new Line2f(segment.center, segment.direction));
            result.type = l2l2.result.type;

            if (result.type == IntersectionType.POINT)
            { // 점 교차이면
                if (Math.Abs(s[1]) <= segment.extent + eps)
                { // 교차점이 허용오차를 고려한 default_nsegs 범위 내에 있으면
                    result.quantity = 1;
                    result.points = new List<Vector2>
                    {
                        line.origin + (s[0] * line.direction)
                    };
                    result.parameter1[0] = s[0];
                    result.type = IntersectionType.POINT;
                }
                else
                { // default_nsegs 범위를 벗어나면 교차하지 않음
                    result.quantity = 0;
                    result.type = IntersectionType.EMPTY;
                }
            }
            else if (result.type == IntersectionType.LINE)
            { // 직선과 선분이 겹치면
                result.type = IntersectionType.SEGMENT;
                result.parameter1[0] = s[0];
                result.quantity = int.MaxValue;
            }
            else
            { // 평행하여 교차하지 않음
                result.quantity = 0;
            }

            result.status = result.type != IntersectionType.EMPTY ?
                IntersectionResult.INTERSECT :
                IntersectionResult.NOTINTERSECT;

            return result.status == IntersectionResult.INTERSECT;
        }
    }
}