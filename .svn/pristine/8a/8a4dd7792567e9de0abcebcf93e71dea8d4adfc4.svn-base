using OpenTK.Graphics.OpenGL4;
using System;
using System.Buffers;
using System.Runtime.CompilerServices;

namespace IGX.ViewControl.Buffer.Common
{
    public class MutableBuffer<T> : GLBuffer<T> where T : struct
    {
        private readonly object _lock = new();
        private T[]? _cpuData;
        private int _cpuDataCapacity;
        private readonly bool _keepCpuData;
        public bool keepCpuData => _keepCpuData;
        public Span<T> CpuData
        {
            get
            {
                lock (_lock)
                {
                    return _keepCpuData ? _cpuData.AsSpan(0, Count) : Span<T>.Empty;
                }
            }
        }
        public void SyncToGpu(int startIndex, int length)
        {
            if (!_keepCpuData || _cpuData == null)
                throw new InvalidOperationException("CPU _instancedBuffer is not maintained.");
            if (!IsContextLikelyActive())
                throw new InvalidOperationException("Cannot sync to GPU without an active OpenGL context.");

            lock (_lock)
            {
                base.UpdateData(_cpuData.AsSpan(startIndex, length), (nint)(startIndex * Unsafe.SizeOf<T>()));
            }
        }
        public MutableBuffer(ReadOnlySpan<T> data, BufferTarget target, BufferUsageHint usageHint, bool keepCpuData = true)
            : base(target, usageHint)
        {
            _keepCpuData = keepCpuData;
            if (_keepCpuData)
            {
                _cpuDataCapacity = data.Length;
                _cpuData = ArrayPool<T>.Shared.Rent(_cpuDataCapacity);
                data.CopyTo(_cpuData.AsSpan());
            }

            base.SetData(data);
        }

        private void EnsureCpuBuffer(int requiredSize)
        {
            lock (_lock)
            {
                if (!_keepCpuData)
                {
                    throw new InvalidOperationException("CPU _instancedBuffer is not maintained.");
                }

                if (requiredSize > _cpuDataCapacity)
                {
                    var newCapacity = Math.Max(requiredSize, _cpuDataCapacity == 0 ? 4 : _cpuDataCapacity * 2);
                    var newBuffer = ArrayPool<T>.Shared.Rent(newCapacity);

                    if (_cpuData != null)
                    {
                        _cpuData.AsSpan(0, Count).CopyTo(newBuffer.AsSpan());
                        ArrayPool<T>.Shared.Return(_cpuData, true);
                    }

                    _cpuData = newBuffer;
                    _cpuDataCapacity = newCapacity;
                }
            }
        }

        public void Resize(int newSize)
        {
            if (newSize == Count) return;

            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot resize _instancedBuffer without an active OpenGL context.");
            }

            lock (_lock)
            {
                var oldSize = Count;
                EnsureCpuBuffer(newSize);

                if (_cpuData != null && newSize < oldSize)
                {
                    _cpuData.AsSpan(newSize, oldSize - newSize).Clear();
                }

                Count = newSize;

                try
                {
                    Bind();
                    GL.BufferData(BufferTarget, new nint(newSize * Unsafe.SizeOf<T>()), IntPtr.Zero, BufferUsageHint);
                    if (_cpuData != null && newSize > 0)
                    {
                        base.UpdateData(_cpuData.AsSpan(0, Math.Min(newSize, oldSize)), 0);
                    }
                    Unbind();
                }
                catch (InvalidOperationException ex)
                {
                    throw new InvalidOperationException("Failed to resize GPU _instancedBuffer.", ex);
                }
            }
        }

        public void Add(ReadOnlySpan<T> data)
        {
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot add data without an active OpenGL context.");
            }

            lock (_lock)
            {
                var newCount = Count + data.Length;
                EnsureCpuBuffer(newCount);

                if (_cpuData != null)
                {
                    data.CopyTo(_cpuData.AsSpan(Count));
                }

                try
                {
                    base.UpdateData(data, (nint)(Count * Unsafe.SizeOf<T>()));
                    Count = newCount;
                }
                catch (InvalidOperationException ex)
                {
                    throw new InvalidOperationException("Failed to add data to GPU _instancedBuffer.", ex);
                }
            }
        }

        public void RemoveAt(int index)
        {
            if (index < 0 || index >= Count)
            {
                throw new ArgumentOutOfRangeException(nameof(index), "Index is out of range.");
            }

            lock (_lock)
            {
                if (_keepCpuData && _cpuData != null)
                {
                    var newCount = Count - 1;
                    if (index < newCount)
                    {
                        _cpuData.AsSpan(index + 1, newCount - index).CopyTo(_cpuData.AsSpan(index));
                    }
                    Count = newCount;

                    if (IsContextLikelyActive())
                    {
                        RevertAll();
                    }
                    else
                    {
                        Console.WriteLine("Warning: GPU _instancedBuffer not updated due to missing OpenGL context. Call RevertAll() later.");
                    }
                }
                else
                {
                    throw new InvalidOperationException("Cannot remove data when CPU _instancedBuffer is not maintained.");
                }
            }
        }

        public void RevertAll()
        {
            if (!_keepCpuData)
            {
                throw new InvalidOperationException("Cannot revert data when CPU _instancedBuffer is not maintained.");
            }

            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot revert data without an active OpenGL context.");
            }

            lock (_lock)
            {
                if (_cpuData != null)
                {
                    base.SetData(_cpuData.AsSpan(0, Count));
                }
            }
        }

        public void RevertInstance(int index)
        {
            if (!_keepCpuData)
            {
                throw new InvalidOperationException("Cannot revert instance when CPU _instancedBuffer is not maintained.");
            }

            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot revert instance without an active OpenGL context.");
            }

            lock (_lock)
            {
                if (_cpuData != null && index >= 0 && index < Count)
                {
                    base.UpdateData(_cpuData.AsSpan(index, 1), (nint)(index * Unsafe.SizeOf<T>()));
                }
            }
        }

        public void UpdateInstance(int index, T newData)
        {
            if (!_keepCpuData)
            {
                throw new InvalidOperationException("Cannot update instance when CPU _instancedBuffer is not maintained.");
            }

            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot update instance without an active OpenGL context.");
            }

            lock (_lock)
            {
                if (_cpuData != null && index >= 0 && index < Count)
                {
                    _cpuData[index] = newData;
                    base.UpdateData(new ReadOnlySpan<T>(new[] { newData }), (nint)(index * Unsafe.SizeOf<T>()));
                }
            }
        }

        public override unsafe void UpdateData(ReadOnlySpan<T> data, nint offset = default)
        {
            if (!IsContextLikelyActive())
            {
                throw new InvalidOperationException("Cannot update data without an active OpenGL context.");
            }

            lock (_lock)
            {
                base.UpdateData(data, offset);
            }
        }

        public override ReadOnlySpan<T> GetData()
        {
            lock (_lock)
            {
                if (!_keepCpuData)
                {
                    return base.GetData();
                }
                return _cpuData.AsSpan(0, Count);
            }
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing && _cpuData != null)
            {
                ArrayPool<T>.Shared.Return(_cpuData, true);
                _cpuData = null;
                _cpuDataCapacity = 0;
            }
            base.Dispose(disposing);
        }
        private static bool IsContextLikelyActive()
        {
            try
            {
                GL.GetError();
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}