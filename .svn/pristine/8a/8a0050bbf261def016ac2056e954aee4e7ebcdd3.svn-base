using OpenTK.Mathematics;
using IGX.Geometry.Common;

namespace IGX.Geometry.Intersect
{
    class IntersectRay3Triangle3
    {
        Ray3f ray;
        Triangle3f triangle;

        public int Quantity = 0;
        public IntersectionResult Result = IntersectionResult.NOTCOMPUTED;
        public IntersectionType Type = IntersectionType.EMPTY;

        public float RayParameter;
        public Vector3 TriangleBaryCoords;

        public Ray3f Ray
        {
            get { return ray; }
            set
            {
                ray = value;
                Result = IntersectionResult.NOTCOMPUTED;
            }
        }

        public Triangle3f Triangle
        {
            get { return triangle; }
            set { triangle = value; Result = IntersectionResult.NOTCOMPUTED; }
        }

        public bool IsSimpleIntersection
        {
            get { return Result == IntersectionResult.INTERSECT && Type == IntersectionType.POINT; }
        }

        public IntersectRay3Triangle3(Ray3f r, Triangle3f t)
        {
            ray = r; triangle = t;
        }

        public bool Compute()
        {
            return Find();
            //return this;
        }

        public bool Find()
        {
            if (Result != IntersectionResult.NOTCOMPUTED)
            {
                return Result != IntersectionResult.NOTINTERSECT;
            }

            Vector3 diff = ray.origin - triangle.V0;
            Vector3 edge1 = triangle.V1 - triangle.V0;
            Vector3 edge2 = triangle.V2 - triangle.V0;
            Vector3 normal = edge1.Cross(edge2);

            // Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            float DdN = Vector3.Dot(ray.direction, normal);
            float sign;
            if (DdN > MathUtil.ZeroTolerance)
            {
                sign = 1;
            }
            else if (DdN < -MathUtil.ZeroTolerance)
            {
                sign = -1;
                DdN = -DdN;
            }
            else
            {
                Result = IntersectionResult.NOTINTERSECT;
                return false;
            }

            float DdQxE2 = sign * Vector3.Dot(ray.direction, diff.Cross(edge2));
            if (DdQxE2 >= 0)
            {
                float DdE1xQ = sign * Vector3.Dot(ray.direction, edge1.Cross(diff));
                if (DdE1xQ >= 0)
                {
                    if (DdQxE2 + DdE1xQ <= DdN)
                    {
                        float QdN = -sign * Vector3.Dot(diff, normal);
                        if (QdN >= 0)
                        {
                            float inv = 1 / DdN;
                            RayParameter = QdN * inv;
                            float mTriBary1 = DdQxE2 * inv;
                            float mTriBary2 = DdE1xQ * inv;
                            TriangleBaryCoords = new Vector3(1 - mTriBary1 - mTriBary2, mTriBary1, mTriBary2);
                            Type = IntersectionType.POINT;
                            Quantity = 1;
                            Result = IntersectionResult.INTERSECT;
                            return true;
                        }
                        // else: t < 0, 교점 없음
                    }
                    // else: b1+b2 > 1, 교점 없음
                }
                // else: b2 < 0, 교점 없음
            }
            // else: b1 < 0, 교점 없음

            Result = IntersectionResult.NOTINTERSECT;
            return false;
        }

        public static bool Intersects(ref Ray3f ray, ref Vector3 V0, ref Vector3 V1, ref Vector3 V2, out float rayT)
        {
            // Compute the OffsetSurface origin, halfedgeSet, and norID.
            Vector3 diff = ray.origin - V0;
            Vector3 edge1 = V1 - V0;
            Vector3 edge2 = V2 - V0;
            Vector3 normal = edge1.Cross(edge2);

            rayT = float.MaxValue;

            // Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            float DdN = Vector3.Dot(ray.direction, normal);
            float sign;
            if (DdN > MathUtil.ZeroTolerance)
            {
                sign = 1;
            }
            else if (DdN < -MathUtil.ZeroTolerance)
            {
                sign = -1;
                DdN = -DdN;
            }
            else
            {
                return false;
            }

            Vector3 cross = diff.Cross(edge2);
            float DdQxE2 = sign * Vector3.Dot(ray.direction, cross);
            if (DdQxE2 >= 0)
            {
                cross = edge1.Cross(diff);
                float DdE1xQ = sign * Vector3.Dot(ray.direction, cross);
                if (DdE1xQ >= 0)
                {
                    if (DdQxE2 + DdE1xQ <= DdN)
                    {
                        float QdN = -sign * Vector3.Dot(diff, normal);
                        if (QdN >= 0)
                        {
                            float inv = 1f / DdN;
                            rayT = QdN * inv;
                            return true;
                        }
                        // else: t < 0, 교점 없음
                    }
                    // else: b1+b2 > 1, 교점 없음
                }
                // else: b2 < 0, 교점 없음
            }
            // else: b1 < 0, 교점 없음

            return false;
        }
    }
}
